{"version":"2.1.0","runs":[{"invocations":[{"executionSuccessful":true,"toolExecutionNotifications":[]}],"results":[{"fingerprints":{"matchBasedId/v1":"c93764ff27a88fe9b80240cab30c10dd73e03099c3f7e84c0ef97c8d7c80a53b0f4e25d8a598da1c3c21a282ca818745b1c4d327e190edcf4d5eaa62de9b37ca_0"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"/content/OWASP DATASET CLEANED/cleaned_Test_Cases/BenchmarkTest00001.java","uriBaseId":"%SRCROOT%"},"region":{"endColumn":40,"endLine":24,"snippet":{"text":"        response.addCookie(userCookie);"},"startColumn":9,"startLine":24}}}],"message":{"text":"A cookie was detected without setting the 'HttpOnly' flag. The 'HttpOnly' flag for cookies instructs the browser to forbid client-side scripts from reading the cookie. Set the 'HttpOnly' flag by calling 'cookie.setHttpOnly(true);'"},"properties":{},"ruleId":"java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly"},{"fingerprints":{"matchBasedId/v1":"1e66e9ff31851d55c5ae31b2808099a16c8f3f4e1fd2a7483b5ea1ed1cb2e14c95f1a93e98434fae006d4cb85feeb8ec12df063b5ad81650edbca0fa36a6254e_0"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"/content/OWASP DATASET CLEANED/cleaned_Test_Cases/BenchmarkTest00001.java","uriBaseId":"%SRCROOT%"},"region":{"endColumn":74,"endLine":53,"snippet":{"text":"            fis = new java.io.FileInputStream(new java.io.File(fileName));"},"startColumn":19,"startLine":53}}}],"message":{"text":"The application dynamically constructs file or path information. If the path\ninformation comes from user input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or replacing it with unique values and\nuse `Path.resolve` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `Path.resolve` and not allowing direct user input:\n```\n// Class to store our user data along with a randomly generated file name\npublic static class UserData {\n    private String userFileNameUnsafe;\n    private String fileName;\n    public UserData(String userFileName) {\n        this.userFileNameUnsafe = userFileName;\n        // Generate a random ID for the filename\n        this.fileName = UUID.randomUUID().toString();\n    }\n    public String getUserFileNameUnsafe() { return userFileNameUnsafe; };\n    public String getFileName() { return fileName; };\n}\n\npublic static void main(String[] args) throws Exception {\n    // User input, saved only as a reference\n    UserData userData = new UserData(\"..\\\\test.txt\");\n    // Restrict all file processing to this directory only\n    String base = \"/var/app/restricted\";\n    Path basePath = Paths.get(base);\n    // Resolve the full path, but only use our random generated filename\n    Path fullPath = basePath.resolve(userData.getFileName());\n    // verify the path is contained within our basePath\n    if (!fullPath.startsWith(base)) {\n        throw new Exception(\"Invalid path specified!\");\n    }\n    // process / work with file\n}\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n"},"properties":{},"ruleId":"gitlab.find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1"},{"fingerprints":{"matchBasedId/v1":"f997ec6f8a3d6efb86d80151a70dfcc61f451874ee61ae1507dd1e29a3c18f91ef5a6f82611a325b40ac3101b6e4e80459404fe7a0d2f9652a436b9cc9573329_0"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"/content/OWASP DATASET CLEANED/cleaned_Test_Cases/BenchmarkTest00001.java","uriBaseId":"%SRCROOT%"},"region":{"endColumn":74,"endLine":53,"snippet":{"text":"            fis = new java.io.FileInputStream(new java.io.File(fileName));"},"startColumn":19,"startLine":53}}}],"message":{"text":"Detected a potential path traversal. A malicious actor could control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are sanitized. You may also consider using a utility method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file name from the path."},"properties":{},"ruleId":"java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal"},{"fingerprints":{"matchBasedId/v1":"1e66e9ff31851d55c5ae31b2808099a16c8f3f4e1fd2a7483b5ea1ed1cb2e14c95f1a93e98434fae006d4cb85feeb8ec12df063b5ad81650edbca0fa36a6254e_1"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"/content/OWASP DATASET CLEANED/cleaned_Test_Cases/BenchmarkTest00001.java","uriBaseId":"%SRCROOT%"},"region":{"endColumn":73,"endLine":53,"snippet":{"text":"            fis = new java.io.FileInputStream(new java.io.File(fileName));"},"startColumn":47,"startLine":53}}}],"message":{"text":"The application dynamically constructs file or path information. If the path\ninformation comes from user input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or replacing it with unique values and\nuse `Path.resolve` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `Path.resolve` and not allowing direct user input:\n```\n// Class to store our user data along with a randomly generated file name\npublic static class UserData {\n    private String userFileNameUnsafe;\n    private String fileName;\n    public UserData(String userFileName) {\n        this.userFileNameUnsafe = userFileName;\n        // Generate a random ID for the filename\n        this.fileName = UUID.randomUUID().toString();\n    }\n    public String getUserFileNameUnsafe() { return userFileNameUnsafe; };\n    public String getFileName() { return fileName; };\n}\n\npublic static void main(String[] args) throws Exception {\n    // User input, saved only as a reference\n    UserData userData = new UserData(\"..\\\\test.txt\");\n    // Restrict all file processing to this directory only\n    String base = \"/var/app/restricted\";\n    Path basePath = Paths.get(base);\n    // Resolve the full path, but only use our random generated filename\n    Path fullPath = basePath.resolve(userData.getFileName());\n    // verify the path is contained within our basePath\n    if (!fullPath.startsWith(base)) {\n        throw new Exception(\"Invalid path specified!\");\n    }\n    // process / work with file\n}\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n"},"properties":{},"ruleId":"gitlab.find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1"}],"tool":{"driver":{"name":"Semgrep OSS","rules":[{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Constructing SimpleDB queries containing user input can allow an attacker to view unauthorized\nrecords.\n"},"help":{"markdown":"Constructing SimpleDB queries containing user input can allow an attacker to view unauthorized\nrecords.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.AWS_QUERY_INJECTION-1)\n","text":"Constructing SimpleDB queries containing user input can allow an attacker to view unauthorized\nrecords.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.AWS_QUERY_INJECTION-1","id":"gitlab.find_sec_bugs.AWS_QUERY_INJECTION-1","name":"gitlab.find_sec_bugs.AWS_QUERY_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-943","security"]},"shortDescription":{"text":"Improper Neutralization of Special Elements in Data Query Logic"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application is using `Integer.toHexString` on a digest array buffer which\nmay lead to an incorrect version of values.\n\nConsider using the `java.util.HexFormat` object introduced in Java 17. For older Java applications\nconsider using the `javax.xml.bind.DatatypeConverter`.\n\nExample using `HexFormat` to create a human-readable string:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(\"some input\".getBytes(StandardCharsets.UTF_8));\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// Create a JDK 17 HexFormat object\nHexFormat hex = HexFormat.of();\n// Use formatHex on the byte array to create a string (note that alphabet characters are\nlowercase)\nString hexString = hex.formatHex(output);\n```\n\nFor more information on DatatypeConverter see:\nhttps://docs.oracle.com/javase/9/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary-byte:A-\n"},"help":{"markdown":"The application is using `Integer.toHexString` on a digest array buffer which\nmay lead to an incorrect version of values.\n\nConsider using the `java.util.HexFormat` object introduced in Java 17. For older Java applications\nconsider using the `javax.xml.bind.DatatypeConverter`.\n\nExample using `HexFormat` to create a human-readable string:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(\"some input\".getBytes(StandardCharsets.UTF_8));\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// Create a JDK 17 HexFormat object\nHexFormat hex = HexFormat.of();\n// Use formatHex on the byte array to create a string (note that alphabet characters are\nlowercase)\nString hexString = hex.formatHex(output);\n```\n\nFor more information on DatatypeConverter see:\nhttps://docs.oracle.com/javase/9/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary-byte:A-\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.BAD_HEXA_CONVERSION-1)\n","text":"The application is using `Integer.toHexString` on a digest array buffer which\nmay lead to an incorrect version of values.\n\nConsider using the `java.util.HexFormat` object introduced in Java 17. For older Java applications\nconsider using the `javax.xml.bind.DatatypeConverter`.\n\nExample using `HexFormat` to create a human-readable string:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(\"some input\".getBytes(StandardCharsets.UTF_8));\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// Create a JDK 17 HexFormat object\nHexFormat hex = HexFormat.of();\n// Use formatHex on the byte array to create a string (note that alphabet characters are\nlowercase)\nString hexString = hex.formatHex(output);\n```\n\nFor more information on DatatypeConverter see:\nhttps://docs.oracle.com/javase/9/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary-byte:A-\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.BAD_HEXA_CONVERSION-1","id":"gitlab.find_sec_bugs.BAD_HEXA_CONVERSION-1","name":"gitlab.find_sec_bugs.BAD_HEXA_CONVERSION-1","properties":{"precision":"very-high","tags":["CWE-704","HIGH CONFIDENCE","OWASP-A05:2021-Security Misconfiguration","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"Info"},"shortDescription":{"text":"Incorrect type conversion or cast"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"An attacker can set arbitrary bean properties that can compromise system integrity. An\nattacker can leverage this functionality to access special bean properties like\nclass.classLoader that will allow them to override system properties and potentially execute\narbitrary code.\n"},"help":{"markdown":"An attacker can set arbitrary bean properties that can compromise system integrity. An\nattacker can leverage this functionality to access special bean properties like\nclass.classLoader that will allow them to override system properties and potentially execute\narbitrary code.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.BEAN_PROPERTY_INJECTION-1)\n","text":"An attacker can set arbitrary bean properties that can compromise system integrity. An\nattacker can leverage this functionality to access special bean properties like\nclass.classLoader that will allow them to override system properties and potentially execute\narbitrary code.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.BEAN_PROPERTY_INJECTION-1","id":"gitlab.find_sec_bugs.BEAN_PROPERTY_INJECTION-1","name":"gitlab.find_sec_bugs.BEAN_PROPERTY_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-15","security"]},"shortDescription":{"text":"External Control of System or Configuration Setting"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The Blowfish encryption algorithm was meant as a drop-in replacement for DES and was created in\n1993. Smaller key sizes may make the ciphertext vulnerable to [birthday\nattacks](https://en.wikipedia.org/wiki/Birthday_attack). While no known attacks against\nBlowfish\nexist, it should never be used to encrypt files over 4GB in size. If possible consider\nusing AES as the instance of `KeyGenerator` instead of Blowfish.\n\nTo remediate the small key size, pass a value such as 256 to the `KeyGenerator.init(keySize)`\nmethod.\n\nExample setting a larger key size and changing to `KeyGenerator` to AES:\n```\npublic static void aesKeyGenerator() throws java.security.NoSuchAlgorithmException {\n    // Use the AES algorithm for key generation\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n\n    // Set the key size here\n    keyGenerator.init(256);\n\n    // get the raw bytes of the key\n    byte[] key = keyGenerator.generateKey().getEncoded();\n\n    // pass the key bytes to create a SecretKeySpec\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n}\n```\n\nExample setting a larger key size for Blowfish:\n```\npublic static void blowFishKeyGenerator() throws java.security.NoSuchAlgorithmException {\n    // Use the Blowfish algorithm for key generation\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n\n    // Set the key size here\n    keyGenerator.init(256);\n\n    // get the raw bytes of the key\n    byte[] key = keyGenerator.generateKey().getEncoded();\n\n    // pass the key bytes to create a SecretKeySpec\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"Blowfish\");\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"The Blowfish encryption algorithm was meant as a drop-in replacement for DES and was created in\n1993. Smaller key sizes may make the ciphertext vulnerable to [birthday\nattacks](https://en.wikipedia.org/wiki/Birthday_attack). While no known attacks against\nBlowfish\nexist, it should never be used to encrypt files over 4GB in size. If possible consider\nusing AES as the instance of `KeyGenerator` instead of Blowfish.\n\nTo remediate the small key size, pass a value such as 256 to the `KeyGenerator.init(keySize)`\nmethod.\n\nExample setting a larger key size and changing to `KeyGenerator` to AES:\n```\npublic static void aesKeyGenerator() throws java.security.NoSuchAlgorithmException {\n    // Use the AES algorithm for key generation\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n\n    // Set the key size here\n    keyGenerator.init(256);\n\n    // get the raw bytes of the key\n    byte[] key = keyGenerator.generateKey().getEncoded();\n\n    // pass the key bytes to create a SecretKeySpec\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n}\n```\n\nExample setting a larger key size for Blowfish:\n```\npublic static void blowFishKeyGenerator() throws java.security.NoSuchAlgorithmException {\n    // Use the Blowfish algorithm for key generation\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n\n    // Set the key size here\n    keyGenerator.init(256);\n\n    // get the raw bytes of the key\n    byte[] key = keyGenerator.generateKey().getEncoded();\n\n    // pass the key bytes to create a SecretKeySpec\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"Blowfish\");\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.BLOWFISH_KEY_SIZE-1)\n","text":"The Blowfish encryption algorithm was meant as a drop-in replacement for DES and was created in\n1993. Smaller key sizes may make the ciphertext vulnerable to [birthday\nattacks](https://en.wikipedia.org/wiki/Birthday_attack). While no known attacks against\nBlowfish\nexist, it should never be used to encrypt files over 4GB in size. If possible consider\nusing AES as the instance of `KeyGenerator` instead of Blowfish.\n\nTo remediate the small key size, pass a value such as 256 to the `KeyGenerator.init(keySize)`\nmethod.\n\nExample setting a larger key size and changing to `KeyGenerator` to AES:\n```\npublic static void aesKeyGenerator() throws java.security.NoSuchAlgorithmException {\n    // Use the AES algorithm for key generation\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n\n    // Set the key size here\n    keyGenerator.init(256);\n\n    // get the raw bytes of the key\n    byte[] key = keyGenerator.generateKey().getEncoded();\n\n    // pass the key bytes to create a SecretKeySpec\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n}\n```\n\nExample setting a larger key size for Blowfish:\n```\npublic static void blowFishKeyGenerator() throws java.security.NoSuchAlgorithmException {\n    // Use the Blowfish algorithm for key generation\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n\n    // Set the key size here\n    keyGenerator.init(256);\n\n    // get the raw bytes of the key\n    byte[] key = keyGenerator.generateKey().getEncoded();\n\n    // pass the key bytes to create a SecretKeySpec\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"Blowfish\");\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.BLOWFISH_KEY_SIZE-1","id":"gitlab.find_sec_bugs.BLOWFISH_KEY_SIZE-1","name":"gitlab.find_sec_bugs.BLOWFISH_KEY_SIZE-1","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Cryptographic algorithms provide many different modes of operation, only some of which provide\nmessage integrity. Without message integrity it could be possible for an adversary to attempt\nto tamper with the ciphertext which could lead to compromising the encryption key. Newer\nalgorithms\napply message integrity to validate ciphertext has not been tampered with.\n\nInstead of using an algorithm that requires configuring a cipher mode, an algorithm\nthat has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n// Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"Cryptographic algorithms provide many different modes of operation, only some of which provide\nmessage integrity. Without message integrity it could be possible for an adversary to attempt\nto tamper with the ciphertext which could lead to compromising the encryption key. Newer\nalgorithms\napply message integrity to validate ciphertext has not been tampered with.\n\nInstead of using an algorithm that requires configuring a cipher mode, an algorithm\nthat has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n// Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.CIPHER_INTEGRITY-1)\n","text":"Cryptographic algorithms provide many different modes of operation, only some of which provide\nmessage integrity. Without message integrity it could be possible for an adversary to attempt\nto tamper with the ciphertext which could lead to compromising the encryption key. Newer\nalgorithms\napply message integrity to validate ciphertext has not been tampered with.\n\nInstead of using an algorithm that requires configuring a cipher mode, an algorithm\nthat has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n// Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.CIPHER_INTEGRITY-1","id":"gitlab.find_sec_bugs.CIPHER_INTEGRITY-1","name":"gitlab.find_sec_bugs.CIPHER_INTEGRITY-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"OS command injection is a critical vulnerability that can lead to a full system\ncompromise as it may allow an adversary to pass in arbitrary commands or arguments\nto be executed.\n\nUser input should never be used in constructing commands or command arguments\nto functions which execute OS commands. This includes filenames supplied by\nuser uploads or downloads.\n\nEnsure your application does not:\n\n- Use user-supplied information in the process name to execute.\n- Use user-supplied information in an OS command execution function which does\nnot escape shell meta-characters.\n- Use user-supplied information in arguments to OS commands.\n\nThe application should have a hardcoded set of arguments that are to be passed\nto OS commands. If filenames are being passed to these functions, it is\nrecommended that a hash of the filename be used instead, or some other unique\nidentifier. It is strongly recommended that a native library that implements\nthe same functionality be used instead of using OS system commands, due to the\nrisk of unknown attacks against third party commands.\n\nWhen specifying the OS command, ensure the application uses the full path\ninformation, otherwise the OS may attempt to look up which process to execute\nand could be vulnerable to untrusted search path vulnerabilities (CWE-426).\n\nExample of safely executing an OS command:\n```\npublic static void executeCommand(String userFileData) throws java.io.IOException {\n    // Generate a random filename, do not use user input\n    String fileName = UUID.randomUUID().toString();\n    // Create a Buffered/FileWriter\n    BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));\n    // Write the user content to our random file\n    writer.write(userFileData);\n    // Close the file to flush contents\n    writer.close();\n    // Create the process builder with a hardcoded path to the binary, and our randomly\ngenerated filename\n    ProcessBuilder processBuilder = new ProcessBuilder(\"/opt/app/path\", fileName);\n    // Start the process\n    Process process = processBuilder.start();\n    // Handle/redirect output of process here\n    // ...\n}\n```\n\nFor more information on OS command injection, see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html\n"},"help":{"markdown":"OS command injection is a critical vulnerability that can lead to a full system\ncompromise as it may allow an adversary to pass in arbitrary commands or arguments\nto be executed.\n\nUser input should never be used in constructing commands or command arguments\nto functions which execute OS commands. This includes filenames supplied by\nuser uploads or downloads.\n\nEnsure your application does not:\n\n- Use user-supplied information in the process name to execute.\n- Use user-supplied information in an OS command execution function which does\nnot escape shell meta-characters.\n- Use user-supplied information in arguments to OS commands.\n\nThe application should have a hardcoded set of arguments that are to be passed\nto OS commands. If filenames are being passed to these functions, it is\nrecommended that a hash of the filename be used instead, or some other unique\nidentifier. It is strongly recommended that a native library that implements\nthe same functionality be used instead of using OS system commands, due to the\nrisk of unknown attacks against third party commands.\n\nWhen specifying the OS command, ensure the application uses the full path\ninformation, otherwise the OS may attempt to look up which process to execute\nand could be vulnerable to untrusted search path vulnerabilities (CWE-426).\n\nExample of safely executing an OS command:\n```\npublic static void executeCommand(String userFileData) throws java.io.IOException {\n    // Generate a random filename, do not use user input\n    String fileName = UUID.randomUUID().toString();\n    // Create a Buffered/FileWriter\n    BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));\n    // Write the user content to our random file\n    writer.write(userFileData);\n    // Close the file to flush contents\n    writer.close();\n    // Create the process builder with a hardcoded path to the binary, and our randomly\ngenerated filename\n    ProcessBuilder processBuilder = new ProcessBuilder(\"/opt/app/path\", fileName);\n    // Start the process\n    Process process = processBuilder.start();\n    // Handle/redirect output of process here\n    // ...\n}\n```\n\nFor more information on OS command injection, see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.COMMAND_INJECTION-1)\n","text":"OS command injection is a critical vulnerability that can lead to a full system\ncompromise as it may allow an adversary to pass in arbitrary commands or arguments\nto be executed.\n\nUser input should never be used in constructing commands or command arguments\nto functions which execute OS commands. This includes filenames supplied by\nuser uploads or downloads.\n\nEnsure your application does not:\n\n- Use user-supplied information in the process name to execute.\n- Use user-supplied information in an OS command execution function which does\nnot escape shell meta-characters.\n- Use user-supplied information in arguments to OS commands.\n\nThe application should have a hardcoded set of arguments that are to be passed\nto OS commands. If filenames are being passed to these functions, it is\nrecommended that a hash of the filename be used instead, or some other unique\nidentifier. It is strongly recommended that a native library that implements\nthe same functionality be used instead of using OS system commands, due to the\nrisk of unknown attacks against third party commands.\n\nWhen specifying the OS command, ensure the application uses the full path\ninformation, otherwise the OS may attempt to look up which process to execute\nand could be vulnerable to untrusted search path vulnerabilities (CWE-426).\n\nExample of safely executing an OS command:\n```\npublic static void executeCommand(String userFileData) throws java.io.IOException {\n    // Generate a random filename, do not use user input\n    String fileName = UUID.randomUUID().toString();\n    // Create a Buffered/FileWriter\n    BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));\n    // Write the user content to our random file\n    writer.write(userFileData);\n    // Close the file to flush contents\n    writer.close();\n    // Create the process builder with a hardcoded path to the binary, and our randomly\ngenerated filename\n    ProcessBuilder processBuilder = new ProcessBuilder(\"/opt/app/path\", fileName);\n    // Start the process\n    Process process = processBuilder.start();\n    // Handle/redirect output of process here\n    // ...\n}\n```\n\nFor more information on OS command injection, see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.COMMAND_INJECTION-1","id":"gitlab.find_sec_bugs.COMMAND_INJECTION-1","name":"gitlab.find_sec_bugs.COMMAND_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-78","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"High"},"shortDescription":{"text":"Improper neutralization of special elements used in an OS command ('OS Command Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Storing sensitive data in a persistent cookie for an extended period can lead to a breach of\nconfidentiality or account compromise.\n"},"help":{"markdown":"Storing sensitive data in a persistent cookie for an extended period can lead to a breach of\nconfidentiality or account compromise.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.COOKIE_PERSISTENT-1)\n","text":"Storing sensitive data in a persistent cookie for an extended period can lead to a breach of\nconfidentiality or account compromise.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.COOKIE_PERSISTENT-1","id":"gitlab.find_sec_bugs.COOKIE_PERSISTENT-1","name":"gitlab.find_sec_bugs.COOKIE_PERSISTENT-1","properties":{"precision":"very-high","tags":["CWE-614","security"]},"shortDescription":{"text":"Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The information stored in a custom cookie should not be sensitive or related to the session.\nIn most cases, sensitive data should only be stored in session and referenced by the user's\nsession cookie.\n"},"help":{"markdown":"The information stored in a custom cookie should not be sensitive or related to the session.\nIn most cases, sensitive data should only be stored in session and referenced by the user's\nsession cookie.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.COOKIE_USAGE-1)\n","text":"The information stored in a custom cookie should not be sensitive or related to the session.\nIn most cases, sensitive data should only be stored in session and referenced by the user's\nsession cookie.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.COOKIE_USAGE-1","id":"gitlab.find_sec_bugs.COOKIE_USAGE-1","name":"gitlab.find_sec_bugs.COOKIE_USAGE-1","properties":{"precision":"very-high","tags":["CWE-614","security"]},"shortDescription":{"text":"Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application was found to take data from user input and output it into a logger method.\nWhen data from\nan untrusted source is sent to a logger without validation, an attacker could forge log\nentries\nor include malicious content. If the log file is processed automatically, the attacker can\nrender the file unusable by corrupting the format of the file or injecting unexpected\ncharacters. An attacker may also inject code or other commands into the log file and take\nadvantage of a vulnerability in the log processing utility (e.g. command injection or XSS).\n\nTo mitigate this issue, encode values that come from user input with a package such as\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:\n```\npublic String escapeValue(String value) {\n  return StringEscapeUtils.escapeJava(value);\n}\n```\n\nFor more information on log injection see OWASP:\nhttps://owasp.org/www-community/attacks/Log_Injection\n"},"help":{"markdown":"The application was found to take data from user input and output it into a logger method.\nWhen data from\nan untrusted source is sent to a logger without validation, an attacker could forge log\nentries\nor include malicious content. If the log file is processed automatically, the attacker can\nrender the file unusable by corrupting the format of the file or injecting unexpected\ncharacters. An attacker may also inject code or other commands into the log file and take\nadvantage of a vulnerability in the log processing utility (e.g. command injection or XSS).\n\nTo mitigate this issue, encode values that come from user input with a package such as\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:\n```\npublic String escapeValue(String value) {\n  return StringEscapeUtils.escapeJava(value);\n}\n```\n\nFor more information on log injection see OWASP:\nhttps://owasp.org/www-community/attacks/Log_Injection\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.CRLF_INJECTION_LOGS-1)\n","text":"The application was found to take data from user input and output it into a logger method.\nWhen data from\nan untrusted source is sent to a logger without validation, an attacker could forge log\nentries\nor include malicious content. If the log file is processed automatically, the attacker can\nrender the file unusable by corrupting the format of the file or injecting unexpected\ncharacters. An attacker may also inject code or other commands into the log file and take\nadvantage of a vulnerability in the log processing utility (e.g. command injection or XSS).\n\nTo mitigate this issue, encode values that come from user input with a package such as\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:\n```\npublic String escapeValue(String value) {\n  return StringEscapeUtils.escapeJava(value);\n}\n```\n\nFor more information on log injection see OWASP:\nhttps://owasp.org/www-community/attacks/Log_Injection\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.CRLF_INJECTION_LOGS-1","id":"gitlab.find_sec_bugs.CRLF_INJECTION_LOGS-1","name":"gitlab.find_sec_bugs.CRLF_INJECTION_LOGS-1","properties":{"precision":"very-high","tags":["CWE-93","security"]},"shortDescription":{"text":"Improper neutralization of CRLF sequences ('CRLF Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `>` or `<` comparison\noperators. In these cases, do not use a user supplied `>` or `<` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n"},"help":{"markdown":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `>` or `<` comparison\noperators. In these cases, do not use a user supplied `>` or `<` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.CUSTOM_INJECTION-1)\n","text":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `>` or `<` comparison\noperators. In these cases, do not use a user supplied `>` or `<` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.CUSTOM_INJECTION-1","id":"gitlab.find_sec_bugs.CUSTOM_INJECTION-1","name":"gitlab.find_sec_bugs.CUSTOM_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-89","security"]},"shortDescription":{"text":"Improper neutralization of special elements used in an SQL command ('SQL Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The method identified is susceptible to injection. The input should be validated and properly\nescaped.\n"},"help":{"markdown":"The method identified is susceptible to injection. The input should be validated and properly\nescaped.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.CUSTOM_INJECTION-2)\n","text":"The method identified is susceptible to injection. The input should be validated and properly\nescaped.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.CUSTOM_INJECTION-2","id":"gitlab.find_sec_bugs.CUSTOM_INJECTION-2","name":"gitlab.find_sec_bugs.CUSTOM_INJECTION-2","properties":{"precision":"very-high","tags":["CWE-89","security"]},"shortDescription":{"text":"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found implementing a custom `java.security.MessageDigest`. It is\nstrongly recommended that a standard Digest algorithm be chosen instead as implementing\na digest by hand is error-prone. The National Institute of Standards and\nTechnology (NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\nSHA-512/256.\n\nExample of creating a SHA-384 hash:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(input);\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// output base64 encoded version of the hash\nSystem.out.println(\"hash: \" + Base64.getEncoder().encodeToString(output));\n```\n"},"help":{"markdown":"The application was found implementing a custom `java.security.MessageDigest`. It is\nstrongly recommended that a standard Digest algorithm be chosen instead as implementing\na digest by hand is error-prone. The National Institute of Standards and\nTechnology (NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\nSHA-512/256.\n\nExample of creating a SHA-384 hash:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(input);\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// output base64 encoded version of the hash\nSystem.out.println(\"hash: \" + Base64.getEncoder().encodeToString(output));\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.CUSTOM_MESSAGE_DIGEST-1)\n","text":"The application was found implementing a custom `java.security.MessageDigest`. It is\nstrongly recommended that a standard Digest algorithm be chosen instead as implementing\na digest by hand is error-prone. The National Institute of Standards and\nTechnology (NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\nSHA-512/256.\n\nExample of creating a SHA-384 hash:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(input);\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// output base64 encoded version of the hash\nSystem.out.println(\"hash: \" + Base64.getEncoder().encodeToString(output));\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.CUSTOM_MESSAGE_DIGEST-1","id":"gitlab.find_sec_bugs.CUSTOM_MESSAGE_DIGEST-1","name":"gitlab.find_sec_bugs.CUSTOM_MESSAGE_DIGEST-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A04:2021-Insecure Design","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found to permit the `RuntimePermission` of `createClassLoader`,\n`ReflectPermission` of `suppressAccessChecks`, or both.\n\nBy granting the `RuntimePermission` of `createClassLoader`, a compromised application\ncould instantiate their own class loaders and load arbitrary classes.\n\nBy granting the `ReflectPermission` of `suppressAccessChecks` an application will no longer\ncheck Java language access checks on fields and methods of a class. This will effectively\ngrant access to protected and private members.\n\nFor more information on `RuntimePermission` see:\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/RuntimePermission.html\n\nFor more information on `ReflectPermission` see:\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ReflectPermission.html\n"},"help":{"markdown":"The application was found to permit the `RuntimePermission` of `createClassLoader`,\n`ReflectPermission` of `suppressAccessChecks`, or both.\n\nBy granting the `RuntimePermission` of `createClassLoader`, a compromised application\ncould instantiate their own class loaders and load arbitrary classes.\n\nBy granting the `ReflectPermission` of `suppressAccessChecks` an application will no longer\ncheck Java language access checks on fields and methods of a class. This will effectively\ngrant access to protected and private members.\n\nFor more information on `RuntimePermission` see:\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/RuntimePermission.html\n\nFor more information on `ReflectPermission` see:\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ReflectPermission.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.DANGEROUS_PERMISSION_COMBINATION-1)\n","text":"The application was found to permit the `RuntimePermission` of `createClassLoader`,\n`ReflectPermission` of `suppressAccessChecks`, or both.\n\nBy granting the `RuntimePermission` of `createClassLoader`, a compromised application\ncould instantiate their own class loaders and load arbitrary classes.\n\nBy granting the `ReflectPermission` of `suppressAccessChecks` an application will no longer\ncheck Java language access checks on fields and methods of a class. This will effectively\ngrant access to protected and private members.\n\nFor more information on `RuntimePermission` see:\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/RuntimePermission.html\n\nFor more information on `ReflectPermission` see:\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ReflectPermission.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.DANGEROUS_PERMISSION_COMBINATION-1","id":"gitlab.find_sec_bugs.DANGEROUS_PERMISSION_COMBINATION-1","name":"gitlab.find_sec_bugs.DANGEROUS_PERMISSION_COMBINATION-1","properties":{"precision":"very-high","tags":["CWE-269","HIGH CONFIDENCE","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper privilege management"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The `org.apache.http.impl.client.DefaultHttpClient` does not verify the hostnames upon connection.\n\nThis allows for an adversary who is in between the application and the target host to intercept\npotentially sensitive information or transmit malicious data.\n\nDo not use the `org.apache.http.impl.client.DefaultHttpClient();` as it is deprecated. Instead\nuse the new `java.net.http.HttpClient` that was introduced in Java 9.\n\nExample connecting to a host that will automatically do TLS validation:\n```\n// Create a new java.net.http.HttpClient\nHttpClient httpClient = HttpClient.newHttpClient();\n// Create a HttpRequest builder\nHttpRequest request = HttpRequest.newBuilder()\n        // Create a URI for a website which requires TLS\n        .uri(URI.create(\"https://www.example.com/\"))\n        // Build the request\n        .build();\n\n// Use the httpClient to send the request and use an HttpResponse.BodyHandlers String type\nHttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n// Debug print\nSystem.out.println(response);\n```\n"},"help":{"markdown":"The `org.apache.http.impl.client.DefaultHttpClient` does not verify the hostnames upon connection.\n\nThis allows for an adversary who is in between the application and the target host to intercept\npotentially sensitive information or transmit malicious data.\n\nDo not use the `org.apache.http.impl.client.DefaultHttpClient();` as it is deprecated. Instead\nuse the new `java.net.http.HttpClient` that was introduced in Java 9.\n\nExample connecting to a host that will automatically do TLS validation:\n```\n// Create a new java.net.http.HttpClient\nHttpClient httpClient = HttpClient.newHttpClient();\n// Create a HttpRequest builder\nHttpRequest request = HttpRequest.newBuilder()\n        // Create a URI for a website which requires TLS\n        .uri(URI.create(\"https://www.example.com/\"))\n        // Build the request\n        .build();\n\n// Use the httpClient to send the request and use an HttpResponse.BodyHandlers String type\nHttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n// Debug print\nSystem.out.println(response);\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.DEFAULT_HTTP_CLIENT-1)\n","text":"The `org.apache.http.impl.client.DefaultHttpClient` does not verify the hostnames upon connection.\n\nThis allows for an adversary who is in between the application and the target host to intercept\npotentially sensitive information or transmit malicious data.\n\nDo not use the `org.apache.http.impl.client.DefaultHttpClient();` as it is deprecated. Instead\nuse the new `java.net.http.HttpClient` that was introduced in Java 9.\n\nExample connecting to a host that will automatically do TLS validation:\n```\n// Create a new java.net.http.HttpClient\nHttpClient httpClient = HttpClient.newHttpClient();\n// Create a HttpRequest builder\nHttpRequest request = HttpRequest.newBuilder()\n        // Create a URI for a website which requires TLS\n        .uri(URI.create(\"https://www.example.com/\"))\n        // Build the request\n        .build();\n\n// Use the httpClient to send the request and use an HttpResponse.BodyHandlers String type\nHttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n// Debug print\nSystem.out.println(response);\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.DEFAULT_HTTP_CLIENT-1","id":"gitlab.find_sec_bugs.DEFAULT_HTTP_CLIENT-1","name":"gitlab.find_sec_bugs.DEFAULT_HTTP_CLIENT-1","properties":{"precision":"very-high","tags":["CWE-295","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper certificate validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.\nNewer algorithms  apply message integrity to validate ciphertext has not been tampered\nwith. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the\nalternatives such as `AES-256-GCM`.\n\nFor older applications that don't have support for `ChaCha20Poly1305`,\n`AES-256-GCM` is recommended, however it has many drawbacks:\n- Slower than `ChaCha20Poly1305`.\n- Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.\nNewer algorithms  apply message integrity to validate ciphertext has not been tampered\nwith. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the\nalternatives such as `AES-256-GCM`.\n\nFor older applications that don't have support for `ChaCha20Poly1305`,\n`AES-256-GCM` is recommended, however it has many drawbacks:\n- Slower than `ChaCha20Poly1305`.\n- Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.DES_USAGE-1)\n","text":"DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.\nNewer algorithms  apply message integrity to validate ciphertext has not been tampered\nwith. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the\nalternatives such as `AES-256-GCM`.\n\nFor older applications that don't have support for `ChaCha20Poly1305`,\n`AES-256-GCM` is recommended, however it has many drawbacks:\n- Slower than `ChaCha20Poly1305`.\n- Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.DES_USAGE-1","id":"gitlab.find_sec_bugs.DES_USAGE-1","name":"gitlab.find_sec_bugs.DES_USAGE-1","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"help":{"markdown":"A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3)\n","text":"A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3","id":"gitlab.find_sec_bugs.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3","name":"gitlab.find_sec_bugs.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3","properties":{"precision":"very-high","tags":["CWE-259","OWASP-A07:2021-Identification and Authentication Failures","OWASP-A2:2017-Broken Authentication","security"],"security-severity":"Critical"},"shortDescription":{"text":"Use of hard-coded password"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"help":{"markdown":"The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2)\n","text":"The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2","id":"gitlab.find_sec_bugs.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2","name":"gitlab.find_sec_bugs.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2","properties":{"precision":"very-high","tags":["CWE-306","OWASP-A07:2021-Identification and Authentication Failures","OWASP-A2:2017-Broken Authentication","security"],"security-severity":"Critical"},"shortDescription":{"text":"Missing authentication for critical function (database)"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Cryptographic algorithms provide many different modes of operation, only some of which provide\nmessage integrity. Without message integrity it could be possible for an adversary to attempt\nto tamper with the ciphertext which could lead to compromising the encryption key. Newer\nalgorithms\napply message integrity to validate ciphertext has not been tampered with.\n\nInstead of using an algorithm that requires configuring a cipher mode, an algorithm\nthat has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"Cryptographic algorithms provide many different modes of operation, only some of which provide\nmessage integrity. Without message integrity it could be possible for an adversary to attempt\nto tamper with the ciphertext which could lead to compromising the encryption key. Newer\nalgorithms\napply message integrity to validate ciphertext has not been tampered with.\n\nInstead of using an algorithm that requires configuring a cipher mode, an algorithm\nthat has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.ECB_MODE-1)\n","text":"Cryptographic algorithms provide many different modes of operation, only some of which provide\nmessage integrity. Without message integrity it could be possible for an adversary to attempt\nto tamper with the ciphertext which could lead to compromising the encryption key. Newer\nalgorithms\napply message integrity to validate ciphertext has not been tampered with.\n\nInstead of using an algorithm that requires configuring a cipher mode, an algorithm\nthat has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.ECB_MODE-1","id":"gitlab.find_sec_bugs.ECB_MODE-1","name":"gitlab.find_sec_bugs.ECB_MODE-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"This rule identifies potential Expression Language (EL) injection vulnerabilities within Java applications. \nThe rule targets use of `createValueExpression`, `createMethodExpression`, `ELProcessor.eval`, `getValue`, \nand `setValue` methods, particularly when input to these methods is not a hardcoded string, indicating dynamic \nevaluation of potentially untrusted input. \n\n`createValueExpression` creates a `ValueExpression` object which gets evaluated upon calling methods like \n`getValue()` and `setValue()` or a Lambda `invoke()` i.e. it evaluates the expression passed to the \n`createValueExpression` method.\n\nSimilarly, `createMethodExpression` creates a `MethodExpression` object which gets evaluated upon calling \nmethods like `invoke()` and `getMethodInfo()`.\n`ELProcessor.eval`, `getValue()`, and `setValue()` methods all evaluate their expressions which are passed \nas parameters.\n\nCalling these method directly with user-supplied input may allow an adversary to execute arbitrary Java \ncode, including OS system commands. Never call these methods directly with user-supplied input. Consider \nalternate methods such as a lookup table to take user input and resolve hardcoded values.\n\nSecure example:\n\n```\nimport javax.el.ELProcessor;\nimport java.util.Set;\n\npublic class SafeELHandling {\n    private static final Set<String> ALLOWED_VALUES = Set.of(\"value1\", \"value2\", \"value3\");\n\n    public void processInput(String userInput) {\n        // Validate user input against the allowlist\n        if (!ALLOWED_VALUES.contains(userInput)) {\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n        \n        ELProcessor elProcessor = new ELProcessor();\n        elProcessor.defineBean(\"userInput\", userInput);\n        \n        // Example EL expression using the safe, predefined input\n        String result = (String) elProcessor.eval(userInput);\n    }\n}\n```\n"},"help":{"markdown":"This rule identifies potential Expression Language (EL) injection vulnerabilities within Java applications. \nThe rule targets use of `createValueExpression`, `createMethodExpression`, `ELProcessor.eval`, `getValue`, \nand `setValue` methods, particularly when input to these methods is not a hardcoded string, indicating dynamic \nevaluation of potentially untrusted input. \n\n`createValueExpression` creates a `ValueExpression` object which gets evaluated upon calling methods like \n`getValue()` and `setValue()` or a Lambda `invoke()` i.e. it evaluates the expression passed to the \n`createValueExpression` method.\n\nSimilarly, `createMethodExpression` creates a `MethodExpression` object which gets evaluated upon calling \nmethods like `invoke()` and `getMethodInfo()`.\n`ELProcessor.eval`, `getValue()`, and `setValue()` methods all evaluate their expressions which are passed \nas parameters.\n\nCalling these method directly with user-supplied input may allow an adversary to execute arbitrary Java \ncode, including OS system commands. Never call these methods directly with user-supplied input. Consider \nalternate methods such as a lookup table to take user input and resolve hardcoded values.\n\nSecure example:\n\n```\nimport javax.el.ELProcessor;\nimport java.util.Set;\n\npublic class SafeELHandling {\n    private static final Set<String> ALLOWED_VALUES = Set.of(\"value1\", \"value2\", \"value3\");\n\n    public void processInput(String userInput) {\n        // Validate user input against the allowlist\n        if (!ALLOWED_VALUES.contains(userInput)) {\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n        \n        ELProcessor elProcessor = new ELProcessor();\n        elProcessor.defineBean(\"userInput\", userInput);\n        \n        // Example EL expression using the safe, predefined input\n        String result = (String) elProcessor.eval(userInput);\n    }\n}\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.EL_INJECTION-1)\n","text":"This rule identifies potential Expression Language (EL) injection vulnerabilities within Java applications. \nThe rule targets use of `createValueExpression`, `createMethodExpression`, `ELProcessor.eval`, `getValue`, \nand `setValue` methods, particularly when input to these methods is not a hardcoded string, indicating dynamic \nevaluation of potentially untrusted input. \n\n`createValueExpression` creates a `ValueExpression` object which gets evaluated upon calling methods like \n`getValue()` and `setValue()` or a Lambda `invoke()` i.e. it evaluates the expression passed to the \n`createValueExpression` method.\n\nSimilarly, `createMethodExpression` creates a `MethodExpression` object which gets evaluated upon calling \nmethods like `invoke()` and `getMethodInfo()`.\n`ELProcessor.eval`, `getValue()`, and `setValue()` methods all evaluate their expressions which are passed \nas parameters.\n\nCalling these method directly with user-supplied input may allow an adversary to execute arbitrary Java \ncode, including OS system commands. Never call these methods directly with user-supplied input. Consider \nalternate methods such as a lookup table to take user input and resolve hardcoded values.\n\nSecure example:\n\n```\nimport javax.el.ELProcessor;\nimport java.util.Set;\n\npublic class SafeELHandling {\n    private static final Set<String> ALLOWED_VALUES = Set.of(\"value1\", \"value2\", \"value3\");\n\n    public void processInput(String userInput) {\n        // Validate user input against the allowlist\n        if (!ALLOWED_VALUES.contains(userInput)) {\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n        \n        ELProcessor elProcessor = new ELProcessor();\n        elProcessor.defineBean(\"userInput\", userInput);\n        \n        // Example EL expression using the safe, predefined input\n        String result = (String) elProcessor.eval(userInput);\n    }\n}\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.EL_INJECTION-1","id":"gitlab.find_sec_bugs.EL_INJECTION-1","name":"gitlab.find_sec_bugs.EL_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-917","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper neutralization of special elements used in an expression language statement ('Expression Language Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found using user-supplied input in a `java.sql.Connection`'s\n`setCatalog` call. This could allow an adversary to supply a different database for the\nlifetime of the connection. Allowing external control of system settings can disrupt service\nor cause an application to behave in unexpected, and potentially malicious ways. Most likely\nthis would only cause an error by providing a nonexistent catalog name.\n\nIt is recommended to not use user-supplied input when selecting the database for an\napplications\ndatabase connection.\n"},"help":{"markdown":"The application was found using user-supplied input in a `java.sql.Connection`'s\n`setCatalog` call. This could allow an adversary to supply a different database for the\nlifetime of the connection. Allowing external control of system settings can disrupt service\nor cause an application to behave in unexpected, and potentially malicious ways. Most likely\nthis would only cause an error by providing a nonexistent catalog name.\n\nIt is recommended to not use user-supplied input when selecting the database for an\napplications\ndatabase connection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.EXTERNAL_CONFIG_CONTROL-1)\n","text":"The application was found using user-supplied input in a `java.sql.Connection`'s\n`setCatalog` call. This could allow an adversary to supply a different database for the\nlifetime of the connection. Allowing external control of system settings can disrupt service\nor cause an application to behave in unexpected, and potentially malicious ways. Most likely\nthis would only cause an error by providing a nonexistent catalog name.\n\nIt is recommended to not use user-supplied input when selecting the database for an\napplications\ndatabase connection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.EXTERNAL_CONFIG_CONTROL-1","id":"gitlab.find_sec_bugs.EXTERNAL_CONFIG_CONTROL-1","name":"gitlab.find_sec_bugs.EXTERNAL_CONFIG_CONTROL-1","properties":{"precision":"very-high","tags":["CWE-15","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Low"},"shortDescription":{"text":"External control of system or configuration setting"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The filename provided by the FileUpload API can be tampered with\nwhich could lead to unauthorized access or file inclusion vulnerabilities.\nTo mitigate this risk, it is essential to conduct rigorous validation of the\nfilenames provided by clients. This validation should ensure that the filename\nadheres to a predefined structure, is devoid of potentially dangerous characters\n(such as forward slashes / and backslashes \\), and corresponds to an authorized\nfile only.\n\nFor example, as a remediation strategy, the application could:\n1. Sanitize Filenames: Create a function to sanitize filenames by removing\n   or replacing unauthorized characters, including path traversal sequences (../ or ..\\).\n2. Allowlist Validation: Implement a allowlist approach, allowing only filenames\n   that match a specific pattern or are part of a predefined list.\n3. Use Server-Generated Filenames: Rather than relying on client-provided filenames,\n   generate unique names server-side for storing files.\n4. Verify File Paths: Ensure files are being saved in the correct,\n   intended directory, and prevent redirection to unauthorized directories.\n\nExample remediation:\n```\n  public class FileUploadHandler {\n\n        protected void doPost(HttpServletRequest request, HttpServletResponse response)\n              throws ServletException, IOException {\n\n          Part filePart = request.getPart(\"file\");\n          String fileName = filePart.getSubmittedFileName();\n\n          // removes any path information from the filename\n          String sanitizedFileName = sanitizeFileName(fileName);\n          if (!isFileNameAllowed(sanitizedFileName)) {\n              throw new SecurityException(\"Invalid file name\");\n          }\n\n          // Generate a unique file name for storage\n          String storedFileName = UUID.randomUUID().toString() + \".txt\";\n\n          Path targetPath = Paths.get(\"uploads\").resolve(storedFileName);\n          Files.copy(fileContent, targetPath, StandardCopyOption.REPLACE_EXISTING);\n      }\n\n      private String sanitizeFileName(String fileName) {\n          return Paths.get(fileName).getFileName().toString();\n      }\n\n      private boolean isFileNameAllowed(String fileName) {\n          return fileName.matches(\"[a-zA-Z0-9._-]+\");\n      }\n  }\n```\n"},"help":{"markdown":"The filename provided by the FileUpload API can be tampered with\nwhich could lead to unauthorized access or file inclusion vulnerabilities.\nTo mitigate this risk, it is essential to conduct rigorous validation of the\nfilenames provided by clients. This validation should ensure that the filename\nadheres to a predefined structure, is devoid of potentially dangerous characters\n(such as forward slashes / and backslashes \\), and corresponds to an authorized\nfile only.\n\nFor example, as a remediation strategy, the application could:\n1. Sanitize Filenames: Create a function to sanitize filenames by removing\n   or replacing unauthorized characters, including path traversal sequences (../ or ..\\).\n2. Allowlist Validation: Implement a allowlist approach, allowing only filenames\n   that match a specific pattern or are part of a predefined list.\n3. Use Server-Generated Filenames: Rather than relying on client-provided filenames,\n   generate unique names server-side for storing files.\n4. Verify File Paths: Ensure files are being saved in the correct,\n   intended directory, and prevent redirection to unauthorized directories.\n\nExample remediation:\n```\n  public class FileUploadHandler {\n\n        protected void doPost(HttpServletRequest request, HttpServletResponse response)\n              throws ServletException, IOException {\n\n          Part filePart = request.getPart(\"file\");\n          String fileName = filePart.getSubmittedFileName();\n\n          // removes any path information from the filename\n          String sanitizedFileName = sanitizeFileName(fileName);\n          if (!isFileNameAllowed(sanitizedFileName)) {\n              throw new SecurityException(\"Invalid file name\");\n          }\n\n          // Generate a unique file name for storage\n          String storedFileName = UUID.randomUUID().toString() + \".txt\";\n\n          Path targetPath = Paths.get(\"uploads\").resolve(storedFileName);\n          Files.copy(fileContent, targetPath, StandardCopyOption.REPLACE_EXISTING);\n      }\n\n      private String sanitizeFileName(String fileName) {\n          return Paths.get(fileName).getFileName().toString();\n      }\n\n      private boolean isFileNameAllowed(String fileName) {\n          return fileName.matches(\"[a-zA-Z0-9._-]+\");\n      }\n  }\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.FILE_UPLOAD_FILENAME-1)\n","text":"The filename provided by the FileUpload API can be tampered with\nwhich could lead to unauthorized access or file inclusion vulnerabilities.\nTo mitigate this risk, it is essential to conduct rigorous validation of the\nfilenames provided by clients. This validation should ensure that the filename\nadheres to a predefined structure, is devoid of potentially dangerous characters\n(such as forward slashes / and backslashes \\), and corresponds to an authorized\nfile only.\n\nFor example, as a remediation strategy, the application could:\n1. Sanitize Filenames: Create a function to sanitize filenames by removing\n   or replacing unauthorized characters, including path traversal sequences (../ or ..\\).\n2. Allowlist Validation: Implement a allowlist approach, allowing only filenames\n   that match a specific pattern or are part of a predefined list.\n3. Use Server-Generated Filenames: Rather than relying on client-provided filenames,\n   generate unique names server-side for storing files.\n4. Verify File Paths: Ensure files are being saved in the correct,\n   intended directory, and prevent redirection to unauthorized directories.\n\nExample remediation:\n```\n  public class FileUploadHandler {\n\n        protected void doPost(HttpServletRequest request, HttpServletResponse response)\n              throws ServletException, IOException {\n\n          Part filePart = request.getPart(\"file\");\n          String fileName = filePart.getSubmittedFileName();\n\n          // removes any path information from the filename\n          String sanitizedFileName = sanitizeFileName(fileName);\n          if (!isFileNameAllowed(sanitizedFileName)) {\n              throw new SecurityException(\"Invalid file name\");\n          }\n\n          // Generate a unique file name for storage\n          String storedFileName = UUID.randomUUID().toString() + \".txt\";\n\n          Path targetPath = Paths.get(\"uploads\").resolve(storedFileName);\n          Files.copy(fileContent, targetPath, StandardCopyOption.REPLACE_EXISTING);\n      }\n\n      private String sanitizeFileName(String fileName) {\n          return Paths.get(fileName).getFileName().toString();\n      }\n\n      private boolean isFileNameAllowed(String fileName) {\n          return fileName.matches(\"[a-zA-Z0-9._-]+\");\n      }\n  }\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.FILE_UPLOAD_FILENAME-1","id":"gitlab.find_sec_bugs.FILE_UPLOAD_FILENAME-1","name":"gitlab.find_sec_bugs.FILE_UPLOAD_FILENAME-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application allows user input to control format string parameters. By passing invalid\nformat\nstring specifiers an adversary could cause the application to throw exceptions or possibly\nleak\ninternal information depending on application logic.\n\nNever allow user-supplied input to be used to create a format string. Replace all format\nstring\narguments with hardcoded format strings containing the necessary specifiers.\n\nExample of using `String.format` safely:\n```\n// Get untrusted user input\nString userInput = request.getParameter(\"someInput\");\n// Ensure that user input is not included in the first argument to String.format\nString.format(\"Hardcoded string expecting a string: %s\", userInput);\n// ...\n```\n"},"help":{"markdown":"The application allows user input to control format string parameters. By passing invalid\nformat\nstring specifiers an adversary could cause the application to throw exceptions or possibly\nleak\ninternal information depending on application logic.\n\nNever allow user-supplied input to be used to create a format string. Replace all format\nstring\narguments with hardcoded format strings containing the necessary specifiers.\n\nExample of using `String.format` safely:\n```\n// Get untrusted user input\nString userInput = request.getParameter(\"someInput\");\n// Ensure that user input is not included in the first argument to String.format\nString.format(\"Hardcoded string expecting a string: %s\", userInput);\n// ...\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.FORMAT_STRING_MANIPULATION-1)\n","text":"The application allows user input to control format string parameters. By passing invalid\nformat\nstring specifiers an adversary could cause the application to throw exceptions or possibly\nleak\ninternal information depending on application logic.\n\nNever allow user-supplied input to be used to create a format string. Replace all format\nstring\narguments with hardcoded format strings containing the necessary specifiers.\n\nExample of using `String.format` safely:\n```\n// Get untrusted user input\nString userInput = request.getParameter(\"someInput\");\n// Ensure that user input is not included in the first argument to String.format\nString.format(\"Hardcoded string expecting a string: %s\", userInput);\n// ...\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.FORMAT_STRING_MANIPULATION-1","id":"gitlab.find_sec_bugs.FORMAT_STRING_MANIPULATION-1","name":"gitlab.find_sec_bugs.FORMAT_STRING_MANIPULATION-1","properties":{"precision":"very-high","tags":["CWE-134","HIGH CONFIDENCE","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of externally-controlled format string"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n"},"help":{"markdown":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_KEY-1)\n","text":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_KEY-1","id":"gitlab.find_sec_bugs.HARD_CODE_KEY-1","name":"gitlab.find_sec_bugs.HARD_CODE_KEY-1","properties":{"precision":"very-high","tags":["CWE-321: Use of Hard-coded Cryptographic Key","security"]},"shortDescription":{"text":"Semgrep Finding: gitlab.find_sec_bugs.HARD_CODE_KEY-1"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n"},"help":{"markdown":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_KEY-2)\n","text":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_KEY-2","id":"gitlab.find_sec_bugs.HARD_CODE_KEY-2","name":"gitlab.find_sec_bugs.HARD_CODE_KEY-2","properties":{"precision":"very-high","tags":["CWE-321: Use of Hard-coded Cryptographic Key","security"]},"shortDescription":{"text":"Semgrep Finding: gitlab.find_sec_bugs.HARD_CODE_KEY-2"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n"},"help":{"markdown":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_KEY-3)\n","text":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_KEY-3","id":"gitlab.find_sec_bugs.HARD_CODE_KEY-3","name":"gitlab.find_sec_bugs.HARD_CODE_KEY-3","properties":{"precision":"very-high","tags":["CWE-321: Use of Hard-coded Cryptographic Key","security"]},"shortDescription":{"text":"Semgrep Finding: gitlab.find_sec_bugs.HARD_CODE_KEY-3"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n"},"help":{"markdown":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_KEY-4)\n","text":"Cryptographic keys should not be kept in the source code. The source code can be widely shared\nin an enterprise environment, and is certainly shared in open source. To be managed safely,\npasswords and secret keys should be stored in separate configuration files or keystores.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_KEY-4","id":"gitlab.find_sec_bugs.HARD_CODE_KEY-4","name":"gitlab.find_sec_bugs.HARD_CODE_KEY-4","properties":{"precision":"very-high","tags":["CWE-321: Use of Hard-coded Cryptographic Key","security"]},"shortDescription":{"text":"Semgrep Finding: gitlab.find_sec_bugs.HARD_CODE_KEY-4"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A potential hard-coded password was identified in a hard-coded string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"help":{"markdown":"A potential hard-coded password was identified in a hard-coded string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_PASSWORD-1)\n","text":"A potential hard-coded password was identified in a hard-coded string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_PASSWORD-1","id":"gitlab.find_sec_bugs.HARD_CODE_PASSWORD-1","name":"gitlab.find_sec_bugs.HARD_CODE_PASSWORD-1","properties":{"precision":"very-high","tags":["CWE-259","OWASP-A07:2021-Identification and Authentication Failures","OWASP-A2:2017-Broken Authentication","security"],"security-severity":"High"},"shortDescription":{"text":"Use of hard-coded password"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The network communications for Hazelcast is configured to use a deprecated symmetric cipher.\nConsider using TLS/SSL when establishing communications across the Hazelcast cluster.\n\nFor more information on configuring TLS/SSL for Hazelcast see:\nhttps://docs.hazelcast.com/imdg/4.2/security/tls-ssl\n"},"help":{"markdown":"The network communications for Hazelcast is configured to use a deprecated symmetric cipher.\nConsider using TLS/SSL when establishing communications across the Hazelcast cluster.\n\nFor more information on configuring TLS/SSL for Hazelcast see:\nhttps://docs.hazelcast.com/imdg/4.2/security/tls-ssl\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HAZELCAST_SYMMETRIC_ENCRYPTION-1)\n","text":"The network communications for Hazelcast is configured to use a deprecated symmetric cipher.\nConsider using TLS/SSL when establishing communications across the Hazelcast cluster.\n\nFor more information on configuring TLS/SSL for Hazelcast see:\nhttps://docs.hazelcast.com/imdg/4.2/security/tls-ssl\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HAZELCAST_SYMMETRIC_ENCRYPTION-1","id":"gitlab.find_sec_bugs.HAZELCAST_SYMMETRIC_ENCRYPTION-1","name":"gitlab.find_sec_bugs.HAZELCAST_SYMMETRIC_ENCRYPTION-1","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added\nto an HTTP response, it will allow a HTTP response splitting vulnerability. See\nhttp://en.wikipedia.org/wiki/HTTP_response_splitting for more information.\n"},"help":{"markdown":"This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added\nto an HTTP response, it will allow a HTTP response splitting vulnerability. See\nhttp://en.wikipedia.org/wiki/HTTP_response_splitting for more information.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HRS_REQUEST_PARAMETER_TO_COOKIE-1)\n","text":"This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added\nto an HTTP response, it will allow a HTTP response splitting vulnerability. See\nhttp://en.wikipedia.org/wiki/HTTP_response_splitting for more information.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HRS_REQUEST_PARAMETER_TO_COOKIE-1","id":"gitlab.find_sec_bugs.HRS_REQUEST_PARAMETER_TO_COOKIE-1","name":"gitlab.find_sec_bugs.HRS_REQUEST_PARAMETER_TO_COOKIE-1","properties":{"precision":"very-high","tags":["CWE-113","security"]},"shortDescription":{"text":"Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"HTTP Response Splitting is a vulnerability where Carriage Return (CR `\\r`) and Line Feed (LF\n`\\n`)\ncharacters are introduced into an HTTP header from user-supplied input. By injecting the\n`\\r\\n`\ncharacter sequence, an adversary could potentially modify how the response is interpreted by\nthe\nclient or any down stream caching services. This could allow an adversary to poison the cache\ndata or execute Cross-Site Scripting (XSS) attacks.\n\nSome Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) will\nautomatically encode\ncharacters from being set in response headers as a space `0x20` character. If your application\nserver does\nnot automatically provide this functionality, user-supplied input that is used in header keys\nor values must be\nvalidated.\n\nExample of validating headers to only allow valid characters:\n```\n// throws an IllegalArgumentException if the provided value contains invalid characters\npublic void validateHeader(String value) throws IllegalArgumentException {\n    char[] chars = value.toCharArray();\n\n    // iterate over every character\n    for (int i = 0; i < chars.length; i++) {\n        char c = chars[i];\n\n        // check for any characters below 0x21 as well as: '\"' ',' ';' '\\' and 0x7f.\n        if (c < 0x21 || c == '\"' || c == ',' || c == ';' || c == '\\\\' || c == 0x7f) {\n            throw new IllegalArgumentException(\"Invalid character in cookie detected:\n{0}\".format(Integer.toString(c)));\n        }\n    }\n}\n```\n\nAlternatively, you could use a string escape package such as\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:\n```\npublic String escapeValue(String value) {\n  return StringEscapeUtils.escapeJava(value);\n}\n```\n\nFor more information on response splitting attacks see OWASP:\nhttps://owasp.org/www-community/attacks/HTTP_Response_Splitting\n"},"help":{"markdown":"HTTP Response Splitting is a vulnerability where Carriage Return (CR `\\r`) and Line Feed (LF\n`\\n`)\ncharacters are introduced into an HTTP header from user-supplied input. By injecting the\n`\\r\\n`\ncharacter sequence, an adversary could potentially modify how the response is interpreted by\nthe\nclient or any down stream caching services. This could allow an adversary to poison the cache\ndata or execute Cross-Site Scripting (XSS) attacks.\n\nSome Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) will\nautomatically encode\ncharacters from being set in response headers as a space `0x20` character. If your application\nserver does\nnot automatically provide this functionality, user-supplied input that is used in header keys\nor values must be\nvalidated.\n\nExample of validating headers to only allow valid characters:\n```\n// throws an IllegalArgumentException if the provided value contains invalid characters\npublic void validateHeader(String value) throws IllegalArgumentException {\n    char[] chars = value.toCharArray();\n\n    // iterate over every character\n    for (int i = 0; i < chars.length; i++) {\n        char c = chars[i];\n\n        // check for any characters below 0x21 as well as: '\"' ',' ';' '\\' and 0x7f.\n        if (c < 0x21 || c == '\"' || c == ',' || c == ';' || c == '\\\\' || c == 0x7f) {\n            throw new IllegalArgumentException(\"Invalid character in cookie detected:\n{0}\".format(Integer.toString(c)));\n        }\n    }\n}\n```\n\nAlternatively, you could use a string escape package such as\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:\n```\npublic String escapeValue(String value) {\n  return StringEscapeUtils.escapeJava(value);\n}\n```\n\nFor more information on response splitting attacks see OWASP:\nhttps://owasp.org/www-community/attacks/HTTP_Response_Splitting\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1)\n","text":"HTTP Response Splitting is a vulnerability where Carriage Return (CR `\\r`) and Line Feed (LF\n`\\n`)\ncharacters are introduced into an HTTP header from user-supplied input. By injecting the\n`\\r\\n`\ncharacter sequence, an adversary could potentially modify how the response is interpreted by\nthe\nclient or any down stream caching services. This could allow an adversary to poison the cache\ndata or execute Cross-Site Scripting (XSS) attacks.\n\nSome Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) will\nautomatically encode\ncharacters from being set in response headers as a space `0x20` character. If your application\nserver does\nnot automatically provide this functionality, user-supplied input that is used in header keys\nor values must be\nvalidated.\n\nExample of validating headers to only allow valid characters:\n```\n// throws an IllegalArgumentException if the provided value contains invalid characters\npublic void validateHeader(String value) throws IllegalArgumentException {\n    char[] chars = value.toCharArray();\n\n    // iterate over every character\n    for (int i = 0; i < chars.length; i++) {\n        char c = chars[i];\n\n        // check for any characters below 0x21 as well as: '\"' ',' ';' '\\' and 0x7f.\n        if (c < 0x21 || c == '\"' || c == ',' || c == ';' || c == '\\\\' || c == 0x7f) {\n            throw new IllegalArgumentException(\"Invalid character in cookie detected:\n{0}\".format(Integer.toString(c)));\n        }\n    }\n}\n```\n\nAlternatively, you could use a string escape package such as\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:\n```\npublic String escapeValue(String value) {\n  return StringEscapeUtils.escapeJava(value);\n}\n```\n\nFor more information on response splitting attacks see OWASP:\nhttps://owasp.org/www-community/attacks/HTTP_Response_Splitting\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1","id":"gitlab.find_sec_bugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1","name":"gitlab.find_sec_bugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1","properties":{"precision":"very-high","tags":["CWE-113","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"High"},"shortDescription":{"text":"Improper neutralization of CRLF sequences in HTTP headers ('HTTP Response Splitting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by\nclient side JavaScript such\nas reading the `document.cookie` values. By enabling this protection, a website that is\nvulnerable to\nCross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie\nvalue from JavaScript.\n\nExample of protecting a `Cookie`:\n```\n// Create an HttpOnly cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set HttpOnly flag to true\nsomeCookie.setHttpOnly(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n"},"help":{"markdown":"The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by\nclient side JavaScript such\nas reading the `document.cookie` values. By enabling this protection, a website that is\nvulnerable to\nCross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie\nvalue from JavaScript.\n\nExample of protecting a `Cookie`:\n```\n// Create an HttpOnly cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set HttpOnly flag to true\nsomeCookie.setHttpOnly(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HTTPONLY_COOKIE-1)\n","text":"The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by\nclient side JavaScript such\nas reading the `document.cookie` values. By enabling this protection, a website that is\nvulnerable to\nCross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie\nvalue from JavaScript.\n\nExample of protecting a `Cookie`:\n```\n// Create an HttpOnly cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set HttpOnly flag to true\nsomeCookie.setHttpOnly(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HTTPONLY_COOKIE-1","id":"gitlab.find_sec_bugs.HTTPONLY_COOKIE-1","name":"gitlab.find_sec_bugs.HTTPONLY_COOKIE-1","properties":{"precision":"very-high","tags":["CWE-1004","security"]},"shortDescription":{"text":"Sensitive cookie without 'HttpOnly' flag"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application was found including unvalidated user input into a URL, which could lead to\nHTTP Parameter Pollution (HPP) or worse, Server Side Request Forgery (SSRF). This could\nallow an adversary to override the value of a URL or a request parameter.  HTTP Parameter\nPollution\n(HPP) attacks consist of injecting encoded query string delimiters into other existing\nparameters. If a web\napplication does not properly sanitize the user input, an adversary may modify the logic of\nthese\nrequests to other applications.\n\nTo remediate this issue, never allow user input directly into creation of a URL or URL\nparameter. Consider\nusing a map to look up user-supplied information and return exact values to be used in the\ngeneration of\nrequests.\n\nExample using a map to look up a key to be used in a HTTP request:\n```\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"value1\");\nlookupTable.put(\"key2\", \"value2\");\nString userInput = request.getParameter(\"key\");\n\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n    // Lookup the value from our user input from our lookupTable\n    String value = lookupTable.getOrDefault(userInput, \"value1\");\n    // Construct the url, with the hardcoded url and only pass in the value from the\nlookupTable,\n    // not direct user input\n    final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+value);\n    // Execute the request\n    CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n    // Read the response\n    byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n    // Handle the response\n    // ...\n}\n```\n\nIf using a map is not possible, the user-supplied input must be encoded prior to use, and\nnever allow full\nURLs:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the string using java.net.URLEncoder with the UTF-8 character set\nString encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n  // Construct the url, with the hardcoded url and only pass in the encoded value, never a\nfull URL\n  final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+encodedString);\n  // Execute the request\n  CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n  // Read the response\n  byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n  // handle the response\n}\n```\n\nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n\nFor more information on HTTP Parameter Pollution see:\nhttps://en.wikipedia.org/wiki/HTTP_parameter_pollution\n"},"help":{"markdown":"The application was found including unvalidated user input into a URL, which could lead to\nHTTP Parameter Pollution (HPP) or worse, Server Side Request Forgery (SSRF). This could\nallow an adversary to override the value of a URL or a request parameter.  HTTP Parameter\nPollution\n(HPP) attacks consist of injecting encoded query string delimiters into other existing\nparameters. If a web\napplication does not properly sanitize the user input, an adversary may modify the logic of\nthese\nrequests to other applications.\n\nTo remediate this issue, never allow user input directly into creation of a URL or URL\nparameter. Consider\nusing a map to look up user-supplied information and return exact values to be used in the\ngeneration of\nrequests.\n\nExample using a map to look up a key to be used in a HTTP request:\n```\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"value1\");\nlookupTable.put(\"key2\", \"value2\");\nString userInput = request.getParameter(\"key\");\n\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n    // Lookup the value from our user input from our lookupTable\n    String value = lookupTable.getOrDefault(userInput, \"value1\");\n    // Construct the url, with the hardcoded url and only pass in the value from the\nlookupTable,\n    // not direct user input\n    final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+value);\n    // Execute the request\n    CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n    // Read the response\n    byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n    // Handle the response\n    // ...\n}\n```\n\nIf using a map is not possible, the user-supplied input must be encoded prior to use, and\nnever allow full\nURLs:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the string using java.net.URLEncoder with the UTF-8 character set\nString encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n  // Construct the url, with the hardcoded url and only pass in the encoded value, never a\nfull URL\n  final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+encodedString);\n  // Execute the request\n  CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n  // Read the response\n  byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n  // handle the response\n}\n```\n\nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n\nFor more information on HTTP Parameter Pollution see:\nhttps://en.wikipedia.org/wiki/HTTP_parameter_pollution\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HTTP_PARAMETER_POLLUTION-1)\n","text":"The application was found including unvalidated user input into a URL, which could lead to\nHTTP Parameter Pollution (HPP) or worse, Server Side Request Forgery (SSRF). This could\nallow an adversary to override the value of a URL or a request parameter.  HTTP Parameter\nPollution\n(HPP) attacks consist of injecting encoded query string delimiters into other existing\nparameters. If a web\napplication does not properly sanitize the user input, an adversary may modify the logic of\nthese\nrequests to other applications.\n\nTo remediate this issue, never allow user input directly into creation of a URL or URL\nparameter. Consider\nusing a map to look up user-supplied information and return exact values to be used in the\ngeneration of\nrequests.\n\nExample using a map to look up a key to be used in a HTTP request:\n```\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"value1\");\nlookupTable.put(\"key2\", \"value2\");\nString userInput = request.getParameter(\"key\");\n\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n    // Lookup the value from our user input from our lookupTable\n    String value = lookupTable.getOrDefault(userInput, \"value1\");\n    // Construct the url, with the hardcoded url and only pass in the value from the\nlookupTable,\n    // not direct user input\n    final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+value);\n    // Execute the request\n    CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n    // Read the response\n    byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n    // Handle the response\n    // ...\n}\n```\n\nIf using a map is not possible, the user-supplied input must be encoded prior to use, and\nnever allow full\nURLs:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the string using java.net.URLEncoder with the UTF-8 character set\nString encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n  // Construct the url, with the hardcoded url and only pass in the encoded value, never a\nfull URL\n  final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+encodedString);\n  // Execute the request\n  CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n  // Read the response\n  byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n  // handle the response\n}\n```\n\nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n\nFor more information on HTTP Parameter Pollution see:\nhttps://en.wikipedia.org/wiki/HTTP_parameter_pollution\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HTTP_PARAMETER_POLLUTION-1","id":"gitlab.find_sec_bugs.HTTP_PARAMETER_POLLUTION-1","name":"gitlab.find_sec_bugs.HTTP_PARAMETER_POLLUTION-1","properties":{"precision":"very-high","tags":["CWE-88","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper neutralization of argument delimiters in a command ('Argument Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"HTTP Response Splitting is a vulnerability where Carriage Return (CR `\\r`) and Line Feed (LF\n`\\n`)\ncharacters are introduced into an HTTP header from user-supplied input. By injecting the\n`\\r\\n`\ncharacter sequence, an adversary could potentially modify how the response is interpreted by\nthe\nclient or any downstream caching services. This could allow an adversary to poison the cache\ndata or execute Cross-Site Scripting (XSS) attacks.\n\nSome Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) as of version\n8.0, newer versions of Jetty and other servers that implement the [RFC 6265 Standard](https://datatracker.ietf.org/doc/html/rfc6265) will\ndisallow `\\r' and '\\n` characters characters from being set in cookies. If your application server does not\nautomatically provide this functionality, user-supplied input that is used in cookie keys or\nvalues must be validated.\n\nExample of validating cookies to only allow valid characters:\n```\n// throws an IllegalArgumentException if the provided value contains invalid characters\npublic void validateRfc6265CookieValue(String value) throws IllegalArgumentException {\n    char[] chars = value.toCharArray();\n\n    // iterate over every character\n    for (int i = 0; i < chars.length; i++) {\n        char c = chars[i];\n\n        // check for any characters below 0x21 as well as: '\"' ',' ';' '\\' and 0x7f.\n        if (c < 0x21 || c == '\"' || c == ',' || c == ';' || c == '\\\\' || c == 0x7f) {\n            throw new IllegalArgumentException(\"Invalid character in cookie detected:\n{0}\".format(Integer.toString(c)));\n        }\n    }\n}\n```\n\nAlternatively, you could use a string escape package such as\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:\n```\npublic String escapeValue(String value) {\n  return StringEscapeUtils.escapeJava(value);\n}\n```\n\nFor more information on response splitting attacks see OWASP:\nhttps://owasp.org/www-community/attacks/HTTP_Response_Splitting\n"},"help":{"markdown":"HTTP Response Splitting is a vulnerability where Carriage Return (CR `\\r`) and Line Feed (LF\n`\\n`)\ncharacters are introduced into an HTTP header from user-supplied input. By injecting the\n`\\r\\n`\ncharacter sequence, an adversary could potentially modify how the response is interpreted by\nthe\nclient or any downstream caching services. This could allow an adversary to poison the cache\ndata or execute Cross-Site Scripting (XSS) attacks.\n\nSome Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) as of version\n8.0, newer versions of Jetty and other servers that implement the [RFC 6265 Standard](https://datatracker.ietf.org/doc/html/rfc6265) will\ndisallow `\\r' and '\\n` characters characters from being set in cookies. If your application server does not\nautomatically provide this functionality, user-supplied input that is used in cookie keys or\nvalues must be validated.\n\nExample of validating cookies to only allow valid characters:\n```\n// throws an IllegalArgumentException if the provided value contains invalid characters\npublic void validateRfc6265CookieValue(String value) throws IllegalArgumentException {\n    char[] chars = value.toCharArray();\n\n    // iterate over every character\n    for (int i = 0; i < chars.length; i++) {\n        char c = chars[i];\n\n        // check for any characters below 0x21 as well as: '\"' ',' ';' '\\' and 0x7f.\n        if (c < 0x21 || c == '\"' || c == ',' || c == ';' || c == '\\\\' || c == 0x7f) {\n            throw new IllegalArgumentException(\"Invalid character in cookie detected:\n{0}\".format(Integer.toString(c)));\n        }\n    }\n}\n```\n\nAlternatively, you could use a string escape package such as\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:\n```\npublic String escapeValue(String value) {\n  return StringEscapeUtils.escapeJava(value);\n}\n```\n\nFor more information on response splitting attacks see OWASP:\nhttps://owasp.org/www-community/attacks/HTTP_Response_Splitting\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.HTTP_RESPONSE_SPLITTING-1)\n","text":"HTTP Response Splitting is a vulnerability where Carriage Return (CR `\\r`) and Line Feed (LF\n`\\n`)\ncharacters are introduced into an HTTP header from user-supplied input. By injecting the\n`\\r\\n`\ncharacter sequence, an adversary could potentially modify how the response is interpreted by\nthe\nclient or any downstream caching services. This could allow an adversary to poison the cache\ndata or execute Cross-Site Scripting (XSS) attacks.\n\nSome Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) as of version\n8.0, newer versions of Jetty and other servers that implement the [RFC 6265 Standard](https://datatracker.ietf.org/doc/html/rfc6265) will\ndisallow `\\r' and '\\n` characters characters from being set in cookies. If your application server does not\nautomatically provide this functionality, user-supplied input that is used in cookie keys or\nvalues must be validated.\n\nExample of validating cookies to only allow valid characters:\n```\n// throws an IllegalArgumentException if the provided value contains invalid characters\npublic void validateRfc6265CookieValue(String value) throws IllegalArgumentException {\n    char[] chars = value.toCharArray();\n\n    // iterate over every character\n    for (int i = 0; i < chars.length; i++) {\n        char c = chars[i];\n\n        // check for any characters below 0x21 as well as: '\"' ',' ';' '\\' and 0x7f.\n        if (c < 0x21 || c == '\"' || c == ',' || c == ';' || c == '\\\\' || c == 0x7f) {\n            throw new IllegalArgumentException(\"Invalid character in cookie detected:\n{0}\".format(Integer.toString(c)));\n        }\n    }\n}\n```\n\nAlternatively, you could use a string escape package such as\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:\n```\npublic String escapeValue(String value) {\n  return StringEscapeUtils.escapeJava(value);\n}\n```\n\nFor more information on response splitting attacks see OWASP:\nhttps://owasp.org/www-community/attacks/HTTP_Response_Splitting\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.HTTP_RESPONSE_SPLITTING-1","id":"gitlab.find_sec_bugs.HTTP_RESPONSE_SPLITTING-1","name":"gitlab.find_sec_bugs.HTTP_RESPONSE_SPLITTING-1","properties":{"precision":"very-high","tags":["CWE-113","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"High"},"shortDescription":{"text":"Improper neutralization of CRLF sequences in HTTP headers ('HTTP Response Splitting')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Improper Handling of Unicode Encoding\n"},"help":{"markdown":"Improper Handling of Unicode Encoding\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.IMPROPER_UNICODE-1)\n","text":"Improper Handling of Unicode Encoding\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.IMPROPER_UNICODE-1","id":"gitlab.find_sec_bugs.IMPROPER_UNICODE-1","name":"gitlab.find_sec_bugs.IMPROPER_UNICODE-1","properties":{"precision":"very-high","tags":["CWE-176","HIGH CONFIDENCE","security"]},"shortDescription":{"text":"Improper Handling of Unicode Encoding"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found printing stack information to the default system output.\nAs stack trace data may contain sensitive information, it is recommended that the\noutput be logged using a secure logging framework. Log files should also be protected\nwith proper operating system permission levels.\n"},"help":{"markdown":"The application was found printing stack information to the default system output.\nAs stack trace data may contain sensitive information, it is recommended that the\noutput be logged using a secure logging framework. Log files should also be protected\nwith proper operating system permission levels.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1)\n","text":"The application was found printing stack information to the default system output.\nAs stack trace data may contain sensitive information, it is recommended that the\noutput be logged using a secure logging framework. Log files should also be protected\nwith proper operating system permission levels.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1","id":"gitlab.find_sec_bugs.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1","name":"gitlab.find_sec_bugs.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1","properties":{"precision":"very-high","tags":["CWE-209","security"]},"shortDescription":{"text":"Information exposure through an error message"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The `Secure` attribute when set to `true` protects the cookie value from being being\ntransmitted over clear text\ncommunication paths such as HTTP. By enabling this protection, the cookie will only be sent\nover HTTPS.\n\nExample of protecting a `Cookie`:\n```\n// Create an Secure cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set Secure flag to true\nsomeCookie.setSecure(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setSecure-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n"},"help":{"markdown":"The `Secure` attribute when set to `true` protects the cookie value from being being\ntransmitted over clear text\ncommunication paths such as HTTP. By enabling this protection, the cookie will only be sent\nover HTTPS.\n\nExample of protecting a `Cookie`:\n```\n// Create an Secure cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set Secure flag to true\nsomeCookie.setSecure(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setSecure-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.INSECURE_COOKIE-1)\n","text":"The `Secure` attribute when set to `true` protects the cookie value from being being\ntransmitted over clear text\ncommunication paths such as HTTP. By enabling this protection, the cookie will only be sent\nover HTTPS.\n\nExample of protecting a `Cookie`:\n```\n// Create an Secure cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set Secure flag to true\nsomeCookie.setSecure(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setSecure-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.INSECURE_COOKIE-1","id":"gitlab.find_sec_bugs.INSECURE_COOKIE-1","name":"gitlab.find_sec_bugs.INSECURE_COOKIE-1","properties":{"precision":"very-high","tags":["CWE-614","OWASP-A05:2021-Security Misconfiguration","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"Low"},"shortDescription":{"text":"Sensitive cookie in HTTPS session without 'Secure' attribute"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The Apache commons mail client by default does not enable TLS server identity.\nThis allows for an adversary who is in between the application and the target host to intercept\npotentially sensitive information or transmit malicious data.\n\nEnable checking server identity by calling `Email.setSSLCheckServerIdentity(true)`\n\nExample email client that enables TLS and server identity:\n```\n// Create an email client\nEmail email = new SimpleEmail();\n// Configure the email hostname\nemail.setHostName(\"smtp.mail.example.com\");\n// Set the port\nemail.setSmtpPort(465);\n// Securely retrieve username and password values\nString username = getUserNameFromKMSorSecretStore();\nString password = getPasswordFromKMSorSecretStore();\n// Configure the Authenticator\nDefaultAuthenticator auth = new DefaultAuthenticator(username, password);\n// Set the authenticator\nemail.setAuthenticator(auth);\n// Ensure we use SSL on connect\nemail.setSSLOnConnect(true);\n// Ensure we validate server identity\nemail.setSSLCheckServerIdentity(true);\n// configure the rest of the email\nemail.setFrom(\"x@example.com\");\nemail.setSubject(\"TestMail\");\nemail.setMsg(\"This is a test mail ... :-)\");\nemail.addTo(\"y@example.com\");\nemail.send();\n```\n"},"help":{"markdown":"The Apache commons mail client by default does not enable TLS server identity.\nThis allows for an adversary who is in between the application and the target host to intercept\npotentially sensitive information or transmit malicious data.\n\nEnable checking server identity by calling `Email.setSSLCheckServerIdentity(true)`\n\nExample email client that enables TLS and server identity:\n```\n// Create an email client\nEmail email = new SimpleEmail();\n// Configure the email hostname\nemail.setHostName(\"smtp.mail.example.com\");\n// Set the port\nemail.setSmtpPort(465);\n// Securely retrieve username and password values\nString username = getUserNameFromKMSorSecretStore();\nString password = getPasswordFromKMSorSecretStore();\n// Configure the Authenticator\nDefaultAuthenticator auth = new DefaultAuthenticator(username, password);\n// Set the authenticator\nemail.setAuthenticator(auth);\n// Ensure we use SSL on connect\nemail.setSSLOnConnect(true);\n// Ensure we validate server identity\nemail.setSSLCheckServerIdentity(true);\n// configure the rest of the email\nemail.setFrom(\"x@example.com\");\nemail.setSubject(\"TestMail\");\nemail.setMsg(\"This is a test mail ... :-)\");\nemail.addTo(\"y@example.com\");\nemail.send();\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.INSECURE_SMTP_SSL-1)\n","text":"The Apache commons mail client by default does not enable TLS server identity.\nThis allows for an adversary who is in between the application and the target host to intercept\npotentially sensitive information or transmit malicious data.\n\nEnable checking server identity by calling `Email.setSSLCheckServerIdentity(true)`\n\nExample email client that enables TLS and server identity:\n```\n// Create an email client\nEmail email = new SimpleEmail();\n// Configure the email hostname\nemail.setHostName(\"smtp.mail.example.com\");\n// Set the port\nemail.setSmtpPort(465);\n// Securely retrieve username and password values\nString username = getUserNameFromKMSorSecretStore();\nString password = getPasswordFromKMSorSecretStore();\n// Configure the Authenticator\nDefaultAuthenticator auth = new DefaultAuthenticator(username, password);\n// Set the authenticator\nemail.setAuthenticator(auth);\n// Ensure we use SSL on connect\nemail.setSSLOnConnect(true);\n// Ensure we validate server identity\nemail.setSSLCheckServerIdentity(true);\n// configure the rest of the email\nemail.setFrom(\"x@example.com\");\nemail.setSubject(\"TestMail\");\nemail.setMsg(\"This is a test mail ... :-)\");\nemail.addTo(\"y@example.com\");\nemail.send();\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.INSECURE_SMTP_SSL-1","id":"gitlab.find_sec_bugs.INSECURE_SMTP_SSL-1","name":"gitlab.find_sec_bugs.INSECURE_SMTP_SSL-1","properties":{"precision":"very-high","tags":["CWE-297","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper validation of certificate with host mismatch"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"This method is part of a REST Web Service (JSR311). The security of this web service should be\nanalyzed; Authentication, if enforced, should be tested. Access control, if enforced, should be\ntested. The inputs should be tracked for potential vulnerabilities. The communication should\nideally be over SSL.\n"},"help":{"markdown":"This method is part of a REST Web Service (JSR311). The security of this web service should be\nanalyzed; Authentication, if enforced, should be tested. Access control, if enforced, should be\ntested. The inputs should be tracked for potential vulnerabilities. The communication should\nideally be over SSL.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.JAXRS_ENDPOINT-1)\n","text":"This method is part of a REST Web Service (JSR311). The security of this web service should be\nanalyzed; Authentication, if enforced, should be tested. Access control, if enforced, should be\ntested. The inputs should be tracked for potential vulnerabilities. The communication should\nideally be over SSL.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.JAXRS_ENDPOINT-1","id":"gitlab.find_sec_bugs.JAXRS_ENDPOINT-1","name":"gitlab.find_sec_bugs.JAXRS_ENDPOINT-1","properties":{"precision":"very-high","tags":["CWE-20","security"]},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"note"},"fullDescription":{"text":"This method is part of a SOAP Web Service (JSR224). The security of this web service should be\nanalyzed; Authentication, if enforced, should be tested. Access control, if enforced, should be\ntested. The inputs should be tracked for potential vulnerabilities. The communication should\nideally be over SSL.\n"},"help":{"markdown":"This method is part of a SOAP Web Service (JSR224). The security of this web service should be\nanalyzed; Authentication, if enforced, should be tested. Access control, if enforced, should be\ntested. The inputs should be tracked for potential vulnerabilities. The communication should\nideally be over SSL.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.JAXWS_ENDPOINT-1)\n","text":"This method is part of a SOAP Web Service (JSR224). The security of this web service should be\nanalyzed; Authentication, if enforced, should be tested. Access control, if enforced, should be\ntested. The inputs should be tracked for potential vulnerabilities. The communication should\nideally be over SSL.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.JAXWS_ENDPOINT-1","id":"gitlab.find_sec_bugs.JAXWS_ENDPOINT-1","name":"gitlab.find_sec_bugs.JAXWS_ENDPOINT-1","properties":{"precision":"very-high","tags":["CWE-20","OWASP-A7:2017-Cross-Site Scripting (XSS)","security"]},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application does not provide authentication when communicating an LDAP\nserver. It is strongly recommended that the LDAP server be configured with\nauthentication and restrict what queries users can execute.\n\nExample code that authenticates with a remote LDAP server and encodes any\nuser-supplied input:\n```\n// Create a properties to hold the ldap connection details\nProperties props = new Properties();\n// Use the com.sun.jndi.ldap.LdapCtxFactory factory provider\nprops.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n// The LDAP server URL\nprops.put(Context.PROVIDER_URL, \"ldap://ldap.example.org:3889\");\n// User details for the connection\nprops.put(Context.SECURITY_PRINCIPAL, \"cn=admin,dc=example,dc=org\");\n// LDAP account password\nString ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();\n// Pass in the LDAP password\nprops.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);\n\n// Create the LDAPContext\nInitialDirContext ldapContext = new InitialDirContext(props);\n// Example using SUBTREE_SCOPE SearchControls\nSearchControls searchControls = new SearchControls();\nsearchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n// Get user input for query\nString userQuery = someUserInput;\n// Use searchArguments to hold the user-supplied input\nObject[] searchArguments = new Object[]{userQuery};\n// Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,\nand pass in the search controls.\n// searchArguments automatically encode\nNamingEnumeration answer = ldapContext.search(\"dc=example,dc=org\", \"(cn={0})\",\nsearchArguments, searchControls);\n// Process the response answer\nwhile (answer.hasMoreElements()) {\n  ...\n}\n```\n\nFor information on enabling authentication, please see your LDAP server's\ndocumentation.\n\nFor more information on LDAP Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html\n"},"help":{"markdown":"The application does not provide authentication when communicating an LDAP\nserver. It is strongly recommended that the LDAP server be configured with\nauthentication and restrict what queries users can execute.\n\nExample code that authenticates with a remote LDAP server and encodes any\nuser-supplied input:\n```\n// Create a properties to hold the ldap connection details\nProperties props = new Properties();\n// Use the com.sun.jndi.ldap.LdapCtxFactory factory provider\nprops.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n// The LDAP server URL\nprops.put(Context.PROVIDER_URL, \"ldap://ldap.example.org:3889\");\n// User details for the connection\nprops.put(Context.SECURITY_PRINCIPAL, \"cn=admin,dc=example,dc=org\");\n// LDAP account password\nString ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();\n// Pass in the LDAP password\nprops.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);\n\n// Create the LDAPContext\nInitialDirContext ldapContext = new InitialDirContext(props);\n// Example using SUBTREE_SCOPE SearchControls\nSearchControls searchControls = new SearchControls();\nsearchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n// Get user input for query\nString userQuery = someUserInput;\n// Use searchArguments to hold the user-supplied input\nObject[] searchArguments = new Object[]{userQuery};\n// Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,\nand pass in the search controls.\n// searchArguments automatically encode\nNamingEnumeration answer = ldapContext.search(\"dc=example,dc=org\", \"(cn={0})\",\nsearchArguments, searchControls);\n// Process the response answer\nwhile (answer.hasMoreElements()) {\n  ...\n}\n```\n\nFor information on enabling authentication, please see your LDAP server's\ndocumentation.\n\nFor more information on LDAP Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.LDAP_ANONYMOUS-1)\n","text":"The application does not provide authentication when communicating an LDAP\nserver. It is strongly recommended that the LDAP server be configured with\nauthentication and restrict what queries users can execute.\n\nExample code that authenticates with a remote LDAP server and encodes any\nuser-supplied input:\n```\n// Create a properties to hold the ldap connection details\nProperties props = new Properties();\n// Use the com.sun.jndi.ldap.LdapCtxFactory factory provider\nprops.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n// The LDAP server URL\nprops.put(Context.PROVIDER_URL, \"ldap://ldap.example.org:3889\");\n// User details for the connection\nprops.put(Context.SECURITY_PRINCIPAL, \"cn=admin,dc=example,dc=org\");\n// LDAP account password\nString ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();\n// Pass in the LDAP password\nprops.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);\n\n// Create the LDAPContext\nInitialDirContext ldapContext = new InitialDirContext(props);\n// Example using SUBTREE_SCOPE SearchControls\nSearchControls searchControls = new SearchControls();\nsearchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n// Get user input for query\nString userQuery = someUserInput;\n// Use searchArguments to hold the user-supplied input\nObject[] searchArguments = new Object[]{userQuery};\n// Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,\nand pass in the search controls.\n// searchArguments automatically encode\nNamingEnumeration answer = ldapContext.search(\"dc=example,dc=org\", \"(cn={0})\",\nsearchArguments, searchControls);\n// Process the response answer\nwhile (answer.hasMoreElements()) {\n  ...\n}\n```\n\nFor information on enabling authentication, please see your LDAP server's\ndocumentation.\n\nFor more information on LDAP Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.LDAP_ANONYMOUS-1","id":"gitlab.find_sec_bugs.LDAP_ANONYMOUS-1","name":"gitlab.find_sec_bugs.LDAP_ANONYMOUS-1","properties":{"precision":"very-high","tags":["CWE-306","OWASP-A07:2021-Identification and Authentication Failures","OWASP-A2:2017-Broken Authentication","security"],"security-severity":"High"},"shortDescription":{"text":"Missing authentication for critical function (LDAP)"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n"},"help":{"markdown":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.LDAP_ENTRY_POISONING-1)\n","text":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.LDAP_ENTRY_POISONING-1","id":"gitlab.find_sec_bugs.LDAP_ENTRY_POISONING-1","name":"gitlab.find_sec_bugs.LDAP_ENTRY_POISONING-1","properties":{"precision":"very-high","tags":["CWE-20","security"]},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"LDAP injection attacks exploit LDAP queries to influence how data is returned by\nthe LDAP server.\n\nLater versions of Java's `InitialDirContext.search` introduced a four argument method, one of\nwhich is the `filterArg` parameter. The `filterArg` will be automatically encoded when\nquerying\nthe LDAP server. If this method signature is not available, the application must encode the\nLDAP strings manually.\n\nMore details on the four argument `search` method can be found here:\nhttps://docs.oracle.com/en/java/javase/20/docs/api/java.naming/javax/naming/directory/InitialDirContext.html#search(javax.naming.Name,java.lang.String,java.lang.Object[],javax.naming.directory.SearchControls)\n\nTo encode the string manually, it is recommended that all input passed to LDAP querying\nsystems\nencode the following values:\n\n- Any occurrence of the null character must be escaped as “\\00”.\n- Any occurrence of the open parenthesis character must be escaped as “\\28”.\n- Any occurrence of the close parenthesis character must be escaped as “\\29”.\n- Any occurrence of the asterisk character must be escaped as “\\2a”.\n- Any occurrence of the backslash character must be escaped as “\\5c”.\n\nExample function that safely encodes user-supplied input to be used in an LDAP query.\n```\npublic static String encodeLDAPString(String input) {\n  // Note the \\ character is replaced first\n  CharSequence[] chars = new CharSequence[] { \"\\\\\", \"\\0\", \"(\", \")\", \"*\" };\n  CharSequence[] encoded = new CharSequence[] { \"\\\\5c\", \"\\\\00\", \"\\\\28\", \"\\\\29\", \"\\\\2a\" };\n  // Iterate over each character sequence, replacing the raw value with an encoded version of\nit\n  for (int i = 0; i < chars.length; i++)\n  {\n      // re-assign to input\n      input = input.replace(chars[i], encoded[i]);\n  }\n  // return our modified input string\n  return input;\n}\n```\n\nExample code that using the `filterArgs` parameter which automatically encodes for us:\n```\n// Create a properties to hold the ldap connection details\nProperties props = new Properties();\n// Use the com.sun.jndi.ldap.LdapCtxFactory factory provider\nprops.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n// The LDAP server URL\nprops.put(Context.PROVIDER_URL, \"ldap://ldap.example.org:3889\");\n// User details for the connection\nprops.put(Context.SECURITY_PRINCIPAL, \"cn=admin,dc=example,dc=org\");\n// LDAP account password\nString ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();\n// Pass in the LDAP password\nprops.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);\n\n// Create the LDAPContext\nInitialDirContext ldapContext = new InitialDirContext(props);\n// Example using SUBTREE_SCOPE SearchControls\nSearchControls searchControls = new SearchControls();\nsearchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n// Get user input for query\nString userQuery = someUserInput;\n// Use searchArguments to hold the user-supplied input\nObject[] searchArguments = new Object[]{userQuery};\n// Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,\nand pass in the search controls.\n// searchArguments automatically encode\nNamingEnumeration answer = ldapContext.search(\"dc=example,dc=org\", \"(cn={0})\",\nsearchArguments, searchControls);\n// Process the response answer\nwhile (answer.hasMoreElements()) {\n  ...\n}\n```\n\nFor more information on LDAP Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html\n"},"help":{"markdown":"LDAP injection attacks exploit LDAP queries to influence how data is returned by\nthe LDAP server.\n\nLater versions of Java's `InitialDirContext.search` introduced a four argument method, one of\nwhich is the `filterArg` parameter. The `filterArg` will be automatically encoded when\nquerying\nthe LDAP server. If this method signature is not available, the application must encode the\nLDAP strings manually.\n\nMore details on the four argument `search` method can be found here:\nhttps://docs.oracle.com/en/java/javase/20/docs/api/java.naming/javax/naming/directory/InitialDirContext.html#search(javax.naming.Name,java.lang.String,java.lang.Object[],javax.naming.directory.SearchControls)\n\nTo encode the string manually, it is recommended that all input passed to LDAP querying\nsystems\nencode the following values:\n\n- Any occurrence of the null character must be escaped as “\\00”.\n- Any occurrence of the open parenthesis character must be escaped as “\\28”.\n- Any occurrence of the close parenthesis character must be escaped as “\\29”.\n- Any occurrence of the asterisk character must be escaped as “\\2a”.\n- Any occurrence of the backslash character must be escaped as “\\5c”.\n\nExample function that safely encodes user-supplied input to be used in an LDAP query.\n```\npublic static String encodeLDAPString(String input) {\n  // Note the \\ character is replaced first\n  CharSequence[] chars = new CharSequence[] { \"\\\\\", \"\\0\", \"(\", \")\", \"*\" };\n  CharSequence[] encoded = new CharSequence[] { \"\\\\5c\", \"\\\\00\", \"\\\\28\", \"\\\\29\", \"\\\\2a\" };\n  // Iterate over each character sequence, replacing the raw value with an encoded version of\nit\n  for (int i = 0; i < chars.length; i++)\n  {\n      // re-assign to input\n      input = input.replace(chars[i], encoded[i]);\n  }\n  // return our modified input string\n  return input;\n}\n```\n\nExample code that using the `filterArgs` parameter which automatically encodes for us:\n```\n// Create a properties to hold the ldap connection details\nProperties props = new Properties();\n// Use the com.sun.jndi.ldap.LdapCtxFactory factory provider\nprops.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n// The LDAP server URL\nprops.put(Context.PROVIDER_URL, \"ldap://ldap.example.org:3889\");\n// User details for the connection\nprops.put(Context.SECURITY_PRINCIPAL, \"cn=admin,dc=example,dc=org\");\n// LDAP account password\nString ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();\n// Pass in the LDAP password\nprops.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);\n\n// Create the LDAPContext\nInitialDirContext ldapContext = new InitialDirContext(props);\n// Example using SUBTREE_SCOPE SearchControls\nSearchControls searchControls = new SearchControls();\nsearchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n// Get user input for query\nString userQuery = someUserInput;\n// Use searchArguments to hold the user-supplied input\nObject[] searchArguments = new Object[]{userQuery};\n// Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,\nand pass in the search controls.\n// searchArguments automatically encode\nNamingEnumeration answer = ldapContext.search(\"dc=example,dc=org\", \"(cn={0})\",\nsearchArguments, searchControls);\n// Process the response answer\nwhile (answer.hasMoreElements()) {\n  ...\n}\n```\n\nFor more information on LDAP Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.LDAP_INJECTION-1)\n","text":"LDAP injection attacks exploit LDAP queries to influence how data is returned by\nthe LDAP server.\n\nLater versions of Java's `InitialDirContext.search` introduced a four argument method, one of\nwhich is the `filterArg` parameter. The `filterArg` will be automatically encoded when\nquerying\nthe LDAP server. If this method signature is not available, the application must encode the\nLDAP strings manually.\n\nMore details on the four argument `search` method can be found here:\nhttps://docs.oracle.com/en/java/javase/20/docs/api/java.naming/javax/naming/directory/InitialDirContext.html#search(javax.naming.Name,java.lang.String,java.lang.Object[],javax.naming.directory.SearchControls)\n\nTo encode the string manually, it is recommended that all input passed to LDAP querying\nsystems\nencode the following values:\n\n- Any occurrence of the null character must be escaped as “\\00”.\n- Any occurrence of the open parenthesis character must be escaped as “\\28”.\n- Any occurrence of the close parenthesis character must be escaped as “\\29”.\n- Any occurrence of the asterisk character must be escaped as “\\2a”.\n- Any occurrence of the backslash character must be escaped as “\\5c”.\n\nExample function that safely encodes user-supplied input to be used in an LDAP query.\n```\npublic static String encodeLDAPString(String input) {\n  // Note the \\ character is replaced first\n  CharSequence[] chars = new CharSequence[] { \"\\\\\", \"\\0\", \"(\", \")\", \"*\" };\n  CharSequence[] encoded = new CharSequence[] { \"\\\\5c\", \"\\\\00\", \"\\\\28\", \"\\\\29\", \"\\\\2a\" };\n  // Iterate over each character sequence, replacing the raw value with an encoded version of\nit\n  for (int i = 0; i < chars.length; i++)\n  {\n      // re-assign to input\n      input = input.replace(chars[i], encoded[i]);\n  }\n  // return our modified input string\n  return input;\n}\n```\n\nExample code that using the `filterArgs` parameter which automatically encodes for us:\n```\n// Create a properties to hold the ldap connection details\nProperties props = new Properties();\n// Use the com.sun.jndi.ldap.LdapCtxFactory factory provider\nprops.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n// The LDAP server URL\nprops.put(Context.PROVIDER_URL, \"ldap://ldap.example.org:3889\");\n// User details for the connection\nprops.put(Context.SECURITY_PRINCIPAL, \"cn=admin,dc=example,dc=org\");\n// LDAP account password\nString ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();\n// Pass in the LDAP password\nprops.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);\n\n// Create the LDAPContext\nInitialDirContext ldapContext = new InitialDirContext(props);\n// Example using SUBTREE_SCOPE SearchControls\nSearchControls searchControls = new SearchControls();\nsearchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n// Get user input for query\nString userQuery = someUserInput;\n// Use searchArguments to hold the user-supplied input\nObject[] searchArguments = new Object[]{userQuery};\n// Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,\nand pass in the search controls.\n// searchArguments automatically encode\nNamingEnumeration answer = ldapContext.search(\"dc=example,dc=org\", \"(cn={0})\",\nsearchArguments, searchControls);\n// Process the response answer\nwhile (answer.hasMoreElements()) {\n  ...\n}\n```\n\nFor more information on LDAP Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.LDAP_INJECTION-1","id":"gitlab.find_sec_bugs.LDAP_INJECTION-1","name":"gitlab.find_sec_bugs.LDAP_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-90","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper neutralization of special elements used in an LDAP query ('LDAP Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application performs XSLT translation with potentially malicious input. An adversary who\nis able to influence the\nloaded\nXSL document could call XSL functions or exploit External XML Entity (XXE) attacks that allow\nfile\nretrieval or force the parser to connect to arbitrary servers to exfiltrate files. It is\nstrongly\nrecommended that an alternative approach is used to work with XML data.\n\nFor increased security, never process user-supplied XSL style sheets. If XSLT processing is\nabsolutely\nnecessary, ensure that `FEATURE_SECURE_PROCESSING` is enabled prior to processing the XSLT\nfile:\n```\n// Create a new TransformerFactory instance\nTransformerFactory transformerFactory = TransformerFactory.newInstance();\n// Enable the FEATURE_SECURE_PROCESSING feature\ntransformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n// Read in the XML Source\nSource xmlSource = new StreamSource(new FileInputStream(\"hardcoded.xml\"));\n// Read in the XSL template file\nSource xslSource = new StreamSource(new FileInputStream(\"hardcoded.xsl\"));\n/// Create the transformer object to do the transformation\nTransformer transformer = transformerFactory.newTransformer(xslSource);\n// Create a Result object for output\nResult result = new StreamResult(System.out);\n// Execute the transformation process\ntransformer.transform(xmlSource, result);\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n\nFor more information on the secure processing feature see:\n- https://xml.apache.org/xalan-j/features.html#secureprocessing\n"},"help":{"markdown":"The application performs XSLT translation with potentially malicious input. An adversary who\nis able to influence the\nloaded\nXSL document could call XSL functions or exploit External XML Entity (XXE) attacks that allow\nfile\nretrieval or force the parser to connect to arbitrary servers to exfiltrate files. It is\nstrongly\nrecommended that an alternative approach is used to work with XML data.\n\nFor increased security, never process user-supplied XSL style sheets. If XSLT processing is\nabsolutely\nnecessary, ensure that `FEATURE_SECURE_PROCESSING` is enabled prior to processing the XSLT\nfile:\n```\n// Create a new TransformerFactory instance\nTransformerFactory transformerFactory = TransformerFactory.newInstance();\n// Enable the FEATURE_SECURE_PROCESSING feature\ntransformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n// Read in the XML Source\nSource xmlSource = new StreamSource(new FileInputStream(\"hardcoded.xml\"));\n// Read in the XSL template file\nSource xslSource = new StreamSource(new FileInputStream(\"hardcoded.xsl\"));\n/// Create the transformer object to do the transformation\nTransformer transformer = transformerFactory.newTransformer(xslSource);\n// Create a Result object for output\nResult result = new StreamResult(System.out);\n// Execute the transformation process\ntransformer.transform(xmlSource, result);\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n\nFor more information on the secure processing feature see:\n- https://xml.apache.org/xalan-j/features.html#secureprocessing\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.MALICIOUS_XSLT-1)\n","text":"The application performs XSLT translation with potentially malicious input. An adversary who\nis able to influence the\nloaded\nXSL document could call XSL functions or exploit External XML Entity (XXE) attacks that allow\nfile\nretrieval or force the parser to connect to arbitrary servers to exfiltrate files. It is\nstrongly\nrecommended that an alternative approach is used to work with XML data.\n\nFor increased security, never process user-supplied XSL style sheets. If XSLT processing is\nabsolutely\nnecessary, ensure that `FEATURE_SECURE_PROCESSING` is enabled prior to processing the XSLT\nfile:\n```\n// Create a new TransformerFactory instance\nTransformerFactory transformerFactory = TransformerFactory.newInstance();\n// Enable the FEATURE_SECURE_PROCESSING feature\ntransformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n// Read in the XML Source\nSource xmlSource = new StreamSource(new FileInputStream(\"hardcoded.xml\"));\n// Read in the XSL template file\nSource xslSource = new StreamSource(new FileInputStream(\"hardcoded.xsl\"));\n/// Create the transformer object to do the transformation\nTransformer transformer = transformerFactory.newTransformer(xslSource);\n// Create a Result object for output\nResult result = new StreamResult(System.out);\n// Execute the transformation process\ntransformer.transform(xmlSource, result);\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n\nFor more information on the secure processing feature see:\n- https://xml.apache.org/xalan-j/features.html#secureprocessing\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.MALICIOUS_XSLT-1","id":"gitlab.find_sec_bugs.MALICIOUS_XSLT-1","name":"gitlab.find_sec_bugs.MALICIOUS_XSLT-1","properties":{"precision":"very-high","tags":["CWE-74","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper neutralization of special elements in output used by a downstream component ('Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found matching a variable during a regular expression\npattern match, and then calling string modification functions after validation has occurred.\nThis is usually indicative of a poor input validation strategy as an adversary may attempt to\nexploit the removal of characters.\n\nFor example a common mistake in attempting to remove path characters to protect against path\ntraversal is to match '../' and then remove any matches. However, if an adversary were to\ninclude in their input: '....//' then the `replace`  method would replace the first `../` but\ncause the leading `..` and trailing `/` to join into the final string of `../`, effectively\nbypassing the check.\n\nTo remediate this issue always perform string modifications before any validation of a string.\nIt is strongly recommended that strings be encoded instead of replaced or removed prior to\nvalidation.\n\n\nExample replaces `..` before validation. Do note this is still not a recommended method for\nprotecting against directory traversal, always use randomly generated IDs or filenames instead:\n```\n// This is ONLY for demonstration purpose, never use untrusted input\n// in paths, always use randomly generated filenames or IDs.\nString input = \"test../....//dir\";\n// Use replaceAll _not_ replace\ninput = input.replaceAll(\"\\\\.\\\\.\", \"\");\n// Input would be test///dir at this point\n// Create a pattern to match on\nPattern pattern = Pattern.compile(\"\\\\.\\\\.\");\n// Create a matcher\nMatcher match = pattern.matcher(input);\n// Call find to see if .. is still in our string\nif (match.find()) {\n    throw new Exception(\".. detected\");\n}\n// Use the input (but do not modify the string)\nSystem.out.println(input + \" safe\");\n```\n\nFor more information see Carnegie Mellon University's Secure Coding Guide:\nhttps://wiki.sei.cmu.edu/confluence/display/java/IDS11-J.+Perform+any+string+modifications+before+validation\n\n"},"help":{"markdown":"The application was found matching a variable during a regular expression\npattern match, and then calling string modification functions after validation has occurred.\nThis is usually indicative of a poor input validation strategy as an adversary may attempt to\nexploit the removal of characters.\n\nFor example a common mistake in attempting to remove path characters to protect against path\ntraversal is to match '../' and then remove any matches. However, if an adversary were to\ninclude in their input: '....//' then the `replace`  method would replace the first `../` but\ncause the leading `..` and trailing `/` to join into the final string of `../`, effectively\nbypassing the check.\n\nTo remediate this issue always perform string modifications before any validation of a string.\nIt is strongly recommended that strings be encoded instead of replaced or removed prior to\nvalidation.\n\n\nExample replaces `..` before validation. Do note this is still not a recommended method for\nprotecting against directory traversal, always use randomly generated IDs or filenames instead:\n```\n// This is ONLY for demonstration purpose, never use untrusted input\n// in paths, always use randomly generated filenames or IDs.\nString input = \"test../....//dir\";\n// Use replaceAll _not_ replace\ninput = input.replaceAll(\"\\\\.\\\\.\", \"\");\n// Input would be test///dir at this point\n// Create a pattern to match on\nPattern pattern = Pattern.compile(\"\\\\.\\\\.\");\n// Create a matcher\nMatcher match = pattern.matcher(input);\n// Call find to see if .. is still in our string\nif (match.find()) {\n    throw new Exception(\".. detected\");\n}\n// Use the input (but do not modify the string)\nSystem.out.println(input + \" safe\");\n```\n\nFor more information see Carnegie Mellon University's Secure Coding Guide:\nhttps://wiki.sei.cmu.edu/confluence/display/java/IDS11-J.+Perform+any+string+modifications+before+validation\n\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.MODIFICATION_AFTER_VALIDATION-1)\n","text":"The application was found matching a variable during a regular expression\npattern match, and then calling string modification functions after validation has occurred.\nThis is usually indicative of a poor input validation strategy as an adversary may attempt to\nexploit the removal of characters.\n\nFor example a common mistake in attempting to remove path characters to protect against path\ntraversal is to match '../' and then remove any matches. However, if an adversary were to\ninclude in their input: '....//' then the `replace`  method would replace the first `../` but\ncause the leading `..` and trailing `/` to join into the final string of `../`, effectively\nbypassing the check.\n\nTo remediate this issue always perform string modifications before any validation of a string.\nIt is strongly recommended that strings be encoded instead of replaced or removed prior to\nvalidation.\n\n\nExample replaces `..` before validation. Do note this is still not a recommended method for\nprotecting against directory traversal, always use randomly generated IDs or filenames instead:\n```\n// This is ONLY for demonstration purpose, never use untrusted input\n// in paths, always use randomly generated filenames or IDs.\nString input = \"test../....//dir\";\n// Use replaceAll _not_ replace\ninput = input.replaceAll(\"\\\\.\\\\.\", \"\");\n// Input would be test///dir at this point\n// Create a pattern to match on\nPattern pattern = Pattern.compile(\"\\\\.\\\\.\");\n// Create a matcher\nMatcher match = pattern.matcher(input);\n// Call find to see if .. is still in our string\nif (match.find()) {\n    throw new Exception(\".. detected\");\n}\n// Use the input (but do not modify the string)\nSystem.out.println(input + \" safe\");\n```\n\nFor more information see Carnegie Mellon University's Secure Coding Guide:\nhttps://wiki.sei.cmu.edu/confluence/display/java/IDS11-J.+Perform+any+string+modifications+before+validation\n\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.MODIFICATION_AFTER_VALIDATION-1","id":"gitlab.find_sec_bugs.MODIFICATION_AFTER_VALIDATION-1","name":"gitlab.find_sec_bugs.MODIFICATION_AFTER_VALIDATION-1","properties":{"precision":"very-high","tags":["CWE-182","HIGH CONFIDENCE","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Info"},"shortDescription":{"text":"Collapse of data into unsafe value"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found matching a variable during a regular expression\npattern match, and then calling a Unicode normalize function after validation has occurred.\nThis is usually indicative of a poor input validation strategy as an adversary may attempt to\nexploit the normalization process.\n\nTo remediate this issue, always perform Unicode normalization before any validation of a\nstring.\n\nExample of normalizing a string before validation:\n```\n// User input possibly containing malicious unicode\nString userInput = \"\\uFE64\" + \"tag\" + \"\\uFE65\";\n// Normalize the input\nuserInput = Normalizer.normalize(userInput, Normalizer.Form.NFKC);\n// Compile our regex pattern looking for < or > characters\nPattern pattern = Pattern.compile(\"[<>]\");\n// Create a matcher from the userInput\nMatcher matcher = pattern.matcher(userInput);\n// See if the matcher matches\nif (matcher.find()) {\n    // It did so throw an error\n    throw new Exception(\"found banned characters in input\");\n}\n```\n\nFor more information see Carnegie Mellon University's Secure Coding Guide:\nhttps://wiki.sei.cmu.edu/confluence/display/java/IDS01-J.+Normalize+strings+before+validating+them\n"},"help":{"markdown":"The application was found matching a variable during a regular expression\npattern match, and then calling a Unicode normalize function after validation has occurred.\nThis is usually indicative of a poor input validation strategy as an adversary may attempt to\nexploit the normalization process.\n\nTo remediate this issue, always perform Unicode normalization before any validation of a\nstring.\n\nExample of normalizing a string before validation:\n```\n// User input possibly containing malicious unicode\nString userInput = \"\\uFE64\" + \"tag\" + \"\\uFE65\";\n// Normalize the input\nuserInput = Normalizer.normalize(userInput, Normalizer.Form.NFKC);\n// Compile our regex pattern looking for < or > characters\nPattern pattern = Pattern.compile(\"[<>]\");\n// Create a matcher from the userInput\nMatcher matcher = pattern.matcher(userInput);\n// See if the matcher matches\nif (matcher.find()) {\n    // It did so throw an error\n    throw new Exception(\"found banned characters in input\");\n}\n```\n\nFor more information see Carnegie Mellon University's Secure Coding Guide:\nhttps://wiki.sei.cmu.edu/confluence/display/java/IDS01-J.+Normalize+strings+before+validating+them\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.NORMALIZATION_AFTER_VALIDATION-1)\n","text":"The application was found matching a variable during a regular expression\npattern match, and then calling a Unicode normalize function after validation has occurred.\nThis is usually indicative of a poor input validation strategy as an adversary may attempt to\nexploit the normalization process.\n\nTo remediate this issue, always perform Unicode normalization before any validation of a\nstring.\n\nExample of normalizing a string before validation:\n```\n// User input possibly containing malicious unicode\nString userInput = \"\\uFE64\" + \"tag\" + \"\\uFE65\";\n// Normalize the input\nuserInput = Normalizer.normalize(userInput, Normalizer.Form.NFKC);\n// Compile our regex pattern looking for < or > characters\nPattern pattern = Pattern.compile(\"[<>]\");\n// Create a matcher from the userInput\nMatcher matcher = pattern.matcher(userInput);\n// See if the matcher matches\nif (matcher.find()) {\n    // It did so throw an error\n    throw new Exception(\"found banned characters in input\");\n}\n```\n\nFor more information see Carnegie Mellon University's Secure Coding Guide:\nhttps://wiki.sei.cmu.edu/confluence/display/java/IDS01-J.+Normalize+strings+before+validating+them\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.NORMALIZATION_AFTER_VALIDATION-1","id":"gitlab.find_sec_bugs.NORMALIZATION_AFTER_VALIDATION-1","name":"gitlab.find_sec_bugs.NORMALIZATION_AFTER_VALIDATION-1","properties":{"precision":"very-high","tags":["CWE-180","HIGH CONFIDENCE","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Info"},"shortDescription":{"text":"Incorrect behavior order: validate before canonicalize"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found creating a `NullCipher` instance. `NullCipher` implements the\n`Cipher` interface by returning ciphertext identical to the supplied plaintext. This means\nany data passed to the `doFinal(...)` or `update(...)` methods will not actually encrypt\nthe input.\n\nRemove the NullCipher reference and replace with a legitimate `Cipher` instance such as\n`ChaCha20-Poly1305`\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"The application was found creating a `NullCipher` instance. `NullCipher` implements the\n`Cipher` interface by returning ciphertext identical to the supplied plaintext. This means\nany data passed to the `doFinal(...)` or `update(...)` methods will not actually encrypt\nthe input.\n\nRemove the NullCipher reference and replace with a legitimate `Cipher` instance such as\n`ChaCha20-Poly1305`\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.NULL_CIPHER-1)\n","text":"The application was found creating a `NullCipher` instance. `NullCipher` implements the\n`Cipher` interface by returning ciphertext identical to the supplied plaintext. This means\nany data passed to the `doFinal(...)` or `update(...)` methods will not actually encrypt\nthe input.\n\nRemove the NullCipher reference and replace with a legitimate `Cipher` instance such as\n`ChaCha20-Poly1305`\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.NULL_CIPHER-1","id":"gitlab.find_sec_bugs.NULL_CIPHER-1","name":"gitlab.find_sec_bugs.NULL_CIPHER-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The Object Graph Navigation Language (OGNL) is an expression language that allows access to\nJava objects and properties stored in an ActionContext. Usage of these low-level\nfunctions is discouraged because they can effectively execute strings as code, leading to\nremote code execution vulnerabilities. Consider using struts tags when processing\nuser-supplied input and templates.\n\nMuch like the Struts security guide recommending to not use raw `${}` EL expressions,\ndo not call or use the following OGNL packages with user-supplied input:\n\n- `com.opensymphony.xwork2.ognl`\n- `com.opensymphony.xwork2.util`\n- `com.opensymphony.xwork2.util.reflection`\n- `org.apache.struts2.util.StrutsUtil`\n\nFor more information on Struts2 security see:\nhttps://struts.apache.org/security/#do-not-use-incoming-untrusted-user-input-in-forced-expression-evaluation\n"},"help":{"markdown":"The Object Graph Navigation Language (OGNL) is an expression language that allows access to\nJava objects and properties stored in an ActionContext. Usage of these low-level\nfunctions is discouraged because they can effectively execute strings as code, leading to\nremote code execution vulnerabilities. Consider using struts tags when processing\nuser-supplied input and templates.\n\nMuch like the Struts security guide recommending to not use raw `${}` EL expressions,\ndo not call or use the following OGNL packages with user-supplied input:\n\n- `com.opensymphony.xwork2.ognl`\n- `com.opensymphony.xwork2.util`\n- `com.opensymphony.xwork2.util.reflection`\n- `org.apache.struts2.util.StrutsUtil`\n\nFor more information on Struts2 security see:\nhttps://struts.apache.org/security/#do-not-use-incoming-untrusted-user-input-in-forced-expression-evaluation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.OGNL_INJECTION-1)\n","text":"The Object Graph Navigation Language (OGNL) is an expression language that allows access to\nJava objects and properties stored in an ActionContext. Usage of these low-level\nfunctions is discouraged because they can effectively execute strings as code, leading to\nremote code execution vulnerabilities. Consider using struts tags when processing\nuser-supplied input and templates.\n\nMuch like the Struts security guide recommending to not use raw `${}` EL expressions,\ndo not call or use the following OGNL packages with user-supplied input:\n\n- `com.opensymphony.xwork2.ognl`\n- `com.opensymphony.xwork2.util`\n- `com.opensymphony.xwork2.util.reflection`\n- `org.apache.struts2.util.StrutsUtil`\n\nFor more information on Struts2 security see:\nhttps://struts.apache.org/security/#do-not-use-incoming-untrusted-user-input-in-forced-expression-evaluation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.OGNL_INJECTION-1","id":"gitlab.find_sec_bugs.OGNL_INJECTION-1","name":"gitlab.find_sec_bugs.OGNL_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-917","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"High"},"shortDescription":{"text":"Expression injection (OGNL)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found setting file permissions to overly permissive values. Consider\nusing the following values if the application user is the only process to access\nthe file:\n\n- `r--` - read only access to the file\n- `w--` - write only access to the file\n- `rw-` - read/write access to the file\n\nExample setting read/write permissions for only the owner of a `Path`:\n```\n// Get a reference to the path\nPath path = Paths.get(\"/tmp/somefile\");\n// Create a PosixFilePermission set from java.nio.file.attribute\nSet<PosixFilePermission> permissions =\njava.nio.file.attribute.PosixFilePermissions.fromString(\"rw-------\");\n// Set the permissions\njava.nio.file.Files.setPosixFilePermissions(path, permissions);\n```\n\nFor all other values please see:\nhttps://en.wikipedia.org/wiki/File-system_permissions#Symbolic_notation\n"},"help":{"markdown":"The application was found setting file permissions to overly permissive values. Consider\nusing the following values if the application user is the only process to access\nthe file:\n\n- `r--` - read only access to the file\n- `w--` - write only access to the file\n- `rw-` - read/write access to the file\n\nExample setting read/write permissions for only the owner of a `Path`:\n```\n// Get a reference to the path\nPath path = Paths.get(\"/tmp/somefile\");\n// Create a PosixFilePermission set from java.nio.file.attribute\nSet<PosixFilePermission> permissions =\njava.nio.file.attribute.PosixFilePermissions.fromString(\"rw-------\");\n// Set the permissions\njava.nio.file.Files.setPosixFilePermissions(path, permissions);\n```\n\nFor all other values please see:\nhttps://en.wikipedia.org/wiki/File-system_permissions#Symbolic_notation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-1)\n","text":"The application was found setting file permissions to overly permissive values. Consider\nusing the following values if the application user is the only process to access\nthe file:\n\n- `r--` - read only access to the file\n- `w--` - write only access to the file\n- `rw-` - read/write access to the file\n\nExample setting read/write permissions for only the owner of a `Path`:\n```\n// Get a reference to the path\nPath path = Paths.get(\"/tmp/somefile\");\n// Create a PosixFilePermission set from java.nio.file.attribute\nSet<PosixFilePermission> permissions =\njava.nio.file.attribute.PosixFilePermissions.fromString(\"rw-------\");\n// Set the permissions\njava.nio.file.Files.setPosixFilePermissions(path, permissions);\n```\n\nFor all other values please see:\nhttps://en.wikipedia.org/wiki/File-system_permissions#Symbolic_notation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-1","id":"gitlab.find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-1","name":"gitlab.find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-1","properties":{"precision":"very-high","tags":["CWE-732","HIGH CONFIDENCE","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Medium"},"shortDescription":{"text":"Incorrect permission assignment for critical resource"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Overly permissive file permission\n"},"help":{"markdown":"Overly permissive file permission\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-2)\n","text":"Overly permissive file permission\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-2","id":"gitlab.find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-2","name":"gitlab.find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-2","properties":{"precision":"very-high","tags":["CWE-732","HIGH CONFIDENCE","security"]},"shortDescription":{"text":"Incorrect Permission Assignment for Critical Resource"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Cryptographic block ciphers can be configured to pad individual blocks if there is not enough\ninput data to match the size of the block. This specific mode of CBC used in combination with\nPKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt\nthe message if the system exposed the difference between plaintext with invalid padding or\nvalid padding. The distinction between valid and invalid padding is usually revealed through\ndistinct error messages being returned for each condition.\n\nConsider switching to a more secure cipher that doesn't require padding and builds in message\nauthentication integrity directly into the algorithm.\n\nConsider using `ChaCha20Poly1305` or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on padding oracle attacks see:\nhttps://en.wikipedia.org/wiki/Padding_oracle_attack\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"Cryptographic block ciphers can be configured to pad individual blocks if there is not enough\ninput data to match the size of the block. This specific mode of CBC used in combination with\nPKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt\nthe message if the system exposed the difference between plaintext with invalid padding or\nvalid padding. The distinction between valid and invalid padding is usually revealed through\ndistinct error messages being returned for each condition.\n\nConsider switching to a more secure cipher that doesn't require padding and builds in message\nauthentication integrity directly into the algorithm.\n\nConsider using `ChaCha20Poly1305` or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on padding oracle attacks see:\nhttps://en.wikipedia.org/wiki/Padding_oracle_attack\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.PADDING_ORACLE-1)\n","text":"Cryptographic block ciphers can be configured to pad individual blocks if there is not enough\ninput data to match the size of the block. This specific mode of CBC used in combination with\nPKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt\nthe message if the system exposed the difference between plaintext with invalid padding or\nvalid padding. The distinction between valid and invalid padding is usually revealed through\ndistinct error messages being returned for each condition.\n\nConsider switching to a more secure cipher that doesn't require padding and builds in message\nauthentication integrity directly into the algorithm.\n\nConsider using `ChaCha20Poly1305` or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our ivKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV Key\n    byte[] ivKey = new byte[12];\n    random.nextBytes(ivKey);\n\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);\n\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n\n     // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);\n\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on padding oracle attacks see:\nhttps://en.wikipedia.org/wiki/Padding_oracle_attack\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.PADDING_ORACLE-1","id":"gitlab.find_sec_bugs.PADDING_ORACLE-1","name":"gitlab.find_sec_bugs.PADDING_ORACLE-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A file is opened to read its content. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files from an arbitrary filesystem location\ncould be read. This rule identifies potential path traversal vulnerabilities. In many cases,\nthe constructed file path cannot be controlled by the user.\n"},"help":{"markdown":"A file is opened to read its content. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files from an arbitrary filesystem location\ncould be read. This rule identifies potential path traversal vulnerabilities. In many cases,\nthe constructed file path cannot be controlled by the user.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.PATH_TRAVERSAL_IN-1)\n","text":"A file is opened to read its content. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files from an arbitrary filesystem location\ncould be read. This rule identifies potential path traversal vulnerabilities. In many cases,\nthe constructed file path cannot be controlled by the user.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.PATH_TRAVERSAL_IN-1","id":"gitlab.find_sec_bugs.PATH_TRAVERSAL_IN-1","name":"gitlab.find_sec_bugs.PATH_TRAVERSAL_IN-1","properties":{"precision":"very-high","tags":["CWE-22","security"]},"shortDescription":{"text":"Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A file is opened to write to its contents. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files at an arbitrary filesystem location\ncould be modified. This rule identifies potential path traversal vulnerabilities. In many\ncases, the constructed file path cannot be controlled by the user.\n"},"help":{"markdown":"A file is opened to write to its contents. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files at an arbitrary filesystem location\ncould be modified. This rule identifies potential path traversal vulnerabilities. In many\ncases, the constructed file path cannot be controlled by the user.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.PATH_TRAVERSAL_OUT-1.PATH_TRAVERSAL_OUT-1)\n","text":"A file is opened to write to its contents. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files at an arbitrary filesystem location\ncould be modified. This rule identifies potential path traversal vulnerabilities. In many\ncases, the constructed file path cannot be controlled by the user.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.PATH_TRAVERSAL_OUT-1.PATH_TRAVERSAL_OUT-1","id":"gitlab.find_sec_bugs.PATH_TRAVERSAL_OUT-1.PATH_TRAVERSAL_OUT-1","name":"gitlab.find_sec_bugs.PATH_TRAVERSAL_OUT-1.PATH_TRAVERSAL_OUT-1","properties":{"precision":"very-high","tags":["CWE-22","security"]},"shortDescription":{"text":"Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n"},"help":{"markdown":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.PERMISSIVE_CORS-1)\n","text":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.PERMISSIVE_CORS-1","id":"gitlab.find_sec_bugs.PERMISSIVE_CORS-1","name":"gitlab.find_sec_bugs.PERMISSIVE_CORS-1","properties":{"precision":"very-high","tags":["CWE-942","security"]},"shortDescription":{"text":"Permissive Cross-domain Policy with Untrusted Domains"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"This application potentially allows user-supplied input into the value of the\n`Access-Control-Allow-Origin` response header. This header is part of the\n[Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) CORS\nspecification. By allowing user input to specify which domains can communicate with this\nserver,\nan adversary could exploit a weakness in this server to force clients to send credentials (such\nas session\nidentifiers) to the adversary's server.\n\nFor the above attack to work, the application would need to suffer from an additional\nvulnerability,\nsuch as Cross-Site Scripting (XSS).\n\nTo remediate this issue, do not use user-supplied information when calling\n`HttpServletResponse.setHeader` or `HttpServletResponse.addHeader`\nfor the `Access-Control-Allow-Origin` header's value. Instead, hardcode the allowed domain(s)\nand reference them in a lookup\ntable:\nExample allowing dynamic but safe domains in `Access-Control-Allow-Origin`:\n\n```\n  // this data should be in the class constructor or taken from a trusted datasource\n  Map<String, String> allowedDomains = new HashMap();\n  allowedDomains.put(\"sub1\", \"sub1.example.com\");\n  allowedDomains.put(\"sub2\", \"sub2.example.com\");\n\n  // extract the allowedDomain parameters value as a key to look up which domain to provide\nvia the allowedDomains map\n  // if not found, sets sub1 as the default\n  String headerValue = allowedDomains.getOrDefault(request.getParameter(\"allowedDomain\"),\nallowedDomains.get(\"sub1\"));\n\n  // add the header with our trusted sub1.example.com or sub2.example.com domains.\n  response.addHeader(\"Access-Control-Allow-Origin\", headerValue);\n}\n```\n\nFor more information on `Access-Control-Allow-Origin` see:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\n"},"help":{"markdown":"This application potentially allows user-supplied input into the value of the\n`Access-Control-Allow-Origin` response header. This header is part of the\n[Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) CORS\nspecification. By allowing user input to specify which domains can communicate with this\nserver,\nan adversary could exploit a weakness in this server to force clients to send credentials (such\nas session\nidentifiers) to the adversary's server.\n\nFor the above attack to work, the application would need to suffer from an additional\nvulnerability,\nsuch as Cross-Site Scripting (XSS).\n\nTo remediate this issue, do not use user-supplied information when calling\n`HttpServletResponse.setHeader` or `HttpServletResponse.addHeader`\nfor the `Access-Control-Allow-Origin` header's value. Instead, hardcode the allowed domain(s)\nand reference them in a lookup\ntable:\nExample allowing dynamic but safe domains in `Access-Control-Allow-Origin`:\n\n```\n  // this data should be in the class constructor or taken from a trusted datasource\n  Map<String, String> allowedDomains = new HashMap();\n  allowedDomains.put(\"sub1\", \"sub1.example.com\");\n  allowedDomains.put(\"sub2\", \"sub2.example.com\");\n\n  // extract the allowedDomain parameters value as a key to look up which domain to provide\nvia the allowedDomains map\n  // if not found, sets sub1 as the default\n  String headerValue = allowedDomains.getOrDefault(request.getParameter(\"allowedDomain\"),\nallowedDomains.get(\"sub1\"));\n\n  // add the header with our trusted sub1.example.com or sub2.example.com domains.\n  response.addHeader(\"Access-Control-Allow-Origin\", headerValue);\n}\n```\n\nFor more information on `Access-Control-Allow-Origin` see:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.PERMISSIVE_CORS-2)\n","text":"This application potentially allows user-supplied input into the value of the\n`Access-Control-Allow-Origin` response header. This header is part of the\n[Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) CORS\nspecification. By allowing user input to specify which domains can communicate with this\nserver,\nan adversary could exploit a weakness in this server to force clients to send credentials (such\nas session\nidentifiers) to the adversary's server.\n\nFor the above attack to work, the application would need to suffer from an additional\nvulnerability,\nsuch as Cross-Site Scripting (XSS).\n\nTo remediate this issue, do not use user-supplied information when calling\n`HttpServletResponse.setHeader` or `HttpServletResponse.addHeader`\nfor the `Access-Control-Allow-Origin` header's value. Instead, hardcode the allowed domain(s)\nand reference them in a lookup\ntable:\nExample allowing dynamic but safe domains in `Access-Control-Allow-Origin`:\n\n```\n  // this data should be in the class constructor or taken from a trusted datasource\n  Map<String, String> allowedDomains = new HashMap();\n  allowedDomains.put(\"sub1\", \"sub1.example.com\");\n  allowedDomains.put(\"sub2\", \"sub2.example.com\");\n\n  // extract the allowedDomain parameters value as a key to look up which domain to provide\nvia the allowedDomains map\n  // if not found, sets sub1 as the default\n  String headerValue = allowedDomains.getOrDefault(request.getParameter(\"allowedDomain\"),\nallowedDomains.get(\"sub1\"));\n\n  // add the header with our trusted sub1.example.com or sub2.example.com domains.\n  response.addHeader(\"Access-Control-Allow-Origin\", headerValue);\n}\n```\n\nFor more information on `Access-Control-Allow-Origin` see:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.PERMISSIVE_CORS-2","id":"gitlab.find_sec_bugs.PERMISSIVE_CORS-2","name":"gitlab.find_sec_bugs.PERMISSIVE_CORS-2","properties":{"precision":"very-high","tags":["CWE-942","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Low"},"shortDescription":{"text":"Permissive cross-domain policy with untrusted domains"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Depending on the context, generating weak random numbers may expose cryptographic functions\nwhich rely on these numbers, to be exploitable. When generating numbers for sensitive values\nsuch as tokens, nonces, and cryptographic keys, it is recommended that the `DRBG` instance\nof `SecureRandom` be used.\n\nExample using `DRBG` with `SecureRandom`:\n```\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n// Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"Depending on the context, generating weak random numbers may expose cryptographic functions\nwhich rely on these numbers, to be exploitable. When generating numbers for sensitive values\nsuch as tokens, nonces, and cryptographic keys, it is recommended that the `DRBG` instance\nof `SecureRandom` be used.\n\nExample using `DRBG` with `SecureRandom`:\n```\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n// Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.PREDICTABLE_RANDOM-1)\n","text":"Depending on the context, generating weak random numbers may expose cryptographic functions\nwhich rely on these numbers, to be exploitable. When generating numbers for sensitive values\nsuch as tokens, nonces, and cryptographic keys, it is recommended that the `DRBG` instance\nof `SecureRandom` be used.\n\nExample using `DRBG` with `SecureRandom`:\n```\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n// Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.PREDICTABLE_RANDOM-1","id":"gitlab.find_sec_bugs.PREDICTABLE_RANDOM-1","name":"gitlab.find_sec_bugs.PREDICTABLE_RANDOM-1","properties":{"precision":"very-high","tags":["CWE-330","security"]},"shortDescription":{"text":"Use of insufficiently random values"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application dynamically constructs file or path information. If the path\ninformation comes from user input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or replacing it with unique values and\nuse `Path.resolve` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `Path.resolve` and not allowing direct user input:\n```\n// Class to store our user data along with a randomly generated file name\npublic static class UserData {\n    private String userFileNameUnsafe;\n    private String fileName;\n    public UserData(String userFileName) {\n        this.userFileNameUnsafe = userFileName;\n        // Generate a random ID for the filename\n        this.fileName = UUID.randomUUID().toString();\n    }\n    public String getUserFileNameUnsafe() { return userFileNameUnsafe; };\n    public String getFileName() { return fileName; };\n}\n\npublic static void main(String[] args) throws Exception {\n    // User input, saved only as a reference\n    UserData userData = new UserData(\"..\\\\test.txt\");\n    // Restrict all file processing to this directory only\n    String base = \"/var/app/restricted\";\n    Path basePath = Paths.get(base);\n    // Resolve the full path, but only use our random generated filename\n    Path fullPath = basePath.resolve(userData.getFileName());\n    // verify the path is contained within our basePath\n    if (!fullPath.startsWith(base)) {\n        throw new Exception(\"Invalid path specified!\");\n    }\n    // process / work with file\n}\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n"},"help":{"markdown":"The application dynamically constructs file or path information. If the path\ninformation comes from user input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or replacing it with unique values and\nuse `Path.resolve` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `Path.resolve` and not allowing direct user input:\n```\n// Class to store our user data along with a randomly generated file name\npublic static class UserData {\n    private String userFileNameUnsafe;\n    private String fileName;\n    public UserData(String userFileName) {\n        this.userFileNameUnsafe = userFileName;\n        // Generate a random ID for the filename\n        this.fileName = UUID.randomUUID().toString();\n    }\n    public String getUserFileNameUnsafe() { return userFileNameUnsafe; };\n    public String getFileName() { return fileName; };\n}\n\npublic static void main(String[] args) throws Exception {\n    // User input, saved only as a reference\n    UserData userData = new UserData(\"..\\\\test.txt\");\n    // Restrict all file processing to this directory only\n    String base = \"/var/app/restricted\";\n    Path basePath = Paths.get(base);\n    // Resolve the full path, but only use our random generated filename\n    Path fullPath = basePath.resolve(userData.getFileName());\n    // verify the path is contained within our basePath\n    if (!fullPath.startsWith(base)) {\n        throw new Exception(\"Invalid path specified!\");\n    }\n    // process / work with file\n}\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1)\n","text":"The application dynamically constructs file or path information. If the path\ninformation comes from user input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or replacing it with unique values and\nuse `Path.resolve` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `Path.resolve` and not allowing direct user input:\n```\n// Class to store our user data along with a randomly generated file name\npublic static class UserData {\n    private String userFileNameUnsafe;\n    private String fileName;\n    public UserData(String userFileName) {\n        this.userFileNameUnsafe = userFileName;\n        // Generate a random ID for the filename\n        this.fileName = UUID.randomUUID().toString();\n    }\n    public String getUserFileNameUnsafe() { return userFileNameUnsafe; };\n    public String getFileName() { return fileName; };\n}\n\npublic static void main(String[] args) throws Exception {\n    // User input, saved only as a reference\n    UserData userData = new UserData(\"..\\\\test.txt\");\n    // Restrict all file processing to this directory only\n    String base = \"/var/app/restricted\";\n    Path basePath = Paths.get(base);\n    // Resolve the full path, but only use our random generated filename\n    Path fullPath = basePath.resolve(userData.getFileName());\n    // verify the path is contained within our basePath\n    if (!fullPath.startsWith(base)) {\n        throw new Exception(\"Invalid path specified!\");\n    }\n    // process / work with file\n}\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1","id":"gitlab.find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1","name":"gitlab.find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"\"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize sequences such as \"..\" that can\nresolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/23.html for more information.\"\n"},"help":{"markdown":"\"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize sequences such as \"..\" that can\nresolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/23.html for more information.\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.PT_RELATIVE_PATH_TRAVERSAL-1)\n","text":"\"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize sequences such as \"..\" that can\nresolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/23.html for more information.\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.PT_RELATIVE_PATH_TRAVERSAL-1","id":"gitlab.find_sec_bugs.PT_RELATIVE_PATH_TRAVERSAL-1","name":"gitlab.find_sec_bugs.PT_RELATIVE_PATH_TRAVERSAL-1","properties":{"precision":"very-high","tags":["CWE-22","security"]},"shortDescription":{"text":"Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return\nany file that is resolvable within the web application context. This includes the `web.xml`\nfile, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are\naccessible.\n\nNever pass user-supplied input directly to any of these methods. Use a lookup table or\nhardcode\nwhich views or paths the user should be directed to. Another option is to use a simple HTTP\nredirect by returning an empty response body with a 301 status code and a `Location` redirect\nheader. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.\n\nExample using a redirect instead of a `RequestDispatcher`:\n```\n// Create a look up table or pull from a data source\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"/Resource1\");\nlookupTable.put(\"key2\", \"/Resource2\");\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Look up resource to redirect to from the user input\nString redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n// Redirect the user\nresponse.sendRedirect(redirectValue);\n```\n"},"help":{"markdown":"The `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return\nany file that is resolvable within the web application context. This includes the `web.xml`\nfile, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are\naccessible.\n\nNever pass user-supplied input directly to any of these methods. Use a lookup table or\nhardcode\nwhich views or paths the user should be directed to. Another option is to use a simple HTTP\nredirect by returning an empty response body with a 301 status code and a `Location` redirect\nheader. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.\n\nExample using a redirect instead of a `RequestDispatcher`:\n```\n// Create a look up table or pull from a data source\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"/Resource1\");\nlookupTable.put(\"key2\", \"/Resource2\");\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Look up resource to redirect to from the user input\nString redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n// Redirect the user\nresponse.sendRedirect(redirectValue);\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1)\n","text":"The `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return\nany file that is resolvable within the web application context. This includes the `web.xml`\nfile, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are\naccessible.\n\nNever pass user-supplied input directly to any of these methods. Use a lookup table or\nhardcode\nwhich views or paths the user should be directed to. Another option is to use a simple HTTP\nredirect by returning an empty response body with a 301 status code and a `Location` redirect\nheader. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.\n\nExample using a redirect instead of a `RequestDispatcher`:\n```\n// Create a look up table or pull from a data source\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"/Resource1\");\nlookupTable.put(\"key2\", \"/Resource2\");\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Look up resource to redirect to from the user input\nString redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n// Redirect the user\nresponse.sendRedirect(redirectValue);\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1","id":"gitlab.find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1","name":"gitlab.find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1","properties":{"precision":"very-high","tags":["CWE-552","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"HIGH"},"shortDescription":{"text":"Files or directories accessible to external parties"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The `org.springframework.web.servlet.ModelAndView` class and\n`HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods may\npotentially allow access to restricted files if called with user-supplied input.\n\nFor Spring MVC, the ModelAndView class looks up a view by name to resolve a `.jsp`\nfile. If this view name comes from user-supplied input, it could be abused to attempt\nto return a JSP view that the user should not have access to.\n\nThe `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return\nany file that is resolvable within the web application context. This includes the `web.xml`\nfile, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are\naccessible.\n\nNever pass user-supplied input directly to any of these methods. Use a lookup table or\nhardcode\nwhich views or paths the user should be directed to. Another option is to use a simple HTTP\nredirect by returning an empty response body with a 301 status code and a `Location` redirect\nheader. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.\n\nExample using a lookup table to resolve a view from a Spring MVC application:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n {\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up view from the user input\n  String viewValue = lookupTable.getOrDefault(userInput, userInput);\n  // return the new model and view\n  return new ModelAndView(viewValue);\n}\n```\n\nExample using a redirect instead of a `RequestDispatcher`:\n```\n// Create a look up table or pull from a data source\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"/Resource1\");\nlookupTable.put(\"key2\", \"/Resource2\");\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Look up resource to redirect to from the user input\nString redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n// Redirect the user\nresponse.sendRedirect(redirectValue);\n```\n"},"help":{"markdown":"The `org.springframework.web.servlet.ModelAndView` class and\n`HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods may\npotentially allow access to restricted files if called with user-supplied input.\n\nFor Spring MVC, the ModelAndView class looks up a view by name to resolve a `.jsp`\nfile. If this view name comes from user-supplied input, it could be abused to attempt\nto return a JSP view that the user should not have access to.\n\nThe `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return\nany file that is resolvable within the web application context. This includes the `web.xml`\nfile, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are\naccessible.\n\nNever pass user-supplied input directly to any of these methods. Use a lookup table or\nhardcode\nwhich views or paths the user should be directed to. Another option is to use a simple HTTP\nredirect by returning an empty response body with a 301 status code and a `Location` redirect\nheader. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.\n\nExample using a lookup table to resolve a view from a Spring MVC application:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n {\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up view from the user input\n  String viewValue = lookupTable.getOrDefault(userInput, userInput);\n  // return the new model and view\n  return new ModelAndView(viewValue);\n}\n```\n\nExample using a redirect instead of a `RequestDispatcher`:\n```\n// Create a look up table or pull from a data source\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"/Resource1\");\nlookupTable.put(\"key2\", \"/Resource2\");\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Look up resource to redirect to from the user input\nString redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n// Redirect the user\nresponse.sendRedirect(redirectValue);\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1)\n","text":"The `org.springframework.web.servlet.ModelAndView` class and\n`HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods may\npotentially allow access to restricted files if called with user-supplied input.\n\nFor Spring MVC, the ModelAndView class looks up a view by name to resolve a `.jsp`\nfile. If this view name comes from user-supplied input, it could be abused to attempt\nto return a JSP view that the user should not have access to.\n\nThe `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return\nany file that is resolvable within the web application context. This includes the `web.xml`\nfile, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are\naccessible.\n\nNever pass user-supplied input directly to any of these methods. Use a lookup table or\nhardcode\nwhich views or paths the user should be directed to. Another option is to use a simple HTTP\nredirect by returning an empty response body with a 301 status code and a `Location` redirect\nheader. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.\n\nExample using a lookup table to resolve a view from a Spring MVC application:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n {\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up view from the user input\n  String viewValue = lookupTable.getOrDefault(userInput, userInput);\n  // return the new model and view\n  return new ModelAndView(viewValue);\n}\n```\n\nExample using a redirect instead of a `RequestDispatcher`:\n```\n// Create a look up table or pull from a data source\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"/Resource1\");\nlookupTable.put(\"key2\", \"/Resource2\");\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Look up resource to redirect to from the user input\nString redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n// Redirect the user\nresponse.sendRedirect(redirectValue);\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1","id":"gitlab.find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1","name":"gitlab.find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1","properties":{"precision":"very-high","tags":["CWE-552","security"]},"shortDescription":{"text":"Files or directories accessible to external parties"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Enabling extensions in Apache XML RPC server or client can lead to deserialization\nvulnerability which would allow an attacker to execute arbitrary code.\n"},"help":{"markdown":"Enabling extensions in Apache XML RPC server or client can lead to deserialization\nvulnerability which would allow an attacker to execute arbitrary code.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.RPC_ENABLED_EXTENSIONS-1)\n","text":"Enabling extensions in Apache XML RPC server or client can lead to deserialization\nvulnerability which would allow an attacker to execute arbitrary code.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.RPC_ENABLED_EXTENSIONS-1","id":"gitlab.find_sec_bugs.RPC_ENABLED_EXTENSIONS-1","name":"gitlab.find_sec_bugs.RPC_ENABLED_EXTENSIONS-1","properties":{"precision":"very-high","tags":["CWE-502","security"]},"shortDescription":{"text":"Deserialization of Untrusted Data"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application is generating an RSA key that is less than the recommended 2048 bits.\nThe National Institute of Standards and Technology (NIST) deprecated signing Digital\nCertificates that contained RSA Public Keys of 1024 bits in December 2010. While\n1024-bit RSA keys have not been factored yet, advances in compute may make it possible\nin the near future.\n\nConsider upgrading to the newer asymmetric algorithm such as `Ed25519` which handles\nthe complexities of generating key pairs and choosing correct key sizes for you:\n```\npublic static KeyPair generateEd25519() throws NoSuchAlgorithmException {\n    // Choose Ed25519 for KeyPairGenerator Instance\n    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\");\n    // Generate a KeyPair and return\n    return keyPairGenerator.generateKeyPair();\n}\n```\n\nOtherwise use a key size greater than 2048 when generating RSA keys:\n```\npublic static KeyPair generateRSA() throws NoSuchAlgorithmException {\n    // Choose RSA for KeyPairGenerator Instance\n    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n    // Initialize with 2048 key size\n    keyPairGenerator.initialize(2048);\n    // Generate a KeyPair and return\n    return keyPairGenerator.generateKeyPair();\n}\n```\n\nFor more information on Ed25519 see: http://ed25519.cr.yp.to/\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"The application is generating an RSA key that is less than the recommended 2048 bits.\nThe National Institute of Standards and Technology (NIST) deprecated signing Digital\nCertificates that contained RSA Public Keys of 1024 bits in December 2010. While\n1024-bit RSA keys have not been factored yet, advances in compute may make it possible\nin the near future.\n\nConsider upgrading to the newer asymmetric algorithm such as `Ed25519` which handles\nthe complexities of generating key pairs and choosing correct key sizes for you:\n```\npublic static KeyPair generateEd25519() throws NoSuchAlgorithmException {\n    // Choose Ed25519 for KeyPairGenerator Instance\n    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\");\n    // Generate a KeyPair and return\n    return keyPairGenerator.generateKeyPair();\n}\n```\n\nOtherwise use a key size greater than 2048 when generating RSA keys:\n```\npublic static KeyPair generateRSA() throws NoSuchAlgorithmException {\n    // Choose RSA for KeyPairGenerator Instance\n    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n    // Initialize with 2048 key size\n    keyPairGenerator.initialize(2048);\n    // Generate a KeyPair and return\n    return keyPairGenerator.generateKeyPair();\n}\n```\n\nFor more information on Ed25519 see: http://ed25519.cr.yp.to/\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.RSA_KEY_SIZE-1)\n","text":"The application is generating an RSA key that is less than the recommended 2048 bits.\nThe National Institute of Standards and Technology (NIST) deprecated signing Digital\nCertificates that contained RSA Public Keys of 1024 bits in December 2010. While\n1024-bit RSA keys have not been factored yet, advances in compute may make it possible\nin the near future.\n\nConsider upgrading to the newer asymmetric algorithm such as `Ed25519` which handles\nthe complexities of generating key pairs and choosing correct key sizes for you:\n```\npublic static KeyPair generateEd25519() throws NoSuchAlgorithmException {\n    // Choose Ed25519 for KeyPairGenerator Instance\n    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\");\n    // Generate a KeyPair and return\n    return keyPairGenerator.generateKeyPair();\n}\n```\n\nOtherwise use a key size greater than 2048 when generating RSA keys:\n```\npublic static KeyPair generateRSA() throws NoSuchAlgorithmException {\n    // Choose RSA for KeyPairGenerator Instance\n    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n    // Initialize with 2048 key size\n    keyPairGenerator.initialize(2048);\n    // Generate a KeyPair and return\n    return keyPairGenerator.generateKeyPair();\n}\n```\n\nFor more information on Ed25519 see: http://ed25519.cr.yp.to/\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.RSA_KEY_SIZE-1","id":"gitlab.find_sec_bugs.RSA_KEY_SIZE-1","name":"gitlab.find_sec_bugs.RSA_KEY_SIZE-1","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The software uses the RSA algorithm but does not incorporate Optimal Asymmetric\nEncryption Padding (OAEP). By not enabling padding, the algorithm maybe vulnerable\nto [chosen plaintext attacks](https://en.wikipedia.org/wiki/Chosen-plaintext_attack).\n\nTo enable OAEP mode, pass `RSA/ECB/OAEPWithSHA-256AndMGF1Padding` to the `Cipher.getInstance`\nmethod.\n\nExample encrypting and decrypting a message using RSA with OAEP:\n```\npublic static void encryptWithRSA() throws InvalidKeyException, NoSuchAlgorithmException,\nNoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {\n    // Generate an RSA Public and Private Key Pair\n    KeyPair keyPair = generateRSAKeys();\n    // Create a Cipher instance using RSA, ECB with OAEP\n    Cipher rsaEncryptor = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n    // Initialize to ENCRYPT_MODE with the public key\n    rsaEncryptor.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n    // Encrypt our secret message\n    byte[] cipherText = rsaEncryptor.doFinal(\"Some secret\nmessage\".getBytes(StandardCharsets.UTF_8));\n\n    // Create a Cipher instance using RSA, ECB with OAEP\n    Cipher rsaDecryptor = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n    // Initialize to DECRYPT_MODE with the private key\n    rsaDecryptor.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n    // Decrypt the secret message\n    byte[] plainText = rsaDecryptor.doFinal(cipherText);\n    // Debug output\n    System.out.println(new String(plainText));\n}\n```\nMore information on Optimal asymmetric encryption padding:\nhttps://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"The software uses the RSA algorithm but does not incorporate Optimal Asymmetric\nEncryption Padding (OAEP). By not enabling padding, the algorithm maybe vulnerable\nto [chosen plaintext attacks](https://en.wikipedia.org/wiki/Chosen-plaintext_attack).\n\nTo enable OAEP mode, pass `RSA/ECB/OAEPWithSHA-256AndMGF1Padding` to the `Cipher.getInstance`\nmethod.\n\nExample encrypting and decrypting a message using RSA with OAEP:\n```\npublic static void encryptWithRSA() throws InvalidKeyException, NoSuchAlgorithmException,\nNoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {\n    // Generate an RSA Public and Private Key Pair\n    KeyPair keyPair = generateRSAKeys();\n    // Create a Cipher instance using RSA, ECB with OAEP\n    Cipher rsaEncryptor = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n    // Initialize to ENCRYPT_MODE with the public key\n    rsaEncryptor.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n    // Encrypt our secret message\n    byte[] cipherText = rsaEncryptor.doFinal(\"Some secret\nmessage\".getBytes(StandardCharsets.UTF_8));\n\n    // Create a Cipher instance using RSA, ECB with OAEP\n    Cipher rsaDecryptor = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n    // Initialize to DECRYPT_MODE with the private key\n    rsaDecryptor.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n    // Decrypt the secret message\n    byte[] plainText = rsaDecryptor.doFinal(cipherText);\n    // Debug output\n    System.out.println(new String(plainText));\n}\n```\nMore information on Optimal asymmetric encryption padding:\nhttps://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.RSA_NO_PADDING-1)\n","text":"The software uses the RSA algorithm but does not incorporate Optimal Asymmetric\nEncryption Padding (OAEP). By not enabling padding, the algorithm maybe vulnerable\nto [chosen plaintext attacks](https://en.wikipedia.org/wiki/Chosen-plaintext_attack).\n\nTo enable OAEP mode, pass `RSA/ECB/OAEPWithSHA-256AndMGF1Padding` to the `Cipher.getInstance`\nmethod.\n\nExample encrypting and decrypting a message using RSA with OAEP:\n```\npublic static void encryptWithRSA() throws InvalidKeyException, NoSuchAlgorithmException,\nNoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {\n    // Generate an RSA Public and Private Key Pair\n    KeyPair keyPair = generateRSAKeys();\n    // Create a Cipher instance using RSA, ECB with OAEP\n    Cipher rsaEncryptor = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n    // Initialize to ENCRYPT_MODE with the public key\n    rsaEncryptor.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n    // Encrypt our secret message\n    byte[] cipherText = rsaEncryptor.doFinal(\"Some secret\nmessage\".getBytes(StandardCharsets.UTF_8));\n\n    // Create a Cipher instance using RSA, ECB with OAEP\n    Cipher rsaDecryptor = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n    // Initialize to DECRYPT_MODE with the private key\n    rsaDecryptor.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n    // Decrypt the secret message\n    byte[] plainText = rsaDecryptor.doFinal(cipherText);\n    // Debug output\n    System.out.println(new String(plainText));\n}\n```\nMore information on Optimal asymmetric encryption padding:\nhttps://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.RSA_NO_PADDING-1","id":"gitlab.find_sec_bugs.RSA_NO_PADDING-1","name":"gitlab.find_sec_bugs.RSA_NO_PADDING-1","properties":{"precision":"very-high","tags":["CWE-780","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of RSA algorithm without OAEP"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"SAML parses attestations as an XML document. By processing XML comments, comment\nfields can end up modifying the interpretation of input fields. This could allow\nan adversary to insert an XML comment to break up the attestation's username\nor other fields, allowing an attacker to bypass authorization or authentication checks.\n\nTo remediate this issue, when using `org.opensaml.xml.parse.BasicParserPool` ensure\n`setIgnoreComments(false)` is not called.\n\nThe default value of `ignoreComments` is true, which is safe. \n\nRef:\n- https://javadoc.io/doc/org.opensaml/xmltooling/latest/org/opensaml/xml/parse/BasicParserPool.html#ignoreComments\n\nFor more information on how this issue can be exploited see:\nhttps://developer.okta.com/blog/2018/02/27/a-breakdown-of-the-new-saml-authentication-bypass-vulnerability\n\nFor more information on SAML security see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html\n"},"help":{"markdown":"SAML parses attestations as an XML document. By processing XML comments, comment\nfields can end up modifying the interpretation of input fields. This could allow\nan adversary to insert an XML comment to break up the attestation's username\nor other fields, allowing an attacker to bypass authorization or authentication checks.\n\nTo remediate this issue, when using `org.opensaml.xml.parse.BasicParserPool` ensure\n`setIgnoreComments(false)` is not called.\n\nThe default value of `ignoreComments` is true, which is safe. \n\nRef:\n- https://javadoc.io/doc/org.opensaml/xmltooling/latest/org/opensaml/xml/parse/BasicParserPool.html#ignoreComments\n\nFor more information on how this issue can be exploited see:\nhttps://developer.okta.com/blog/2018/02/27/a-breakdown-of-the-new-saml-authentication-bypass-vulnerability\n\nFor more information on SAML security see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SAML_IGNORE_COMMENTS-1)\n","text":"SAML parses attestations as an XML document. By processing XML comments, comment\nfields can end up modifying the interpretation of input fields. This could allow\nan adversary to insert an XML comment to break up the attestation's username\nor other fields, allowing an attacker to bypass authorization or authentication checks.\n\nTo remediate this issue, when using `org.opensaml.xml.parse.BasicParserPool` ensure\n`setIgnoreComments(false)` is not called.\n\nThe default value of `ignoreComments` is true, which is safe. \n\nRef:\n- https://javadoc.io/doc/org.opensaml/xmltooling/latest/org/opensaml/xml/parse/BasicParserPool.html#ignoreComments\n\nFor more information on how this issue can be exploited see:\nhttps://developer.okta.com/blog/2018/02/27/a-breakdown-of-the-new-saml-authentication-bypass-vulnerability\n\nFor more information on SAML security see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SAML_IGNORE_COMMENTS-1","id":"gitlab.find_sec_bugs.SAML_IGNORE_COMMENTS-1","name":"gitlab.find_sec_bugs.SAML_IGNORE_COMMENTS-1","properties":{"precision":"very-high","tags":["CWE-287","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper authentication"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application executes an argument using a `ScriptEngine`'s `eval` method. This\nmay allow for direct OS commands to be executed as it's possible to pass in strings\nsuch as `java.lang.Runtime.getRuntime().exec('/bin/sh ...');`.\n\nNever pass user-supplied input directly to the `eval` function. If possible hardcode all\nJavasScript code or use a lookup table to resolve user input to known values. If none of these\ntechniques are possible, use `javax.script.Bindings` to pass input to the script engine.\n\nExample using `Binding` to safely pass in string values:\n```\n// Get ECMAScript engine\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\"ECMAScript\");\n\n// User input, consisting of first and last name\nString userFirstName = \"John\";\nString userLastName = \"Snow\";\n\n// Create bindings to pass into our script, forcing the values to be String.\nBindings bindings = engine.createBindings();\nbindings.put(\"fname\", new String(userFirstName));\nbindings.put(\"lname\", new String(userLastName));\n\n// Example script that concatenates a greeting with the user-supplied input first/last name\nString script = \"var greeting='Hello ';\" +\n// fname and lname variables will be resolved by our bindings defined above\n\"greeting += fname + ' ' + lname;\" +\n// prints greeting\n\"greeting\";\n\ntry {\n  // Execute the script, passing in the bindings\n  Object bindingsResult = engine.eval(script, bindings);\n  // Work with result\n  // ...\n} catch (ScriptException e) {\n  // Handle exception\n  e.printStackTrace();\n}\n```\n"},"help":{"markdown":"The application executes an argument using a `ScriptEngine`'s `eval` method. This\nmay allow for direct OS commands to be executed as it's possible to pass in strings\nsuch as `java.lang.Runtime.getRuntime().exec('/bin/sh ...');`.\n\nNever pass user-supplied input directly to the `eval` function. If possible hardcode all\nJavasScript code or use a lookup table to resolve user input to known values. If none of these\ntechniques are possible, use `javax.script.Bindings` to pass input to the script engine.\n\nExample using `Binding` to safely pass in string values:\n```\n// Get ECMAScript engine\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\"ECMAScript\");\n\n// User input, consisting of first and last name\nString userFirstName = \"John\";\nString userLastName = \"Snow\";\n\n// Create bindings to pass into our script, forcing the values to be String.\nBindings bindings = engine.createBindings();\nbindings.put(\"fname\", new String(userFirstName));\nbindings.put(\"lname\", new String(userLastName));\n\n// Example script that concatenates a greeting with the user-supplied input first/last name\nString script = \"var greeting='Hello ';\" +\n// fname and lname variables will be resolved by our bindings defined above\n\"greeting += fname + ' ' + lname;\" +\n// prints greeting\n\"greeting\";\n\ntry {\n  // Execute the script, passing in the bindings\n  Object bindingsResult = engine.eval(script, bindings);\n  // Work with result\n  // ...\n} catch (ScriptException e) {\n  // Handle exception\n  e.printStackTrace();\n}\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1)\n","text":"The application executes an argument using a `ScriptEngine`'s `eval` method. This\nmay allow for direct OS commands to be executed as it's possible to pass in strings\nsuch as `java.lang.Runtime.getRuntime().exec('/bin/sh ...');`.\n\nNever pass user-supplied input directly to the `eval` function. If possible hardcode all\nJavasScript code or use a lookup table to resolve user input to known values. If none of these\ntechniques are possible, use `javax.script.Bindings` to pass input to the script engine.\n\nExample using `Binding` to safely pass in string values:\n```\n// Get ECMAScript engine\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\"ECMAScript\");\n\n// User input, consisting of first and last name\nString userFirstName = \"John\";\nString userLastName = \"Snow\";\n\n// Create bindings to pass into our script, forcing the values to be String.\nBindings bindings = engine.createBindings();\nbindings.put(\"fname\", new String(userFirstName));\nbindings.put(\"lname\", new String(userLastName));\n\n// Example script that concatenates a greeting with the user-supplied input first/last name\nString script = \"var greeting='Hello ';\" +\n// fname and lname variables will be resolved by our bindings defined above\n\"greeting += fname + ' ' + lname;\" +\n// prints greeting\n\"greeting\";\n\ntry {\n  // Execute the script, passing in the bindings\n  Object bindingsResult = engine.eval(script, bindings);\n  // Work with result\n  // ...\n} catch (ScriptException e) {\n  // Handle exception\n  e.printStackTrace();\n}\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1","id":"gitlab.find_sec_bugs.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1","name":"gitlab.find_sec_bugs.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-94","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"High"},"shortDescription":{"text":"Improper control of generation of code ('Code Injection')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application was found calling SpringFramework's `SpelExpressionParser.parseExpression`.\nCalling this method directly with user-supplied input may allow an adversary to\nexecute arbitrary Java code including OS system commands.\n\nNever call `parseExpression` or `parseRaw` directly with user-supplied input. Consider\nalternate\nmethods such as a lookup table to take user input and resolve hardcoded values.\n\nLater versions of SpringFramework introduced a `SimpleEvaluationContext` which can be\nused to access bound data when calling the `getValue` result of `parseExpression`. This\n`SimpleEvaluationContext` has a reduced set of functionality and can restrict data binding\nto read-only or read-write contexts. An adversary could still access public properties\nor fields on custom types that have been provided to the evaluation context. Use with caution.\n\nExample using `SimpleEvaluationContext` with a read-write data binding context:\n```\n@RequestMapping(value=\"/spel\", method=RequestMethod.POST)\npublic String spel(@Validated User user, Model model)  {\n  // Create the Expression Parser\n  SpelExpressionParser parser = new SpelExpressionParser();\n  // Parse the expression\n  Expression parsedExpression = parser.parseExpression(model.getPossiblyUnsafeData());\n  // Create the read-write data binding context\n  SimpleEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n  // Execute the expression, passing in the read-write context\n  Object result = parsedExpression.getValue(context);\n  // work with the result\n  // ...\n  return \"user\";\n}\n```\n\nFor more information on SimpleEvaluationContext see:\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html\n"},"help":{"markdown":"The application was found calling SpringFramework's `SpelExpressionParser.parseExpression`.\nCalling this method directly with user-supplied input may allow an adversary to\nexecute arbitrary Java code including OS system commands.\n\nNever call `parseExpression` or `parseRaw` directly with user-supplied input. Consider\nalternate\nmethods such as a lookup table to take user input and resolve hardcoded values.\n\nLater versions of SpringFramework introduced a `SimpleEvaluationContext` which can be\nused to access bound data when calling the `getValue` result of `parseExpression`. This\n`SimpleEvaluationContext` has a reduced set of functionality and can restrict data binding\nto read-only or read-write contexts. An adversary could still access public properties\nor fields on custom types that have been provided to the evaluation context. Use with caution.\n\nExample using `SimpleEvaluationContext` with a read-write data binding context:\n```\n@RequestMapping(value=\"/spel\", method=RequestMethod.POST)\npublic String spel(@Validated User user, Model model)  {\n  // Create the Expression Parser\n  SpelExpressionParser parser = new SpelExpressionParser();\n  // Parse the expression\n  Expression parsedExpression = parser.parseExpression(model.getPossiblyUnsafeData());\n  // Create the read-write data binding context\n  SimpleEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n  // Execute the expression, passing in the read-write context\n  Object result = parsedExpression.getValue(context);\n  // work with the result\n  // ...\n  return \"user\";\n}\n```\n\nFor more information on SimpleEvaluationContext see:\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SCRIPT_ENGINE_INJECTION-2)\n","text":"The application was found calling SpringFramework's `SpelExpressionParser.parseExpression`.\nCalling this method directly with user-supplied input may allow an adversary to\nexecute arbitrary Java code including OS system commands.\n\nNever call `parseExpression` or `parseRaw` directly with user-supplied input. Consider\nalternate\nmethods such as a lookup table to take user input and resolve hardcoded values.\n\nLater versions of SpringFramework introduced a `SimpleEvaluationContext` which can be\nused to access bound data when calling the `getValue` result of `parseExpression`. This\n`SimpleEvaluationContext` has a reduced set of functionality and can restrict data binding\nto read-only or read-write contexts. An adversary could still access public properties\nor fields on custom types that have been provided to the evaluation context. Use with caution.\n\nExample using `SimpleEvaluationContext` with a read-write data binding context:\n```\n@RequestMapping(value=\"/spel\", method=RequestMethod.POST)\npublic String spel(@Validated User user, Model model)  {\n  // Create the Expression Parser\n  SpelExpressionParser parser = new SpelExpressionParser();\n  // Parse the expression\n  Expression parsedExpression = parser.parseExpression(model.getPossiblyUnsafeData());\n  // Create the read-write data binding context\n  SimpleEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n  // Execute the expression, passing in the read-write context\n  Object result = parsedExpression.getValue(context);\n  // work with the result\n  // ...\n  return \"user\";\n}\n```\n\nFor more information on SimpleEvaluationContext see:\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SCRIPT_ENGINE_INJECTION-2","id":"gitlab.find_sec_bugs.SCRIPT_ENGINE_INJECTION-2","name":"gitlab.find_sec_bugs.SCRIPT_ENGINE_INJECTION-2","properties":{"precision":"very-high","tags":["CWE-917","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"High"},"shortDescription":{"text":"Improper neutralization of special elements used in an expression language statement ('Expression Language Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The Servlet can read GET and POST parameters from various methods. The\nvalue obtained should be considered unsafe.\"\n"},"help":{"markdown":"The Servlet can read GET and POST parameters from various methods. The\nvalue obtained should be considered unsafe.\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1)\n","text":"The Servlet can read GET and POST parameters from various methods. The\nvalue obtained should be considered unsafe.\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1","id":"gitlab.find_sec_bugs.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1","name":"gitlab.find_sec_bugs.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1","properties":{"precision":"very-high","tags":["CWE-20","security"]},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application was found calling `MimeMessage` methods without encoding\nnew line characters. Much like HTTP, Simple Mail Transfer Protocol (SMTP) is a\ntext based protocol that uses headers to convey additional directives for how\nemail messages should be treated. An adversary could potentially cause email\nmessages to be sent to unintended recipients by abusing the CC or BCC headers\nif they were able to inject them.\n\nTo mitigate this issue, `\\r\\n` (CRLF) character sequences must be escaped\nor encoded prior to being used in any of the `MimeMessage` methods.\n\nExample that escapes values that come from user input with\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/):\n```\n// Create a MimeMessage with a javax.mail.Session\nMessage message = new MimeMessage(session);\n// Set the from address\nmessage.setFrom(new InternetAddress(\"source@example.com\"));\n// Set the to address\nmessage.setRecipients(Message.RecipientType.TO,new InternetAddress[] {new\nInternetAddress(\"destination@example.com\")});\n// Example user input\nString subject = \"potentially malicious data\";\nString headerValue = \"potentially malicious data\";\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.setSubject(StringEscapeUtils.escapeJava(subject));\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.addHeader(\"HeaderName\", StringEscapeUtils.escapeJava(header));\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.setDescription(StringEscapeUtils.escapeJava(\"some description\"));\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.setDisposition(StringEscapeUtils.escapeJava(\"some disposition\"));\n// Set the mail body text\nmessage.setText(\"Some email content.\");\n// Send the message\n```\n"},"help":{"markdown":"The application was found calling `MimeMessage` methods without encoding\nnew line characters. Much like HTTP, Simple Mail Transfer Protocol (SMTP) is a\ntext based protocol that uses headers to convey additional directives for how\nemail messages should be treated. An adversary could potentially cause email\nmessages to be sent to unintended recipients by abusing the CC or BCC headers\nif they were able to inject them.\n\nTo mitigate this issue, `\\r\\n` (CRLF) character sequences must be escaped\nor encoded prior to being used in any of the `MimeMessage` methods.\n\nExample that escapes values that come from user input with\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/):\n```\n// Create a MimeMessage with a javax.mail.Session\nMessage message = new MimeMessage(session);\n// Set the from address\nmessage.setFrom(new InternetAddress(\"source@example.com\"));\n// Set the to address\nmessage.setRecipients(Message.RecipientType.TO,new InternetAddress[] {new\nInternetAddress(\"destination@example.com\")});\n// Example user input\nString subject = \"potentially malicious data\";\nString headerValue = \"potentially malicious data\";\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.setSubject(StringEscapeUtils.escapeJava(subject));\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.addHeader(\"HeaderName\", StringEscapeUtils.escapeJava(header));\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.setDescription(StringEscapeUtils.escapeJava(\"some description\"));\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.setDisposition(StringEscapeUtils.escapeJava(\"some disposition\"));\n// Set the mail body text\nmessage.setText(\"Some email content.\");\n// Send the message\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SMTP_HEADER_INJECTION-1)\n","text":"The application was found calling `MimeMessage` methods without encoding\nnew line characters. Much like HTTP, Simple Mail Transfer Protocol (SMTP) is a\ntext based protocol that uses headers to convey additional directives for how\nemail messages should be treated. An adversary could potentially cause email\nmessages to be sent to unintended recipients by abusing the CC or BCC headers\nif they were able to inject them.\n\nTo mitigate this issue, `\\r\\n` (CRLF) character sequences must be escaped\nor encoded prior to being used in any of the `MimeMessage` methods.\n\nExample that escapes values that come from user input with\n[Apache Commons Text](https://commons.apache.org/proper/commons-text/):\n```\n// Create a MimeMessage with a javax.mail.Session\nMessage message = new MimeMessage(session);\n// Set the from address\nmessage.setFrom(new InternetAddress(\"source@example.com\"));\n// Set the to address\nmessage.setRecipients(Message.RecipientType.TO,new InternetAddress[] {new\nInternetAddress(\"destination@example.com\")});\n// Example user input\nString subject = \"potentially malicious data\";\nString headerValue = \"potentially malicious data\";\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.setSubject(StringEscapeUtils.escapeJava(subject));\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.addHeader(\"HeaderName\", StringEscapeUtils.escapeJava(header));\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.setDescription(StringEscapeUtils.escapeJava(\"some description\"));\n// Use Apache Commons Text StringEscapeUtils.escapeJava to encode \\r\\n to \\\\r\\\\n.\nmessage.setDisposition(StringEscapeUtils.escapeJava(\"some disposition\"));\n// Set the mail body text\nmessage.setText(\"Some email content.\");\n// Send the message\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SMTP_HEADER_INJECTION-1","id":"gitlab.find_sec_bugs.SMTP_HEADER_INJECTION-1","name":"gitlab.find_sec_bugs.SMTP_HEADER_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-77","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Low"},"shortDescription":{"text":"Improper neutralization of special elements used in a command"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application fails to protect against Cross-Site Request Forgery (CSRF)\ndue to disabling Spring's CSRF protection features.\n\nThe vulnerability can be exploited by an adversary creating a link or form on a third\nparty site and tricking an authenticated victim to access them.\n\nTo remediate this issue, remove the call to `HttpSecurity.csrf().disable()` or remove\nthe custom `CsrfConfigurer`.\n\nFor more information on CSRF protection in Spring see:\nhttps://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#servlet-csrf\n\nAdditionally, consider setting all session cookies to have the `SameSite=Strict` attribute.\nIt should be noted that this may impact usability when sharing links across other mediums.\nIt is recommended that a two cookie based approach is taken, as outlined in the\n[Top level\nnavigations](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-08#section-8.8.2)\nsection\nof the SameSite RFC.\n\nFor more information on CSRF see OWASP's guide:\nhttps://owasp.org/www-community/attacks/csrf\n"},"help":{"markdown":"The application fails to protect against Cross-Site Request Forgery (CSRF)\ndue to disabling Spring's CSRF protection features.\n\nThe vulnerability can be exploited by an adversary creating a link or form on a third\nparty site and tricking an authenticated victim to access them.\n\nTo remediate this issue, remove the call to `HttpSecurity.csrf().disable()` or remove\nthe custom `CsrfConfigurer`.\n\nFor more information on CSRF protection in Spring see:\nhttps://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#servlet-csrf\n\nAdditionally, consider setting all session cookies to have the `SameSite=Strict` attribute.\nIt should be noted that this may impact usability when sharing links across other mediums.\nIt is recommended that a two cookie based approach is taken, as outlined in the\n[Top level\nnavigations](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-08#section-8.8.2)\nsection\nof the SameSite RFC.\n\nFor more information on CSRF see OWASP's guide:\nhttps://owasp.org/www-community/attacks/csrf\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SPRING_CSRF_PROTECTION_DISABLED-1)\n","text":"The application fails to protect against Cross-Site Request Forgery (CSRF)\ndue to disabling Spring's CSRF protection features.\n\nThe vulnerability can be exploited by an adversary creating a link or form on a third\nparty site and tricking an authenticated victim to access them.\n\nTo remediate this issue, remove the call to `HttpSecurity.csrf().disable()` or remove\nthe custom `CsrfConfigurer`.\n\nFor more information on CSRF protection in Spring see:\nhttps://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#servlet-csrf\n\nAdditionally, consider setting all session cookies to have the `SameSite=Strict` attribute.\nIt should be noted that this may impact usability when sharing links across other mediums.\nIt is recommended that a two cookie based approach is taken, as outlined in the\n[Top level\nnavigations](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-08#section-8.8.2)\nsection\nof the SameSite RFC.\n\nFor more information on CSRF see OWASP's guide:\nhttps://owasp.org/www-community/attacks/csrf\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SPRING_CSRF_PROTECTION_DISABLED-1","id":"gitlab.find_sec_bugs.SPRING_CSRF_PROTECTION_DISABLED-1","name":"gitlab.find_sec_bugs.SPRING_CSRF_PROTECTION_DISABLED-1","properties":{"precision":"very-high","tags":["CWE-352","security"]},"shortDescription":{"text":"Cross-Site Request Forgery (CSRF)"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The `org.springframework.web.servlet.ModelAndView` class may\npotentially allow access to restricted files if called with user-supplied input.\n\nThe ModelAndView class looks up a view by name to resolve a `.jsp`\nfile. If this view name comes from user-supplied input, it could be abused to attempt\nto return a JSP view that the user should not have access to.\n\nUse a lookup table or hardcode which views or paths the user should be directed to.\n\nExample using a lookup table to resolve a view from a Spring MVC application:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n {\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up view from the user input\n  String viewValue = lookupTable.getOrDefault(userInput, \"Resource1\");\n  // return the new model and view\n  return new ModelAndView(viewValue);\n}\n```\n\nExample using a redirect instead of a `RequestDispatcher` in Spring:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic void mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n {\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up resource to redirect to from the user input\n  String redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n  // return the new model and view\n  response.sendRedirect(redirectValue);\n}\n```\n"},"help":{"markdown":"The `org.springframework.web.servlet.ModelAndView` class may\npotentially allow access to restricted files if called with user-supplied input.\n\nThe ModelAndView class looks up a view by name to resolve a `.jsp`\nfile. If this view name comes from user-supplied input, it could be abused to attempt\nto return a JSP view that the user should not have access to.\n\nUse a lookup table or hardcode which views or paths the user should be directed to.\n\nExample using a lookup table to resolve a view from a Spring MVC application:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n {\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up view from the user input\n  String viewValue = lookupTable.getOrDefault(userInput, \"Resource1\");\n  // return the new model and view\n  return new ModelAndView(viewValue);\n}\n```\n\nExample using a redirect instead of a `RequestDispatcher` in Spring:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic void mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n {\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up resource to redirect to from the user input\n  String redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n  // return the new model and view\n  response.sendRedirect(redirectValue);\n}\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SPRING_FILE_DISCLOSURE-1)\n","text":"The `org.springframework.web.servlet.ModelAndView` class may\npotentially allow access to restricted files if called with user-supplied input.\n\nThe ModelAndView class looks up a view by name to resolve a `.jsp`\nfile. If this view name comes from user-supplied input, it could be abused to attempt\nto return a JSP view that the user should not have access to.\n\nUse a lookup table or hardcode which views or paths the user should be directed to.\n\nExample using a lookup table to resolve a view from a Spring MVC application:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n {\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up view from the user input\n  String viewValue = lookupTable.getOrDefault(userInput, \"Resource1\");\n  // return the new model and view\n  return new ModelAndView(viewValue);\n}\n```\n\nExample using a redirect instead of a `RequestDispatcher` in Spring:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic void mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n {\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up resource to redirect to from the user input\n  String redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n  // return the new model and view\n  response.sendRedirect(redirectValue);\n}\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SPRING_FILE_DISCLOSURE-1","id":"gitlab.find_sec_bugs.SPRING_FILE_DISCLOSURE-1","name":"gitlab.find_sec_bugs.SPRING_FILE_DISCLOSURE-1","properties":{"precision":"very-high","tags":["CWE-552","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"HIGH"},"shortDescription":{"text":"Files or directories accessible to external parties"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"help":{"markdown":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1)\n","text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1","id":"gitlab.find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1","name":"gitlab.find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1","properties":{"precision":"very-high","tags":["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')","security"]},"shortDescription":{"text":"Semgrep Finding: gitlab.find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `>` or `<` comparison\noperators. In these cases, do not use a user supplied `>` or `<` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n"},"help":{"markdown":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `>` or `<` comparison\noperators. In these cases, do not use a user supplied `>` or `<` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1)\n","text":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `>` or `<` comparison\noperators. In these cases, do not use a user supplied `>` or `<` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1","id":"gitlab.find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1","name":"gitlab.find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1","properties":{"precision":"very-high","tags":["CWE-89","security"]},"shortDescription":{"text":"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Avoid initializing SSLContext with insecure protocols like `SSL`, `SSLv2`, or `SSLv3`.\nThese protocols are outdated and do not validate certificates by default. Additionally,\nthese older `SSL` versions have many known security issues.\n\nInstead, use secure protocols like `TLSv1.2` or `TLSv1.3`.\n```\nSSLContext context = SSLContext.getInstance(\"TLSv1.3\");\n```\nFor more information on see OWASP:\n   - https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/01-Testing_for_Weak_SSL_TLS_Ciphers_Insufficient_Transport_Layer_Protection\n"},"help":{"markdown":"Avoid initializing SSLContext with insecure protocols like `SSL`, `SSLv2`, or `SSLv3`.\nThese protocols are outdated and do not validate certificates by default. Additionally,\nthese older `SSL` versions have many known security issues.\n\nInstead, use secure protocols like `TLSv1.2` or `TLSv1.3`.\n```\nSSLContext context = SSLContext.getInstance(\"TLSv1.3\");\n```\nFor more information on see OWASP:\n   - https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/01-Testing_for_Weak_SSL_TLS_Ciphers_Insufficient_Transport_Layer_Protection\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SSL_CONTEXT-1)\n","text":"Avoid initializing SSLContext with insecure protocols like `SSL`, `SSLv2`, or `SSLv3`.\nThese protocols are outdated and do not validate certificates by default. Additionally,\nthese older `SSL` versions have many known security issues.\n\nInstead, use secure protocols like `TLSv1.2` or `TLSv1.3`.\n```\nSSLContext context = SSLContext.getInstance(\"TLSv1.3\");\n```\nFor more information on see OWASP:\n   - https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/01-Testing_for_Weak_SSL_TLS_Ciphers_Insufficient_Transport_Layer_Protection\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SSL_CONTEXT-1","id":"gitlab.find_sec_bugs.SSL_CONTEXT-1","name":"gitlab.find_sec_bugs.SSL_CONTEXT-1","properties":{"precision":"very-high","tags":["CWE-295","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper certificate validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found enabling insecure TLS protocol versions. When enabling protocol\nversions for an `SSLContext`, only the following versions should be allowed:\n- TLSv1.2\n- TLSv1.3\n- DTLSv1.2\n- DTLSv1.3\n\nTo mitigate potential security risks, it is strongly advised to enforce TLS 1.2 as the minimum\nprotocol version and disallow older versions such as TLS 1.0. Do note that newer versions of\nJava do not even support TLS 1.0 and will throw `NoSuchAlgorithmException`. Versions of TLS\nprior to 1.2 could expose the connection to downgrade attacks, where an adversary intercepts\nthe\nconnection and alters the requested protocol version to be a less secure one.\n\nIn many scenarios, relying on the default system configuration does not meet compliance\nstandards. This is due to the application being deployed across diverse systems with varying\nconfigurations and Java versions. While the default value may be secure on modern and\nup-to-date systems, it may not hold true for older systems. Consequently, it is highly\nrecommended to explicitly define a secure configuration in all cases.\n\nExample configuring an SSLContext with TLSv1.2:\n```\n// Create an SSLContext with TLSv1.2 explicitly\nSSLContext tlsContext = SSLContext.getInstance(\"TLSv1.2\"); // or TLSv1.3, DTLSv1.2, DTLSv1.3\n\n// Alternatively, set the enabled protocols\nSSLContext serverSslContext = SSLContext.getInstance(\"TLS\");\nSSLEngine serverEngine = serverSslContext.createSSLEngine();\n// Calling setEnabledProtocols will override the original context's configured protocol version\nserverEngine.setEnabledProtocols(new String[]{ \"TLSv1.2\" });\n```\n\nFor more information on `SSLContext` see:\n- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html\n\nFor more information on MiTM attacks see:\n- https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack\n"},"help":{"markdown":"The application was found enabling insecure TLS protocol versions. When enabling protocol\nversions for an `SSLContext`, only the following versions should be allowed:\n- TLSv1.2\n- TLSv1.3\n- DTLSv1.2\n- DTLSv1.3\n\nTo mitigate potential security risks, it is strongly advised to enforce TLS 1.2 as the minimum\nprotocol version and disallow older versions such as TLS 1.0. Do note that newer versions of\nJava do not even support TLS 1.0 and will throw `NoSuchAlgorithmException`. Versions of TLS\nprior to 1.2 could expose the connection to downgrade attacks, where an adversary intercepts\nthe\nconnection and alters the requested protocol version to be a less secure one.\n\nIn many scenarios, relying on the default system configuration does not meet compliance\nstandards. This is due to the application being deployed across diverse systems with varying\nconfigurations and Java versions. While the default value may be secure on modern and\nup-to-date systems, it may not hold true for older systems. Consequently, it is highly\nrecommended to explicitly define a secure configuration in all cases.\n\nExample configuring an SSLContext with TLSv1.2:\n```\n// Create an SSLContext with TLSv1.2 explicitly\nSSLContext tlsContext = SSLContext.getInstance(\"TLSv1.2\"); // or TLSv1.3, DTLSv1.2, DTLSv1.3\n\n// Alternatively, set the enabled protocols\nSSLContext serverSslContext = SSLContext.getInstance(\"TLS\");\nSSLEngine serverEngine = serverSslContext.createSSLEngine();\n// Calling setEnabledProtocols will override the original context's configured protocol version\nserverEngine.setEnabledProtocols(new String[]{ \"TLSv1.2\" });\n```\n\nFor more information on `SSLContext` see:\n- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html\n\nFor more information on MiTM attacks see:\n- https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.SSL_CONTEXT-2)\n","text":"The application was found enabling insecure TLS protocol versions. When enabling protocol\nversions for an `SSLContext`, only the following versions should be allowed:\n- TLSv1.2\n- TLSv1.3\n- DTLSv1.2\n- DTLSv1.3\n\nTo mitigate potential security risks, it is strongly advised to enforce TLS 1.2 as the minimum\nprotocol version and disallow older versions such as TLS 1.0. Do note that newer versions of\nJava do not even support TLS 1.0 and will throw `NoSuchAlgorithmException`. Versions of TLS\nprior to 1.2 could expose the connection to downgrade attacks, where an adversary intercepts\nthe\nconnection and alters the requested protocol version to be a less secure one.\n\nIn many scenarios, relying on the default system configuration does not meet compliance\nstandards. This is due to the application being deployed across diverse systems with varying\nconfigurations and Java versions. While the default value may be secure on modern and\nup-to-date systems, it may not hold true for older systems. Consequently, it is highly\nrecommended to explicitly define a secure configuration in all cases.\n\nExample configuring an SSLContext with TLSv1.2:\n```\n// Create an SSLContext with TLSv1.2 explicitly\nSSLContext tlsContext = SSLContext.getInstance(\"TLSv1.2\"); // or TLSv1.3, DTLSv1.2, DTLSv1.3\n\n// Alternatively, set the enabled protocols\nSSLContext serverSslContext = SSLContext.getInstance(\"TLS\");\nSSLEngine serverEngine = serverSslContext.createSSLEngine();\n// Calling setEnabledProtocols will override the original context's configured protocol version\nserverEngine.setEnabledProtocols(new String[]{ \"TLSv1.2\" });\n```\n\nFor more information on `SSLContext` see:\n- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html\n\nFor more information on MiTM attacks see:\n- https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.SSL_CONTEXT-2","id":"gitlab.find_sec_bugs.SSL_CONTEXT-2","name":"gitlab.find_sec_bugs.SSL_CONTEXT-2","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Form inputs should have minimal input validation. Preventive validation helps\nprovide defense in depth against a variety of risks.\n"},"help":{"markdown":"Form inputs should have minimal input validation. Preventive validation helps\nprovide defense in depth against a variety of risks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.STRUTS_FORM_VALIDATION-1)\n","text":"Form inputs should have minimal input validation. Preventive validation helps\nprovide defense in depth against a variety of risks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.STRUTS_FORM_VALIDATION-1","id":"gitlab.find_sec_bugs.STRUTS_FORM_VALIDATION-1","name":"gitlab.find_sec_bugs.STRUTS_FORM_VALIDATION-1","properties":{"precision":"very-high","tags":["CWE-20","security"]},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.\nNewer algorithms  apply message integrity to validate ciphertext has not been tampered\nwith. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the\nalternatives such as `AES-256-GCM`.\n\nFor older applications that don't have support for `ChaCha20Poly1305`,\n`AES-256-GCM` is recommended, however it has many drawbacks:\n- Slower than `ChaCha20Poly1305`.\n- Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] nonceKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our nonceKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(nonceKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV nonceKey\n    byte[] nonceKey = new byte[12];\n    random.nextBytes(nonceKey);\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, nonceKey, secretKey);\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n    // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, nonceKey, secretKey);\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"help":{"markdown":"DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.\nNewer algorithms  apply message integrity to validate ciphertext has not been tampered\nwith. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the\nalternatives such as `AES-256-GCM`.\n\nFor older applications that don't have support for `ChaCha20Poly1305`,\n`AES-256-GCM` is recommended, however it has many drawbacks:\n- Slower than `ChaCha20Poly1305`.\n- Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] nonceKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our nonceKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(nonceKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV nonceKey\n    byte[] nonceKey = new byte[12];\n    random.nextBytes(nonceKey);\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, nonceKey, secretKey);\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n    // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, nonceKey, secretKey);\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.TDES_USAGE-1)\n","text":"DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.\nNewer algorithms  apply message integrity to validate ciphertext has not been tampered\nwith. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the\nalternatives such as `AES-256-GCM`.\n\nFor older applications that don't have support for `ChaCha20Poly1305`,\n`AES-256-GCM` is recommended, however it has many drawbacks:\n- Slower than `ChaCha20Poly1305`.\n- Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n```\npublic encrypt() throws Exception {\n    chaChaEncryption(\"Secret text to encrypt\".getBytes(StandardCharsets.UTF_8));\n}\n\npublic SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {\n    // Use DRBG according to\nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\n    return SecureRandom.getInstance(\"DRBG\",\n            // Security strength in bits (default is 128)\n            DrbgParameters.instantiation(256,\n                // Set prediction resistance and re-seeding\n                DrbgParameters.Capability.PR_AND_RESEED,\n                // Set the personalization string (optional, not necessary)\n                \"some_personalization_string\".getBytes()\n            )\n    );\n}\n\npublic Cipher getChaCha20Poly1305(int mode, byte[] nonceKey, byte[] secretKey) throws\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\nInvalidAlgorithmParameterException  {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create a ChaCha20-Poly1305 cipher instance\n    Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n    // Create our parameterSpec using our nonceKey\n    AlgorithmParameterSpec parameterSpec = new IvParameterSpec(nonceKey);\n    // Create a SecretKeySpec using our secretKey\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, \"ChaCha20\");\n    // Initialize and return the cipher for the provided mode\n    chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);\n    return chaChaCipher;\n}\n\npublic void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    // Get a DRBG random number generator instance\n    SecureRandom random = getSecureRandomDRBG();\n    // Create secretKey\n    byte[] secretKey = new byte[32];\n    random.nextBytes(secretKey);\n    // Create an IV nonceKey\n    byte[] nonceKey = new byte[12];\n    random.nextBytes(nonceKey);\n    // Create a chaCha encryption cipher instance\n    Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, nonceKey, secretKey);\n    // Encrypt the text using ChaCha20Poly1305\n    byte[] cipherText = null;\n    try {\n        cipherText = chaChaEncryptor.doFinal(plainText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to encrypt text\");\n        return;\n    }\n    System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(cipherText));\n    // Create a chaCha decryption cipher instance\n    Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, nonceKey, secretKey);\n    // Decrypt the text\n    byte[] decryptedText = null;\n    try {\n        decryptedText = chaChaDecryptor.doFinal(cipherText);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        System.out.println(\"failed to decrypt text\");\n        return;\n    }\n    System.out.println(\"decrypted: \" + new String(decryptedText, StandardCharsets.UTF_8));\n}\n```\n\nFor more information on Java Cryptography see:\nhttps://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.TDES_USAGE-1","id":"gitlab.find_sec_bugs.TDES_USAGE-1","name":"gitlab.find_sec_bugs.TDES_USAGE-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application may allow control over a template string. Providing user input directly in the\ntemplate by\ndynamically creating template strings may allow an adversary to execute arbitrary Java code,\nincluding\nOS system commands.\n\nFor Velocity, never call `evaluate` with user-supplied input in the template string. Use a\n`VelocityContext`\nobject instead to data-bind user-supplied information as it will be treated as an underlying\ndata type and not\ntemplate code.\n\nExample using Apache Velocity's `VelocityContext` and escape tools to pass in user-supplied\ndata to a template:\n```\n// Create a tool manager\nToolManager manager = new ToolManager(true);\n// Create a context from the tool manager\nContext context = manager.createContext();\n// For demonstration purposes, alternatively configure from a properties file\ncontext.put(\"esc\", new EscapeTool());\n// For demonstration purposes, create an output buffer\nStringWriter stringWriter = new StringWriter();\n// Get userInput\nString userInput = \"potentially malicious data\";\n// Use the context to pass in the userInput value\ncontext.put(\"userInput\", userInput);\n// Pass in the context, the output buffer, a logtag (demo), and the template with userInput\n// making sure to escape it if in the context of HTML.\nVelocity.evaluate(context, stringWriter, \"demo\", \"Hello $esc.html($userInput)\");\n// Work with the output buffer\n// ...\n```\n\nFor other templating engines, please see your framework's documentation.\n"},"help":{"markdown":"The application may allow control over a template string. Providing user input directly in the\ntemplate by\ndynamically creating template strings may allow an adversary to execute arbitrary Java code,\nincluding\nOS system commands.\n\nFor Velocity, never call `evaluate` with user-supplied input in the template string. Use a\n`VelocityContext`\nobject instead to data-bind user-supplied information as it will be treated as an underlying\ndata type and not\ntemplate code.\n\nExample using Apache Velocity's `VelocityContext` and escape tools to pass in user-supplied\ndata to a template:\n```\n// Create a tool manager\nToolManager manager = new ToolManager(true);\n// Create a context from the tool manager\nContext context = manager.createContext();\n// For demonstration purposes, alternatively configure from a properties file\ncontext.put(\"esc\", new EscapeTool());\n// For demonstration purposes, create an output buffer\nStringWriter stringWriter = new StringWriter();\n// Get userInput\nString userInput = \"potentially malicious data\";\n// Use the context to pass in the userInput value\ncontext.put(\"userInput\", userInput);\n// Pass in the context, the output buffer, a logtag (demo), and the template with userInput\n// making sure to escape it if in the context of HTML.\nVelocity.evaluate(context, stringWriter, \"demo\", \"Hello $esc.html($userInput)\");\n// Work with the output buffer\n// ...\n```\n\nFor other templating engines, please see your framework's documentation.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1)\n","text":"The application may allow control over a template string. Providing user input directly in the\ntemplate by\ndynamically creating template strings may allow an adversary to execute arbitrary Java code,\nincluding\nOS system commands.\n\nFor Velocity, never call `evaluate` with user-supplied input in the template string. Use a\n`VelocityContext`\nobject instead to data-bind user-supplied information as it will be treated as an underlying\ndata type and not\ntemplate code.\n\nExample using Apache Velocity's `VelocityContext` and escape tools to pass in user-supplied\ndata to a template:\n```\n// Create a tool manager\nToolManager manager = new ToolManager(true);\n// Create a context from the tool manager\nContext context = manager.createContext();\n// For demonstration purposes, alternatively configure from a properties file\ncontext.put(\"esc\", new EscapeTool());\n// For demonstration purposes, create an output buffer\nStringWriter stringWriter = new StringWriter();\n// Get userInput\nString userInput = \"potentially malicious data\";\n// Use the context to pass in the userInput value\ncontext.put(\"userInput\", userInput);\n// Pass in the context, the output buffer, a logtag (demo), and the template with userInput\n// making sure to escape it if in the context of HTML.\nVelocity.evaluate(context, stringWriter, \"demo\", \"Hello $esc.html($userInput)\");\n// Work with the output buffer\n// ...\n```\n\nFor other templating engines, please see your framework's documentation.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1","id":"gitlab.find_sec_bugs.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1","name":"gitlab.find_sec_bugs.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1","properties":{"precision":"very-high","tags":["CWE-94","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"High"},"shortDescription":{"text":"Improper control of generation of code ('Code Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A trust boundary can be thought of as line drawn through a program. On one side\nof the line, data is untrusted. On the other side of the line, data is assumed\nto be trustworthy. The purpose of validation logic is to allow data to safely\ncross the trust boundary - to move from untrusted to trusted. A trust boundary\nviolation occurs when a program blurs the line between what is trusted and what\nis untrusted. By combining trusted and untrusted data in the same data\nstructure, it becomes easier for programmers to mistakenly trust unvalidated\ndata.\n"},"help":{"markdown":"A trust boundary can be thought of as line drawn through a program. On one side\nof the line, data is untrusted. On the other side of the line, data is assumed\nto be trustworthy. The purpose of validation logic is to allow data to safely\ncross the trust boundary - to move from untrusted to trusted. A trust boundary\nviolation occurs when a program blurs the line between what is trusted and what\nis untrusted. By combining trusted and untrusted data in the same data\nstructure, it becomes easier for programmers to mistakenly trust unvalidated\ndata.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.TRUST_BOUNDARY_VIOLATION-1)\n","text":"A trust boundary can be thought of as line drawn through a program. On one side\nof the line, data is untrusted. On the other side of the line, data is assumed\nto be trustworthy. The purpose of validation logic is to allow data to safely\ncross the trust boundary - to move from untrusted to trusted. A trust boundary\nviolation occurs when a program blurs the line between what is trusted and what\nis untrusted. By combining trusted and untrusted data in the same data\nstructure, it becomes easier for programmers to mistakenly trust unvalidated\ndata.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.TRUST_BOUNDARY_VIOLATION-1","id":"gitlab.find_sec_bugs.TRUST_BOUNDARY_VIOLATION-1","name":"gitlab.find_sec_bugs.TRUST_BOUNDARY_VIOLATION-1","properties":{"precision":"very-high","tags":["CWE-501","security"]},"shortDescription":{"text":"Trust Boundary Violation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Beyond using an SSL socket, you need to make sure your use of SSLSocketFactory\ndoes all the appropriate certificate validation checks to make sure you are not\nsubject to man-in-the-middle attacks. Please read the OWASP Transport Layer\nProtection Cheat Sheet for details on how to do this correctly.\n"},"help":{"markdown":"Beyond using an SSL socket, you need to make sure your use of SSLSocketFactory\ndoes all the appropriate certificate validation checks to make sure you are not\nsubject to man-in-the-middle attacks. Please read the OWASP Transport Layer\nProtection Cheat Sheet for details on how to do this correctly.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1)\n","text":"Beyond using an SSL socket, you need to make sure your use of SSLSocketFactory\ndoes all the appropriate certificate validation checks to make sure you are not\nsubject to man-in-the-middle attacks. Please read the OWASP Transport Layer\nProtection Cheat Sheet for details on how to do this correctly.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1","id":"gitlab.find_sec_bugs.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1","name":"gitlab.find_sec_bugs.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1","properties":{"precision":"very-high","tags":["CWE-319","security"]},"shortDescription":{"text":"Cleartext Transmission of Sensitive Information"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Unvalidated redirects occur when an application redirects a user to a\ndestination URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities can be used to facilitate phishing attacks.\n\nTo avoid open redirect vulnerabilities in Java, one effective strategy is to\nonly allow redirection to URLs that are pre-defined in a safe list. This safe\nlist can be implemented using a collection like a Map, List, or Dictionary,\nwhere you store all the valid URLs or URL patterns. When a redirect request is\nmade, you can check if the requested URL is in this safe list before proceeding \nwith the redirection. For example:\n\n```\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n      private List<String> safeUrls = new ArrayList<>();\n      safeUrls.add(\"/home\");\n      safeUrls.add(\"/user/profile\");\n      safeUrls.add(\"/dashboard\");\n      \n      String redirectUrl = request.getParameter(\"url\");\n\n      if (safeUrls.contains(redirectUrl)) {\n          response.sendRedirect(redirectUrl);\n      } else {\n          response.sendRedirect(\"/errorPage\");\n      }\n  }\"\n```  \n"},"help":{"markdown":"Unvalidated redirects occur when an application redirects a user to a\ndestination URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities can be used to facilitate phishing attacks.\n\nTo avoid open redirect vulnerabilities in Java, one effective strategy is to\nonly allow redirection to URLs that are pre-defined in a safe list. This safe\nlist can be implemented using a collection like a Map, List, or Dictionary,\nwhere you store all the valid URLs or URL patterns. When a redirect request is\nmade, you can check if the requested URL is in this safe list before proceeding \nwith the redirection. For example:\n\n```\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n      private List<String> safeUrls = new ArrayList<>();\n      safeUrls.add(\"/home\");\n      safeUrls.add(\"/user/profile\");\n      safeUrls.add(\"/dashboard\");\n      \n      String redirectUrl = request.getParameter(\"url\");\n\n      if (safeUrls.contains(redirectUrl)) {\n          response.sendRedirect(redirectUrl);\n      } else {\n          response.sendRedirect(\"/errorPage\");\n      }\n  }\"\n```  \n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.UNVALIDATED_REDIRECT-1.URL_REWRITING-1)\n","text":"Unvalidated redirects occur when an application redirects a user to a\ndestination URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities can be used to facilitate phishing attacks.\n\nTo avoid open redirect vulnerabilities in Java, one effective strategy is to\nonly allow redirection to URLs that are pre-defined in a safe list. This safe\nlist can be implemented using a collection like a Map, List, or Dictionary,\nwhere you store all the valid URLs or URL patterns. When a redirect request is\nmade, you can check if the requested URL is in this safe list before proceeding \nwith the redirection. For example:\n\n```\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n      private List<String> safeUrls = new ArrayList<>();\n      safeUrls.add(\"/home\");\n      safeUrls.add(\"/user/profile\");\n      safeUrls.add(\"/dashboard\");\n      \n      String redirectUrl = request.getParameter(\"url\");\n\n      if (safeUrls.contains(redirectUrl)) {\n          response.sendRedirect(redirectUrl);\n      } else {\n          response.sendRedirect(\"/errorPage\");\n      }\n  }\"\n```  \n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.UNVALIDATED_REDIRECT-1.URL_REWRITING-1","id":"gitlab.find_sec_bugs.UNVALIDATED_REDIRECT-1.URL_REWRITING-1","name":"gitlab.find_sec_bugs.UNVALIDATED_REDIRECT-1.URL_REWRITING-1","properties":{"precision":"very-high","tags":["CWE-601","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Info"},"shortDescription":{"text":"URL redirection to untrusted site ('Open Redirect')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Server-Side-Request-Forgery (SSRF) exploits backend systems that initiate requests to third\nparties.\nIf user input is used in constructing or sending these requests, an attacker could supply\nmalicious\ndata to force the request to other systems or modify request data to cause unwanted actions.\n\nEnsure user input is not used directly in constructing URLs or URIs when initiating requests\nto third party\nsystems from back end systems. Care must also be taken when constructing payloads using user\ninput. Where\npossible restrict to known URIs or payloads. Consider using a server-side map where keys are\nused to return\nURLs such as `https://site/goto?key=1` where `{key: 1, url: 'http://some.url/', key: 2, url:\n'http://...'}`.\n\nIf you must use user-supplied input for requesting URLs, it is strongly recommended that the\nHTTP client\nchosen allows you to customize and block certain IP ranges at the network level. By blocking\nRFC 1918\naddresses or other network address ranges, you can limit the severity of a successful SSRF\nattack. Care must\nalso be taken to block certain protocol or address formatting such as IPv6.\n\nIf you cannot block address ranges at the client level, you may want to run the HTTP client\nas a protected\nuser, or in a protected network where you can apply IP Table or firewall rules to block access\nto dangerous\naddresses. Finally, if none of the above protections are available, you could also run a\ncustom HTTP proxy\nand force all requests through it to handle blocking dangerous addresses.\n\nExample using a map to look up a key to be used in a HTTP request:\n```\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"https://example.com/\");\nlookupTable.put(\"key2\", \"https://safeurl.com/\");\nString userInput = request.getParameter(\"key\");\n\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n    // Lookup the value from our user input from our lookupTable\n    String value = lookupTable.getOrDefault(userInput, \"https://example.com/\");\n    // Construct the url, with the hardcoded url and only pass in the value from the\nlookupTable,\n    // not direct user input\n    final HttpGet httpget = new HttpGet(value);\n    // Execute the request\n    CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n    // Read the response\n    byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n    // Handle the response\n    // ...\n}\n```\n\nIf using a map is not possible, the user-supplied input must be encoded prior to use, and\nnever allow full\nURLs:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the string using java.net.URLEncoder with the UTF-8 character set\nString encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n  // Construct the url, with the hardcoded url and only pass in the encoded value, never a\nfull URL\n  final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+encodedString);\n  // Execute the request\n  CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n  // Read the response\n  byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n  // handle the response\n}\n```\n\nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n"},"help":{"markdown":"Server-Side-Request-Forgery (SSRF) exploits backend systems that initiate requests to third\nparties.\nIf user input is used in constructing or sending these requests, an attacker could supply\nmalicious\ndata to force the request to other systems or modify request data to cause unwanted actions.\n\nEnsure user input is not used directly in constructing URLs or URIs when initiating requests\nto third party\nsystems from back end systems. Care must also be taken when constructing payloads using user\ninput. Where\npossible restrict to known URIs or payloads. Consider using a server-side map where keys are\nused to return\nURLs such as `https://site/goto?key=1` where `{key: 1, url: 'http://some.url/', key: 2, url:\n'http://...'}`.\n\nIf you must use user-supplied input for requesting URLs, it is strongly recommended that the\nHTTP client\nchosen allows you to customize and block certain IP ranges at the network level. By blocking\nRFC 1918\naddresses or other network address ranges, you can limit the severity of a successful SSRF\nattack. Care must\nalso be taken to block certain protocol or address formatting such as IPv6.\n\nIf you cannot block address ranges at the client level, you may want to run the HTTP client\nas a protected\nuser, or in a protected network where you can apply IP Table or firewall rules to block access\nto dangerous\naddresses. Finally, if none of the above protections are available, you could also run a\ncustom HTTP proxy\nand force all requests through it to handle blocking dangerous addresses.\n\nExample using a map to look up a key to be used in a HTTP request:\n```\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"https://example.com/\");\nlookupTable.put(\"key2\", \"https://safeurl.com/\");\nString userInput = request.getParameter(\"key\");\n\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n    // Lookup the value from our user input from our lookupTable\n    String value = lookupTable.getOrDefault(userInput, \"https://example.com/\");\n    // Construct the url, with the hardcoded url and only pass in the value from the\nlookupTable,\n    // not direct user input\n    final HttpGet httpget = new HttpGet(value);\n    // Execute the request\n    CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n    // Read the response\n    byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n    // Handle the response\n    // ...\n}\n```\n\nIf using a map is not possible, the user-supplied input must be encoded prior to use, and\nnever allow full\nURLs:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the string using java.net.URLEncoder with the UTF-8 character set\nString encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n  // Construct the url, with the hardcoded url and only pass in the encoded value, never a\nfull URL\n  final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+encodedString);\n  // Execute the request\n  CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n  // Read the response\n  byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n  // handle the response\n}\n```\n\nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.URLCONNECTION_SSRF_FD-1)\n","text":"Server-Side-Request-Forgery (SSRF) exploits backend systems that initiate requests to third\nparties.\nIf user input is used in constructing or sending these requests, an attacker could supply\nmalicious\ndata to force the request to other systems or modify request data to cause unwanted actions.\n\nEnsure user input is not used directly in constructing URLs or URIs when initiating requests\nto third party\nsystems from back end systems. Care must also be taken when constructing payloads using user\ninput. Where\npossible restrict to known URIs or payloads. Consider using a server-side map where keys are\nused to return\nURLs such as `https://site/goto?key=1` where `{key: 1, url: 'http://some.url/', key: 2, url:\n'http://...'}`.\n\nIf you must use user-supplied input for requesting URLs, it is strongly recommended that the\nHTTP client\nchosen allows you to customize and block certain IP ranges at the network level. By blocking\nRFC 1918\naddresses or other network address ranges, you can limit the severity of a successful SSRF\nattack. Care must\nalso be taken to block certain protocol or address formatting such as IPv6.\n\nIf you cannot block address ranges at the client level, you may want to run the HTTP client\nas a protected\nuser, or in a protected network where you can apply IP Table or firewall rules to block access\nto dangerous\naddresses. Finally, if none of the above protections are available, you could also run a\ncustom HTTP proxy\nand force all requests through it to handle blocking dangerous addresses.\n\nExample using a map to look up a key to be used in a HTTP request:\n```\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"https://example.com/\");\nlookupTable.put(\"key2\", \"https://safeurl.com/\");\nString userInput = request.getParameter(\"key\");\n\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n    // Lookup the value from our user input from our lookupTable\n    String value = lookupTable.getOrDefault(userInput, \"https://example.com/\");\n    // Construct the url, with the hardcoded url and only pass in the value from the\nlookupTable,\n    // not direct user input\n    final HttpGet httpget = new HttpGet(value);\n    // Execute the request\n    CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n    // Read the response\n    byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n    // Handle the response\n    // ...\n}\n```\n\nIf using a map is not possible, the user-supplied input must be encoded prior to use, and\nnever allow full\nURLs:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the string using java.net.URLEncoder with the UTF-8 character set\nString encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n  // Construct the url, with the hardcoded url and only pass in the encoded value, never a\nfull URL\n  final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+encodedString);\n  // Execute the request\n  CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n  // Read the response\n  byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n  // handle the response\n}\n```\n\nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.URLCONNECTION_SSRF_FD-1","id":"gitlab.find_sec_bugs.URLCONNECTION_SSRF_FD-1","name":"gitlab.find_sec_bugs.URLCONNECTION_SSRF_FD-1","properties":{"precision":"very-high","tags":["CWE-918","OWASP-A10:2021-Server-Side Request Forgery","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Server-Side Request Forgery (SSRF)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The filename provided by the FileUpload API can be tampered with by the client to reference\nunauthorized files. The provided filename should be properly validated to ensure it's properly\nstructured, contains no unauthorized path characters (e.g., / \\), and refers to an authorized\nfile.\n\nThe application was found to take a parameter from user input to construct a path name. If an\nunfiltered parameter is passed to this file API, files from an arbitrary filesystem location\ncould be read. When data from an unstrusted source is untrusted source is used to construct\na file path, an attacker could potentially gain access to restrcited files locations outside\nthe relevant context.\n\nFor example, if the application tries to access the users profile picture based on their user\nname by concatenating the username to the filepath:\n\n\"images/userprofiles/\" + username\n\nThe expected result of this would be \"images/userprofiles/alice\", however an attacker could\nuse a malicious input such as \"../../../etc/passwd\" to gain access to and/or manipulate\nsensitive information\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy.\n\nInputs can be sanitized by using the getName() method with concat() method to remove the \npotentially malicious path traversal and limit the scope to a restricted directory. Or \ninput can also be sanitized by using resolve() method alongwith startsWith() method to \nverify that the base path of the file is safe and expected.\n\nExample of limiting path traversal using getName:\n\n```\nprotected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n    String input = req.getHeader(\"input\");\n\n    input = getName(input);\n    \n    String safePath = concat(basePath, input);\n\n    // Read the contents of the file\n    File file = new File(safePath);\n}\n```\n"},"help":{"markdown":"The filename provided by the FileUpload API can be tampered with by the client to reference\nunauthorized files. The provided filename should be properly validated to ensure it's properly\nstructured, contains no unauthorized path characters (e.g., / \\), and refers to an authorized\nfile.\n\nThe application was found to take a parameter from user input to construct a path name. If an\nunfiltered parameter is passed to this file API, files from an arbitrary filesystem location\ncould be read. When data from an unstrusted source is untrusted source is used to construct\na file path, an attacker could potentially gain access to restrcited files locations outside\nthe relevant context.\n\nFor example, if the application tries to access the users profile picture based on their user\nname by concatenating the username to the filepath:\n\n\"images/userprofiles/\" + username\n\nThe expected result of this would be \"images/userprofiles/alice\", however an attacker could\nuse a malicious input such as \"../../../etc/passwd\" to gain access to and/or manipulate\nsensitive information\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy.\n\nInputs can be sanitized by using the getName() method with concat() method to remove the \npotentially malicious path traversal and limit the scope to a restricted directory. Or \ninput can also be sanitized by using resolve() method alongwith startsWith() method to \nverify that the base path of the file is safe and expected.\n\nExample of limiting path traversal using getName:\n\n```\nprotected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n    String input = req.getHeader(\"input\");\n\n    input = getName(input);\n    \n    String safePath = concat(basePath, input);\n\n    // Read the contents of the file\n    File file = new File(safePath);\n}\n```\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_FILENAMEUTILS-1)\n","text":"The filename provided by the FileUpload API can be tampered with by the client to reference\nunauthorized files. The provided filename should be properly validated to ensure it's properly\nstructured, contains no unauthorized path characters (e.g., / \\), and refers to an authorized\nfile.\n\nThe application was found to take a parameter from user input to construct a path name. If an\nunfiltered parameter is passed to this file API, files from an arbitrary filesystem location\ncould be read. When data from an unstrusted source is untrusted source is used to construct\na file path, an attacker could potentially gain access to restrcited files locations outside\nthe relevant context.\n\nFor example, if the application tries to access the users profile picture based on their user\nname by concatenating the username to the filepath:\n\n\"images/userprofiles/\" + username\n\nThe expected result of this would be \"images/userprofiles/alice\", however an attacker could\nuse a malicious input such as \"../../../etc/passwd\" to gain access to and/or manipulate\nsensitive information\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy.\n\nInputs can be sanitized by using the getName() method with concat() method to remove the \npotentially malicious path traversal and limit the scope to a restricted directory. Or \ninput can also be sanitized by using resolve() method alongwith startsWith() method to \nverify that the base path of the file is safe and expected.\n\nExample of limiting path traversal using getName:\n\n```\nprotected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n    String input = req.getHeader(\"input\");\n\n    input = getName(input);\n    \n    String safePath = concat(basePath, input);\n\n    // Read the contents of the file\n    File file = new File(safePath);\n}\n```\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_FILENAMEUTILS-1","id":"gitlab.find_sec_bugs.WEAK_FILENAMEUTILS-1","name":"gitlab.find_sec_bugs.WEAK_FILENAMEUTILS-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The `HostnameVerifier` has been set to always return `true`. This effectively \ndisables the validation of server or client certificates. This could allow an \nadversary who is in between the application and the target host to launch a Man \nin the middle attack (MITM) i.e intercept potentially sensitive information or \ninject malicious content into the communication stream.\n\nTo mitigate this vulnerability and enhance the security of your application, it is \nstrongly advised to adhere to the default HostnameVerifier settings. This ensures \nthat the validation mechanism remains intact, providing a crucial layer of security \nagainst unauthorized interception and data manipulation.\n\nImplementing the default HostnameVerifier can be achieved with the following code \nsnippet:\n```\n// Use the default HostnameVerifier\nHttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\nconnection.setHostnameVerifier(HttpsURLConnection.getDefaultHostnameVerifier());\n```\nFor more information on TLS security, refer the following OWASP documentation:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\n"},"help":{"markdown":"The `HostnameVerifier` has been set to always return `true`. This effectively \ndisables the validation of server or client certificates. This could allow an \nadversary who is in between the application and the target host to launch a Man \nin the middle attack (MITM) i.e intercept potentially sensitive information or \ninject malicious content into the communication stream.\n\nTo mitigate this vulnerability and enhance the security of your application, it is \nstrongly advised to adhere to the default HostnameVerifier settings. This ensures \nthat the validation mechanism remains intact, providing a crucial layer of security \nagainst unauthorized interception and data manipulation.\n\nImplementing the default HostnameVerifier can be achieved with the following code \nsnippet:\n```\n// Use the default HostnameVerifier\nHttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\nconnection.setHostnameVerifier(HttpsURLConnection.getDefaultHostnameVerifier());\n```\nFor more information on TLS security, refer the following OWASP documentation:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_HOSTNAME_VERIFIER)\n","text":"The `HostnameVerifier` has been set to always return `true`. This effectively \ndisables the validation of server or client certificates. This could allow an \nadversary who is in between the application and the target host to launch a Man \nin the middle attack (MITM) i.e intercept potentially sensitive information or \ninject malicious content into the communication stream.\n\nTo mitigate this vulnerability and enhance the security of your application, it is \nstrongly advised to adhere to the default HostnameVerifier settings. This ensures \nthat the validation mechanism remains intact, providing a crucial layer of security \nagainst unauthorized interception and data manipulation.\n\nImplementing the default HostnameVerifier can be achieved with the following code \nsnippet:\n```\n// Use the default HostnameVerifier\nHttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\nconnection.setHostnameVerifier(HttpsURLConnection.getDefaultHostnameVerifier());\n```\nFor more information on TLS security, refer the following OWASP documentation:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_HOSTNAME_VERIFIER","id":"gitlab.find_sec_bugs.WEAK_HOSTNAME_VERIFIER","name":"gitlab.find_sec_bugs.WEAK_HOSTNAME_VERIFIER","properties":{"precision":"very-high","tags":["CWE-295","OWASP-A05:2021-Security Misconfiguration","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper certificate validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Either the `HostnameVerifier` has been set to always return `true` or the `X509TrustManager`\nhas\nbeen configured to return null, or both. This effectively disables the validation of server or\nclient certificates.\n\nThis allows for an adversary who is in between the application and the target host to intercept\npotentially sensitive information or transmit malicious data.\n\nIt is recommended to not override the default `HostnameVerifiers`.\n\nConsider using the default `TrustManager` instead of implementing a custom one. If you must\noverride\nthe default verification process, implement proper TrustManager verification for\n`checkServerTrusted` and\n`checkClientTrusted` by throwing `CertificateException` if the certificate is invalid.\n\nExample using the built in `TrustManagerFactory` to manage validating certificate chains:\n```\n// Use the default TrustManagerFactory\nTrustManagerFactory trustManagerFactory =\nTrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n// Use default system KeyStore, alternatively pass in your own keystore.\ntrustManagerFactory.init((KeyStore) null);\n// Create SSLContext for TLS connections\nSSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n// Initialize the tlsContext with our trust manager and a SecureRandom number generator.\ntlsContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n```\n\nFor more information on TLS security see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\n"},"help":{"markdown":"Either the `HostnameVerifier` has been set to always return `true` or the `X509TrustManager`\nhas\nbeen configured to return null, or both. This effectively disables the validation of server or\nclient certificates.\n\nThis allows for an adversary who is in between the application and the target host to intercept\npotentially sensitive information or transmit malicious data.\n\nIt is recommended to not override the default `HostnameVerifiers`.\n\nConsider using the default `TrustManager` instead of implementing a custom one. If you must\noverride\nthe default verification process, implement proper TrustManager verification for\n`checkServerTrusted` and\n`checkClientTrusted` by throwing `CertificateException` if the certificate is invalid.\n\nExample using the built in `TrustManagerFactory` to manage validating certificate chains:\n```\n// Use the default TrustManagerFactory\nTrustManagerFactory trustManagerFactory =\nTrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n// Use default system KeyStore, alternatively pass in your own keystore.\ntrustManagerFactory.init((KeyStore) null);\n// Create SSLContext for TLS connections\nSSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n// Initialize the tlsContext with our trust manager and a SecureRandom number generator.\ntlsContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n```\n\nFor more information on TLS security see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1)\n","text":"Either the `HostnameVerifier` has been set to always return `true` or the `X509TrustManager`\nhas\nbeen configured to return null, or both. This effectively disables the validation of server or\nclient certificates.\n\nThis allows for an adversary who is in between the application and the target host to intercept\npotentially sensitive information or transmit malicious data.\n\nIt is recommended to not override the default `HostnameVerifiers`.\n\nConsider using the default `TrustManager` instead of implementing a custom one. If you must\noverride\nthe default verification process, implement proper TrustManager verification for\n`checkServerTrusted` and\n`checkClientTrusted` by throwing `CertificateException` if the certificate is invalid.\n\nExample using the built in `TrustManagerFactory` to manage validating certificate chains:\n```\n// Use the default TrustManagerFactory\nTrustManagerFactory trustManagerFactory =\nTrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n// Use default system KeyStore, alternatively pass in your own keystore.\ntrustManagerFactory.init((KeyStore) null);\n// Create SSLContext for TLS connections\nSSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n// Initialize the tlsContext with our trust manager and a SecureRandom number generator.\ntlsContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n```\n\nFor more information on TLS security see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1","id":"gitlab.find_sec_bugs.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1","name":"gitlab.find_sec_bugs.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1","properties":{"precision":"very-high","tags":["CWE-295","security"]},"shortDescription":{"text":"Improper certificate validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found using an insecure or risky digest or signature algorithm. Both MD5\nand SHA1 hash algorithms have been found to be vulnerable to producing collisions.\nThis means\nthat two different values, when hashed, can lead to the same hash value. If the application is\ntrying\nto use these hash methods for storing passwords, then it is recommended to switch to a\npassword hashing\nalgorithm such as Argon2id or PBKDF2.\nstrongly recommended that a standard Digest algorithm be chosen instead as implementing\na digest by hand is error-prone.\n\nExample of creating a SHA-384 hash:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(input);\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// output base64 encoded version of the hash\nSystem.out.println(\"hash: \" + Base64.getEncoder().encodeToString(output));\n```\n\nFor more information on secure password storage see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n"},"help":{"markdown":"The application was found using an insecure or risky digest or signature algorithm. Both MD5\nand SHA1 hash algorithms have been found to be vulnerable to producing collisions.\nThis means\nthat two different values, when hashed, can lead to the same hash value. If the application is\ntrying\nto use these hash methods for storing passwords, then it is recommended to switch to a\npassword hashing\nalgorithm such as Argon2id or PBKDF2.\nstrongly recommended that a standard Digest algorithm be chosen instead as implementing\na digest by hand is error-prone.\n\nExample of creating a SHA-384 hash:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(input);\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// output base64 encoded version of the hash\nSystem.out.println(\"hash: \" + Base64.getEncoder().encodeToString(output));\n```\n\nFor more information on secure password storage see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1)\n","text":"The application was found using an insecure or risky digest or signature algorithm. Both MD5\nand SHA1 hash algorithms have been found to be vulnerable to producing collisions.\nThis means\nthat two different values, when hashed, can lead to the same hash value. If the application is\ntrying\nto use these hash methods for storing passwords, then it is recommended to switch to a\npassword hashing\nalgorithm such as Argon2id or PBKDF2.\nstrongly recommended that a standard Digest algorithm be chosen instead as implementing\na digest by hand is error-prone.\n\nExample of creating a SHA-384 hash:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(input);\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// output base64 encoded version of the hash\nSystem.out.println(\"hash: \" + Base64.getEncoder().encodeToString(output));\n```\n\nFor more information on secure password storage see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","id":"gitlab.find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","name":"gitlab.find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A04:2021-Insecure Design","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm (SHA1/MD5)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The `X509TrustManager` has been configured to return null. This effectively disables the\nvalidation of server or client certificates. This could allow an adversary who is in \nbetween the application and the target host to launch a Man in the middle attack (MITM) i.e \nintercept potentially sensitive information or inject malicious content into the \ncommunication stream.\n\nConsider using the \ndefault `TrustManager` instead of implementing a custom one. If you must override\nthe default verification process, implement proper TrustManager verification for\n`checkServerTrusted` and `checkClientTrusted` by throwing `CertificateException` if \nthe certificate is invalid.\n\nFor most applications, using the default TrustManager provided by the Java runtime is \nsufficient and recommended. Following is an example using the built in `TrustManagerFactory` \nto manage validating certificate chains:\n```\n// Use the default TrustManagerFactory\nTrustManagerFactory trustManagerFactory =\nTrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n// Use default system KeyStore, alternatively pass in your own keystore.\ntrustManagerFactory.init((KeyStore) null);\n// Create SSLContext for TLS connections\nSSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n// Initialize the tlsContext with our trust manager and a SecureRandom number generator.\ntlsContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n```\nFor more information on TLS security, refer the following OWASP documentation:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\n"},"help":{"markdown":"The `X509TrustManager` has been configured to return null. This effectively disables the\nvalidation of server or client certificates. This could allow an adversary who is in \nbetween the application and the target host to launch a Man in the middle attack (MITM) i.e \nintercept potentially sensitive information or inject malicious content into the \ncommunication stream.\n\nConsider using the \ndefault `TrustManager` instead of implementing a custom one. If you must override\nthe default verification process, implement proper TrustManager verification for\n`checkServerTrusted` and `checkClientTrusted` by throwing `CertificateException` if \nthe certificate is invalid.\n\nFor most applications, using the default TrustManager provided by the Java runtime is \nsufficient and recommended. Following is an example using the built in `TrustManagerFactory` \nto manage validating certificate chains:\n```\n// Use the default TrustManagerFactory\nTrustManagerFactory trustManagerFactory =\nTrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n// Use default system KeyStore, alternatively pass in your own keystore.\ntrustManagerFactory.init((KeyStore) null);\n// Create SSLContext for TLS connections\nSSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n// Initialize the tlsContext with our trust manager and a SecureRandom number generator.\ntlsContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n```\nFor more information on TLS security, refer the following OWASP documentation:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_TRUST_MANAGER)\n","text":"The `X509TrustManager` has been configured to return null. This effectively disables the\nvalidation of server or client certificates. This could allow an adversary who is in \nbetween the application and the target host to launch a Man in the middle attack (MITM) i.e \nintercept potentially sensitive information or inject malicious content into the \ncommunication stream.\n\nConsider using the \ndefault `TrustManager` instead of implementing a custom one. If you must override\nthe default verification process, implement proper TrustManager verification for\n`checkServerTrusted` and `checkClientTrusted` by throwing `CertificateException` if \nthe certificate is invalid.\n\nFor most applications, using the default TrustManager provided by the Java runtime is \nsufficient and recommended. Following is an example using the built in `TrustManagerFactory` \nto manage validating certificate chains:\n```\n// Use the default TrustManagerFactory\nTrustManagerFactory trustManagerFactory =\nTrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n// Use default system KeyStore, alternatively pass in your own keystore.\ntrustManagerFactory.init((KeyStore) null);\n// Create SSLContext for TLS connections\nSSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n// Initialize the tlsContext with our trust manager and a SecureRandom number generator.\ntlsContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n```\nFor more information on TLS security, refer the following OWASP documentation:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.WEAK_TRUST_MANAGER","id":"gitlab.find_sec_bugs.WEAK_TRUST_MANAGER","name":"gitlab.find_sec_bugs.WEAK_TRUST_MANAGER","properties":{"precision":"very-high","tags":["CWE-295","OWASP-A05:2021-Security Misconfiguration","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper certificate validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application is disabling Wicket's string escaping functionality by calling\n`setEscapeModelStrings(false)`.\nThis could lead to Cross Site Scripting (XSS) if used with user-supplied input. XSS is an\nattack which exploits\n a web application or system to treat    user input\nas markup or script code. It is important to encode the data depending on the specific context\nit\nis used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input\nis ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as JavaScript code. Care must also be\ntaken\nto not mix server-side templating with client-side templating, as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be\nencoded depending on context of where it is output. It is much safer to force the displaying\nsystem to\nhandle the encoding and not attempt to guess how it should be encoded.\n\nUse Wicket's built in escaping feature by calling `Component.setEscapeModelStrings(true);`\n\nFor more information on Wicket components see:\n- https://nightlies.apache.org/wicket/apidocs/9.x/org/apache/wicket/Component.html\n\nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n"},"help":{"markdown":"The application is disabling Wicket's string escaping functionality by calling\n`setEscapeModelStrings(false)`.\nThis could lead to Cross Site Scripting (XSS) if used with user-supplied input. XSS is an\nattack which exploits\n a web application or system to treat    user input\nas markup or script code. It is important to encode the data depending on the specific context\nit\nis used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input\nis ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as JavaScript code. Care must also be\ntaken\nto not mix server-side templating with client-side templating, as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be\nencoded depending on context of where it is output. It is much safer to force the displaying\nsystem to\nhandle the encoding and not attempt to guess how it should be encoded.\n\nUse Wicket's built in escaping feature by calling `Component.setEscapeModelStrings(true);`\n\nFor more information on Wicket components see:\n- https://nightlies.apache.org/wicket/apidocs/9.x/org/apache/wicket/Component.html\n\nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.WICKET_XSS1-1)\n","text":"The application is disabling Wicket's string escaping functionality by calling\n`setEscapeModelStrings(false)`.\nThis could lead to Cross Site Scripting (XSS) if used with user-supplied input. XSS is an\nattack which exploits\n a web application or system to treat    user input\nas markup or script code. It is important to encode the data depending on the specific context\nit\nis used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input\nis ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as JavaScript code. Care must also be\ntaken\nto not mix server-side templating with client-side templating, as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be\nencoded depending on context of where it is output. It is much safer to force the displaying\nsystem to\nhandle the encoding and not attempt to guess how it should be encoded.\n\nUse Wicket's built in escaping feature by calling `Component.setEscapeModelStrings(true);`\n\nFor more information on Wicket components see:\n- https://nightlies.apache.org/wicket/apidocs/9.x/org/apache/wicket/Component.html\n\nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.WICKET_XSS1-1","id":"gitlab.find_sec_bugs.WICKET_XSS1-1","name":"gitlab.find_sec_bugs.WICKET_XSS1-1","properties":{"precision":"very-high","tags":["CWE-79","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper neutralization of input during web page generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Deserialization attacks exploit the process of reading serialized data and turning it back\ninto an object. By constructing malicious objects and serializing them, an adversary may\nattempt to:\n\n- Inject code that is executed upon object construction, which occurs during the\ndeserialization process.\n- Exploit mass assignment by including fields that are not normally a part of the serialized\ndata but are read in during deserialization.\n\nConsider safer alternatives such as serializing data in the JSON format. Ensure any format\nchosen allows\nthe application to specify exactly which object types are allowed to be deserialized.\nAdditionally, when\ndeserializing, never deserialize to base object types like `Object` and only cast to the exact\nobject\ntype that is expected.\n\nTo protect against mass assignment, only allow deserialization of the specific fields that are\nrequired. If this is not easily done, consider creating an intermediary type that\ncan be serialized with only the necessary fields exposed.\n\nDo note that `XMLEncoder` and `XMLDecoder` are not recommended. If the application must\nuse this serialization method, use a custom ClassLoader to prevent loading of arbitrary\nclasses:\n```\nXMLDecoder decoder = new XMLDecoder(inputStream, null, null, new ClassLoader() {\n    @Override\n    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        if (!name.equals(NameOfBeanHere.class.getName()) &&\n!name.equals(XMLDecoder.class.getName())) {\n            throw new RuntimeException(\"Unauthorized deserialization attempt: \" + name);\n        }\n\n        return super.loadClass(name, resolve);\n    }\n});\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n\nFor more details on deserialization attacks in general, see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html\n\nIt should be noted that [tools exist](https://github.com/frohoff/ysoserial) to\nautomatically create\nexploit code for these vulnerabilities.\n"},"help":{"markdown":"Deserialization attacks exploit the process of reading serialized data and turning it back\ninto an object. By constructing malicious objects and serializing them, an adversary may\nattempt to:\n\n- Inject code that is executed upon object construction, which occurs during the\ndeserialization process.\n- Exploit mass assignment by including fields that are not normally a part of the serialized\ndata but are read in during deserialization.\n\nConsider safer alternatives such as serializing data in the JSON format. Ensure any format\nchosen allows\nthe application to specify exactly which object types are allowed to be deserialized.\nAdditionally, when\ndeserializing, never deserialize to base object types like `Object` and only cast to the exact\nobject\ntype that is expected.\n\nTo protect against mass assignment, only allow deserialization of the specific fields that are\nrequired. If this is not easily done, consider creating an intermediary type that\ncan be serialized with only the necessary fields exposed.\n\nDo note that `XMLEncoder` and `XMLDecoder` are not recommended. If the application must\nuse this serialization method, use a custom ClassLoader to prevent loading of arbitrary\nclasses:\n```\nXMLDecoder decoder = new XMLDecoder(inputStream, null, null, new ClassLoader() {\n    @Override\n    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        if (!name.equals(NameOfBeanHere.class.getName()) &&\n!name.equals(XMLDecoder.class.getName())) {\n            throw new RuntimeException(\"Unauthorized deserialization attempt: \" + name);\n        }\n\n        return super.loadClass(name, resolve);\n    }\n});\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n\nFor more details on deserialization attacks in general, see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html\n\nIt should be noted that [tools exist](https://github.com/frohoff/ysoserial) to\nautomatically create\nexploit code for these vulnerabilities.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XML_DECODER-1)\n","text":"Deserialization attacks exploit the process of reading serialized data and turning it back\ninto an object. By constructing malicious objects and serializing them, an adversary may\nattempt to:\n\n- Inject code that is executed upon object construction, which occurs during the\ndeserialization process.\n- Exploit mass assignment by including fields that are not normally a part of the serialized\ndata but are read in during deserialization.\n\nConsider safer alternatives such as serializing data in the JSON format. Ensure any format\nchosen allows\nthe application to specify exactly which object types are allowed to be deserialized.\nAdditionally, when\ndeserializing, never deserialize to base object types like `Object` and only cast to the exact\nobject\ntype that is expected.\n\nTo protect against mass assignment, only allow deserialization of the specific fields that are\nrequired. If this is not easily done, consider creating an intermediary type that\ncan be serialized with only the necessary fields exposed.\n\nDo note that `XMLEncoder` and `XMLDecoder` are not recommended. If the application must\nuse this serialization method, use a custom ClassLoader to prevent loading of arbitrary\nclasses:\n```\nXMLDecoder decoder = new XMLDecoder(inputStream, null, null, new ClassLoader() {\n    @Override\n    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        if (!name.equals(NameOfBeanHere.class.getName()) &&\n!name.equals(XMLDecoder.class.getName())) {\n            throw new RuntimeException(\"Unauthorized deserialization attempt: \" + name);\n        }\n\n        return super.loadClass(name, resolve);\n    }\n});\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n\nFor more details on deserialization attacks in general, see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html\n\nIt should be noted that [tools exist](https://github.com/frohoff/ysoserial) to\nautomatically create\nexploit code for these vulnerabilities.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XML_DECODER-1","id":"gitlab.find_sec_bugs.XML_DECODER-1","name":"gitlab.find_sec_bugs.XML_DECODER-1","properties":{"precision":"very-high","tags":["CWE-502","OWASP-A08:2021-Software and Data Integrity Failures","OWASP-A8:2017-Insecure Deserialization","security"],"security-severity":"High"},"shortDescription":{"text":"Deserialization of untrusted data"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application processes `XPath` queries with potentially malicious input.\nAn adversary who is able to control the XPath query could potentially influence the logic\nof how data is retrieved, processed or even bypass protections.\n\nTo protect against XPath injection, user input should be parameterized using a variable\nresolver.\nBy creating a class that implements the `XPathVariableResolver` the application can ensure\nthat\nthe xpath query and user-supplied input are treated separately.\n\nExample implementation of an XPathVariableResolver:\n```\n// Create a class which implements the XPathVariableResolver interface\npublic static class SimpleXPathVariableResolver implements XPathVariableResolver {\n  // Use a map or lookup table to store variables for resolution\n  private HashMap<QName, String> variables = new HashMap<>();\n  // Allow caller to set variables\n  public void setVariable(QName name, String value) {\n    variables.put(name, value);\n  }\n  // Implement the resolveVariable to return the value\n  @Override\n  public Object resolveVariable(QName name) {\n    return variables.getOrDefault(name, \"\");\n  }\n}\n\npublic static void xpathQuery(String userInput) throws ParseException,\nParserConfigurationException,\n  SAXException, IOException, XPathExpressionException {\n\n  // Create our DocumentFactory\n  DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n  // Enable namespace awareness\n  domFactory.setNamespaceAware(true);\n  // Enable secure processing\n  domFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n  // Create our DocumentBuilder\n  DocumentBuilder builder = domFactory.newDocumentBuilder();\n  // Parse our XML document\n  Document doc = builder.parse(\"inventory.xml\");\n\n  // Create a new instance of an XPath object\n  XPath xpathProcessor = XPathFactory.newInstance().newXPath();\n  // Create our XPathVariableResolver\n  SimpleXPathVariableResolver resolver = new SimpleXPathVariableResolver();\n  // Add user input as a variable value\n  resolver.setVariable(new QName(\"author\"), userInput);\n  // Configure the processor to use our variable resolver\n  xpathProcessor.setXPathVariableResolver(resolver);\n  // Evaluate the XPath query\n      String result = xpathProcessor.compile(\"//author[contains(., $author)]\").evaluate(doc);\n  // Work with the result\n  // ...\n}\n```\n\nFor more information on XPath Injection see:\n- https://owasp.org/www-community/attacks/XPATH_Injection\n"},"help":{"markdown":"The application processes `XPath` queries with potentially malicious input.\nAn adversary who is able to control the XPath query could potentially influence the logic\nof how data is retrieved, processed or even bypass protections.\n\nTo protect against XPath injection, user input should be parameterized using a variable\nresolver.\nBy creating a class that implements the `XPathVariableResolver` the application can ensure\nthat\nthe xpath query and user-supplied input are treated separately.\n\nExample implementation of an XPathVariableResolver:\n```\n// Create a class which implements the XPathVariableResolver interface\npublic static class SimpleXPathVariableResolver implements XPathVariableResolver {\n  // Use a map or lookup table to store variables for resolution\n  private HashMap<QName, String> variables = new HashMap<>();\n  // Allow caller to set variables\n  public void setVariable(QName name, String value) {\n    variables.put(name, value);\n  }\n  // Implement the resolveVariable to return the value\n  @Override\n  public Object resolveVariable(QName name) {\n    return variables.getOrDefault(name, \"\");\n  }\n}\n\npublic static void xpathQuery(String userInput) throws ParseException,\nParserConfigurationException,\n  SAXException, IOException, XPathExpressionException {\n\n  // Create our DocumentFactory\n  DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n  // Enable namespace awareness\n  domFactory.setNamespaceAware(true);\n  // Enable secure processing\n  domFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n  // Create our DocumentBuilder\n  DocumentBuilder builder = domFactory.newDocumentBuilder();\n  // Parse our XML document\n  Document doc = builder.parse(\"inventory.xml\");\n\n  // Create a new instance of an XPath object\n  XPath xpathProcessor = XPathFactory.newInstance().newXPath();\n  // Create our XPathVariableResolver\n  SimpleXPathVariableResolver resolver = new SimpleXPathVariableResolver();\n  // Add user input as a variable value\n  resolver.setVariable(new QName(\"author\"), userInput);\n  // Configure the processor to use our variable resolver\n  xpathProcessor.setXPathVariableResolver(resolver);\n  // Evaluate the XPath query\n      String result = xpathProcessor.compile(\"//author[contains(., $author)]\").evaluate(doc);\n  // Work with the result\n  // ...\n}\n```\n\nFor more information on XPath Injection see:\n- https://owasp.org/www-community/attacks/XPATH_Injection\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XPATH_INJECTION-1)\n","text":"The application processes `XPath` queries with potentially malicious input.\nAn adversary who is able to control the XPath query could potentially influence the logic\nof how data is retrieved, processed or even bypass protections.\n\nTo protect against XPath injection, user input should be parameterized using a variable\nresolver.\nBy creating a class that implements the `XPathVariableResolver` the application can ensure\nthat\nthe xpath query and user-supplied input are treated separately.\n\nExample implementation of an XPathVariableResolver:\n```\n// Create a class which implements the XPathVariableResolver interface\npublic static class SimpleXPathVariableResolver implements XPathVariableResolver {\n  // Use a map or lookup table to store variables for resolution\n  private HashMap<QName, String> variables = new HashMap<>();\n  // Allow caller to set variables\n  public void setVariable(QName name, String value) {\n    variables.put(name, value);\n  }\n  // Implement the resolveVariable to return the value\n  @Override\n  public Object resolveVariable(QName name) {\n    return variables.getOrDefault(name, \"\");\n  }\n}\n\npublic static void xpathQuery(String userInput) throws ParseException,\nParserConfigurationException,\n  SAXException, IOException, XPathExpressionException {\n\n  // Create our DocumentFactory\n  DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n  // Enable namespace awareness\n  domFactory.setNamespaceAware(true);\n  // Enable secure processing\n  domFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n  // Create our DocumentBuilder\n  DocumentBuilder builder = domFactory.newDocumentBuilder();\n  // Parse our XML document\n  Document doc = builder.parse(\"inventory.xml\");\n\n  // Create a new instance of an XPath object\n  XPath xpathProcessor = XPathFactory.newInstance().newXPath();\n  // Create our XPathVariableResolver\n  SimpleXPathVariableResolver resolver = new SimpleXPathVariableResolver();\n  // Add user input as a variable value\n  resolver.setVariable(new QName(\"author\"), userInput);\n  // Configure the processor to use our variable resolver\n  xpathProcessor.setXPathVariableResolver(resolver);\n  // Evaluate the XPath query\n      String result = xpathProcessor.compile(\"//author[contains(., $author)]\").evaluate(doc);\n  // Work with the result\n  // ...\n}\n```\n\nFor more information on XPath Injection see:\n- https://owasp.org/www-community/attacks/XPATH_Injection\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XPATH_INJECTION-1","id":"gitlab.find_sec_bugs.XPATH_INJECTION-1","name":"gitlab.find_sec_bugs.XPATH_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-643","security"]},"shortDescription":{"text":"Improper neutralization of data within XPath expressions ('XPath Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application is returning user-supplied data from an HTTP request to an HTTP response's\n`sendError` method. This could lead to Cross Site Scripting (XSS) if the input were malicious\nscript code and the application server is not properly validating the output. Note that Apache\nTomcat 9 and above automatically encode the output and are not vulnerable.\n\nXSS is an attack which exploits a web application or system to treat user input\nas markup or script code. It is important to encode the data depending on the specific context\nit is used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input\nis ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as Javascript code. Care must also be\ntaken\nto not mix server-side templating with client-side templating, as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be\nencoded depending on context of where it is output. It is much safer to force the displaying\nsystem to\nhandle the encoding and not attempt to guess how it should be encoded.\n\nIf possible do not use user input directly in the output to the `sendError` message parameter.\n\nRegardless if the application server handles output encoding, consider encoding any\nuser-supplied\ninput\nthat is used in the sendError method:\n\nExample using [Apache Commons Text](https://commons.apache.org/proper/commons-text/)\n`StringEscapeUtils.escapeHtml4`:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the input using the Html4 encoder\nString encoded = StringEscapeUtils.escapeHtml4(userInput);\n// Respond with the error code and value\nresponse.sendError(401, encoded);\n```\n\nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n"},"help":{"markdown":"The application is returning user-supplied data from an HTTP request to an HTTP response's\n`sendError` method. This could lead to Cross Site Scripting (XSS) if the input were malicious\nscript code and the application server is not properly validating the output. Note that Apache\nTomcat 9 and above automatically encode the output and are not vulnerable.\n\nXSS is an attack which exploits a web application or system to treat user input\nas markup or script code. It is important to encode the data depending on the specific context\nit is used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input\nis ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as Javascript code. Care must also be\ntaken\nto not mix server-side templating with client-side templating, as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be\nencoded depending on context of where it is output. It is much safer to force the displaying\nsystem to\nhandle the encoding and not attempt to guess how it should be encoded.\n\nIf possible do not use user input directly in the output to the `sendError` message parameter.\n\nRegardless if the application server handles output encoding, consider encoding any\nuser-supplied\ninput\nthat is used in the sendError method:\n\nExample using [Apache Commons Text](https://commons.apache.org/proper/commons-text/)\n`StringEscapeUtils.escapeHtml4`:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the input using the Html4 encoder\nString encoded = StringEscapeUtils.escapeHtml4(userInput);\n// Respond with the error code and value\nresponse.sendError(401, encoded);\n```\n\nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SEND_ERROR-1)\n","text":"The application is returning user-supplied data from an HTTP request to an HTTP response's\n`sendError` method. This could lead to Cross Site Scripting (XSS) if the input were malicious\nscript code and the application server is not properly validating the output. Note that Apache\nTomcat 9 and above automatically encode the output and are not vulnerable.\n\nXSS is an attack which exploits a web application or system to treat user input\nas markup or script code. It is important to encode the data depending on the specific context\nit is used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input\nis ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as Javascript code. Care must also be\ntaken\nto not mix server-side templating with client-side templating, as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be\nencoded depending on context of where it is output. It is much safer to force the displaying\nsystem to\nhandle the encoding and not attempt to guess how it should be encoded.\n\nIf possible do not use user input directly in the output to the `sendError` message parameter.\n\nRegardless if the application server handles output encoding, consider encoding any\nuser-supplied\ninput\nthat is used in the sendError method:\n\nExample using [Apache Commons Text](https://commons.apache.org/proper/commons-text/)\n`StringEscapeUtils.escapeHtml4`:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the input using the Html4 encoder\nString encoded = StringEscapeUtils.escapeHtml4(userInput);\n// Respond with the error code and value\nresponse.sendError(401, encoded);\n```\n\nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SEND_ERROR-1","id":"gitlab.find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SEND_ERROR-1","name":"gitlab.find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SEND_ERROR-1","properties":{"precision":"very-high","tags":["CWE-79","security"]},"shortDescription":{"text":"Improper neutralization of input during web page generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application is returning user-supplied data from an HTTP request directly into an HTTP\nresponse output\nwriter. This could lead to Cross Site Scripting (XSS) if the input were malicious\nscript code and the application server is not properly validating the output.\n\nXSS is an attack which exploits a web application or system to treat user input\nas markup or script code. It is important to encode the data depending on the specific context\nit is used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input\nis ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as Javascript code. Care must also be\ntaken\nto not mix server-side templating with client-side templating, as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be\nencoded depending on context of where it is output. It is much safer to force the displaying\nsystem to\nhandle the encoding and not attempt to guess how it should be encoded.\n\nIf possible do not use user input directly in the output to the response writer.\n\nIf the application must output user-supplied input, it will need to encode the data depending\non\nthe output context.\n\nConsider using [Apache Commons Text](https://commons.apache.org/proper/commons-text/)\n`StringEscapeUtils` methods for various context. Please note there is no way to safely\noutput script code in most circumstances, regardless of encoding. If calling the HTTP\nresponse writer directly, ensure that the `Content-Type` is set to `text/plain` so it will\nnot be accidentally interpreted by HTML by modern browsers.\n```\n// Get user input\nString htmlInput = request.getParameter(\"userInput\");\n// Encode the input using the Html4 encoder\nString htmlEncoded = StringEscapeUtils.escapeHtml4(htmlInput);\n// Force the HTTP response to be content type of text/plain so it is not interpreted as HTML\nresponse.setContentType(\"text/plain\");\n// Ensure UTF-8\nresponse.setCharacterEncoding(\"UTF-8\");\n// Write response\nresponse.getWriter().write(htmlEncoded);\n```\n\nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n"},"help":{"markdown":"The application is returning user-supplied data from an HTTP request directly into an HTTP\nresponse output\nwriter. This could lead to Cross Site Scripting (XSS) if the input were malicious\nscript code and the application server is not properly validating the output.\n\nXSS is an attack which exploits a web application or system to treat user input\nas markup or script code. It is important to encode the data depending on the specific context\nit is used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input\nis ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as Javascript code. Care must also be\ntaken\nto not mix server-side templating with client-side templating, as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be\nencoded depending on context of where it is output. It is much safer to force the displaying\nsystem to\nhandle the encoding and not attempt to guess how it should be encoded.\n\nIf possible do not use user input directly in the output to the response writer.\n\nIf the application must output user-supplied input, it will need to encode the data depending\non\nthe output context.\n\nConsider using [Apache Commons Text](https://commons.apache.org/proper/commons-text/)\n`StringEscapeUtils` methods for various context. Please note there is no way to safely\noutput script code in most circumstances, regardless of encoding. If calling the HTTP\nresponse writer directly, ensure that the `Content-Type` is set to `text/plain` so it will\nnot be accidentally interpreted by HTML by modern browsers.\n```\n// Get user input\nString htmlInput = request.getParameter(\"userInput\");\n// Encode the input using the Html4 encoder\nString htmlEncoded = StringEscapeUtils.escapeHtml4(htmlInput);\n// Force the HTTP response to be content type of text/plain so it is not interpreted as HTML\nresponse.setContentType(\"text/plain\");\n// Ensure UTF-8\nresponse.setCharacterEncoding(\"UTF-8\");\n// Write response\nresponse.getWriter().write(htmlEncoded);\n```\n\nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1)\n","text":"The application is returning user-supplied data from an HTTP request directly into an HTTP\nresponse output\nwriter. This could lead to Cross Site Scripting (XSS) if the input were malicious\nscript code and the application server is not properly validating the output.\n\nXSS is an attack which exploits a web application or system to treat user input\nas markup or script code. It is important to encode the data depending on the specific context\nit is used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input\nis ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as Javascript code. Care must also be\ntaken\nto not mix server-side templating with client-side templating, as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be\nencoded depending on context of where it is output. It is much safer to force the displaying\nsystem to\nhandle the encoding and not attempt to guess how it should be encoded.\n\nIf possible do not use user input directly in the output to the response writer.\n\nIf the application must output user-supplied input, it will need to encode the data depending\non\nthe output context.\n\nConsider using [Apache Commons Text](https://commons.apache.org/proper/commons-text/)\n`StringEscapeUtils` methods for various context. Please note there is no way to safely\noutput script code in most circumstances, regardless of encoding. If calling the HTTP\nresponse writer directly, ensure that the `Content-Type` is set to `text/plain` so it will\nnot be accidentally interpreted by HTML by modern browsers.\n```\n// Get user input\nString htmlInput = request.getParameter(\"userInput\");\n// Encode the input using the Html4 encoder\nString htmlEncoded = StringEscapeUtils.escapeHtml4(htmlInput);\n// Force the HTTP response to be content type of text/plain so it is not interpreted as HTML\nresponse.setContentType(\"text/plain\");\n// Ensure UTF-8\nresponse.setCharacterEncoding(\"UTF-8\");\n// Write response\nresponse.getWriter().write(htmlEncoded);\n```\n\nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1","id":"gitlab.find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1","name":"gitlab.find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1","properties":{"precision":"very-high","tags":["CWE-79","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper neutralization of input during web page generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"note"},"fullDescription":{"text":"Avoid using custom XSS filtering. Please use standard sanitization functions.\n"},"help":{"markdown":"Avoid using custom XSS filtering. Please use standard sanitization functions.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_REQUEST_WRAPPER-1)\n","text":"Avoid using custom XSS filtering. Please use standard sanitization functions.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_REQUEST_WRAPPER-1","id":"gitlab.find_sec_bugs.XSS_REQUEST_WRAPPER-1","name":"gitlab.find_sec_bugs.XSS_REQUEST_WRAPPER-1","properties":{"precision":"very-high","tags":["CWE-79","security"]},"shortDescription":{"text":"Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A potential XSS was found. It could be used to execute unwanted JavaScript in a\nclient's browser.\n"},"help":{"markdown":"A potential XSS was found. It could be used to execute unwanted JavaScript in a\nclient's browser.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_SERVLET-1)\n","text":"A potential XSS was found. It could be used to execute unwanted JavaScript in a\nclient's browser.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_SERVLET-1","id":"gitlab.find_sec_bugs.XSS_SERVLET-1","name":"gitlab.find_sec_bugs.XSS_SERVLET-1","properties":{"precision":"very-high","tags":["CWE-79","security"]},"shortDescription":{"text":"Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The Servlet can read GET and POST parameters from various methods. The value obtained should be\nconsidered unsafe. You may need to validate or sanitize those values before passing them to\nsensitive APIs\n"},"help":{"markdown":"The Servlet can read GET and POST parameters from various methods. The value obtained should be\nconsidered unsafe. You may need to validate or sanitize those values before passing them to\nsensitive APIs\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_SERVLET-2.XSS_SERVLET_PARAMETER-1)\n","text":"The Servlet can read GET and POST parameters from various methods. The value obtained should be\nconsidered unsafe. You may need to validate or sanitize those values before passing them to\nsensitive APIs\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XSS_SERVLET-2.XSS_SERVLET_PARAMETER-1","id":"gitlab.find_sec_bugs.XSS_SERVLET-2.XSS_SERVLET_PARAMETER-1","name":"gitlab.find_sec_bugs.XSS_SERVLET-2.XSS_SERVLET_PARAMETER-1","properties":{"precision":"very-high","tags":["CWE-20","security"]},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1","id":"gitlab.find_sec_bugs.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1","name":"gitlab.find_sec_bugs.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1","properties":{"precision":"very-high","tags":["CWE-611","security"]},"shortDescription":{"text":"Improper Restriction of XML External Entity Reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"External XML entities are a feature of XML parsers that allow documents to contain references\nto\nother documents or data. This feature can be abused to read files, communicate with external\nhosts,\nexfiltrate data, or cause a Denial of Service (DoS).\n\nIt is recommended that the `SAXParser` is configured to disable DTD doctypes as this protects\nagainst the majority of XXE attacks.\n\nExample creating a SAXParser with disallowing the doctypes feature enabled:\n```\n// Create a SAXParserFactory\nSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n// Enable the feature which disallows <!DOCTYPE declarations which includes referencing\nexternal entities.\nsaxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n// Create a new parser from this factory\nSAXParser parser = saxParserFactory.newSAXParser();\n// Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve\nmethod)\nparser.parse(new FileInputStream(new File(\"bad.xml\")), new DefaultHandler());\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n"},"help":{"markdown":"External XML entities are a feature of XML parsers that allow documents to contain references\nto\nother documents or data. This feature can be abused to read files, communicate with external\nhosts,\nexfiltrate data, or cause a Denial of Service (DoS).\n\nIt is recommended that the `SAXParser` is configured to disable DTD doctypes as this protects\nagainst the majority of XXE attacks.\n\nExample creating a SAXParser with disallowing the doctypes feature enabled:\n```\n// Create a SAXParserFactory\nSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n// Enable the feature which disallows <!DOCTYPE declarations which includes referencing\nexternal entities.\nsaxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n// Create a new parser from this factory\nSAXParser parser = saxParserFactory.newSAXParser();\n// Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve\nmethod)\nparser.parse(new FileInputStream(new File(\"bad.xml\")), new DefaultHandler());\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_SAXPARSER-1)\n","text":"External XML entities are a feature of XML parsers that allow documents to contain references\nto\nother documents or data. This feature can be abused to read files, communicate with external\nhosts,\nexfiltrate data, or cause a Denial of Service (DoS).\n\nIt is recommended that the `SAXParser` is configured to disable DTD doctypes as this protects\nagainst the majority of XXE attacks.\n\nExample creating a SAXParser with disallowing the doctypes feature enabled:\n```\n// Create a SAXParserFactory\nSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n// Enable the feature which disallows <!DOCTYPE declarations which includes referencing\nexternal entities.\nsaxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n// Create a new parser from this factory\nSAXParser parser = saxParserFactory.newSAXParser();\n// Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve\nmethod)\nparser.parse(new FileInputStream(new File(\"bad.xml\")), new DefaultHandler());\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_SAXPARSER-1","id":"gitlab.find_sec_bugs.XXE_SAXPARSER-1","name":"gitlab.find_sec_bugs.XXE_SAXPARSER-1","properties":{"precision":"very-high","tags":["CWE-611","security"]},"shortDescription":{"text":"Improper restriction of XML external entity reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"External XML entities are a feature of XML parsers that allow documents to contain references\nto\nother documents or data. This feature can be abused to read files, communicate with external\nhosts,\nexfiltrate data, or cause a Denial of Service (DoS).\n\nThe XMLReaderFactory has been deprecated. It is recommended that\n[SAXParserFactory](https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/SAXParserFactory.html)\nbe used\ninstead. Additionally when using the SAXParser it must be configured to disallow doctypes,\nwhich will\nprotect against the majority of XXE attacks.\n\nExample creating a SAXParser with disallowing the doctypes feature enabled:\n```\n// Create a SAXParserFactory\nSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n// Enable the feature which disallows <!DOCTYPE declarations which includes referencing\nexternal entities.\nsaxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n// Create a new parser from this factory\nSAXParser parser = saxParserFactory.newSAXParser();\n// Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve\nmethod)\nparser.parse(new FileInputStream(new File(\"bad.xml\")), new DefaultHandler());\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n"},"help":{"markdown":"External XML entities are a feature of XML parsers that allow documents to contain references\nto\nother documents or data. This feature can be abused to read files, communicate with external\nhosts,\nexfiltrate data, or cause a Denial of Service (DoS).\n\nThe XMLReaderFactory has been deprecated. It is recommended that\n[SAXParserFactory](https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/SAXParserFactory.html)\nbe used\ninstead. Additionally when using the SAXParser it must be configured to disallow doctypes,\nwhich will\nprotect against the majority of XXE attacks.\n\nExample creating a SAXParser with disallowing the doctypes feature enabled:\n```\n// Create a SAXParserFactory\nSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n// Enable the feature which disallows <!DOCTYPE declarations which includes referencing\nexternal entities.\nsaxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n// Create a new parser from this factory\nSAXParser parser = saxParserFactory.newSAXParser();\n// Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve\nmethod)\nparser.parse(new FileInputStream(new File(\"bad.xml\")), new DefaultHandler());\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_XMLREADER-1)\n","text":"External XML entities are a feature of XML parsers that allow documents to contain references\nto\nother documents or data. This feature can be abused to read files, communicate with external\nhosts,\nexfiltrate data, or cause a Denial of Service (DoS).\n\nThe XMLReaderFactory has been deprecated. It is recommended that\n[SAXParserFactory](https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/SAXParserFactory.html)\nbe used\ninstead. Additionally when using the SAXParser it must be configured to disallow doctypes,\nwhich will\nprotect against the majority of XXE attacks.\n\nExample creating a SAXParser with disallowing the doctypes feature enabled:\n```\n// Create a SAXParserFactory\nSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n// Enable the feature which disallows <!DOCTYPE declarations which includes referencing\nexternal entities.\nsaxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n// Create a new parser from this factory\nSAXParser parser = saxParserFactory.newSAXParser();\n// Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve\nmethod)\nparser.parse(new FileInputStream(new File(\"bad.xml\")), new DefaultHandler());\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_XMLREADER-1","id":"gitlab.find_sec_bugs.XXE_XMLREADER-1","name":"gitlab.find_sec_bugs.XXE_XMLREADER-1","properties":{"precision":"very-high","tags":["CWE-611","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper restriction of XML external entity reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"External XML entities are a feature of XML parsers that allow documents to contain references\nto\nother documents or data. This feature can be abused to read files, communicate with external\nhosts,\nexfiltrate data, or cause a Denial of Service (DoS).\n\nIn most XML parsers, the recommendation to protect against XXE is to disable the doctype\nfeature.\nUnfortunately use of the `XMLInputFactory` requires that the doctypes feature be enabled.\nInstead\nthe application can set the `ACCESS_EXTERNAL_DTD` to an empty string and disable\n`javax.xml.stream.isSupportingExternalEntities`.\n\n\nCreates an `XMLInputFactory` stream parser, but disables accessing external DTD or entities:\n```\n// Create an XMLInputFactory\nXMLInputFactory factory = XMLInputFactory.newFactory();\n// Set the ACCESS_EXTERNAL_DTD property to an empty string so it won't access\n// entities using protocols\n// (ref:\nhttps://docs.oracle.com/javase/8/docs/api/javax/xml/XMLConstants.html#ACCESS_EXTERNAL_DTD)\nfactory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n// Additionally, disable support for resolving external entities\nfactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n// Continue to work with the factory/stream parser\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n"},"help":{"markdown":"External XML entities are a feature of XML parsers that allow documents to contain references\nto\nother documents or data. This feature can be abused to read files, communicate with external\nhosts,\nexfiltrate data, or cause a Denial of Service (DoS).\n\nIn most XML parsers, the recommendation to protect against XXE is to disable the doctype\nfeature.\nUnfortunately use of the `XMLInputFactory` requires that the doctypes feature be enabled.\nInstead\nthe application can set the `ACCESS_EXTERNAL_DTD` to an empty string and disable\n`javax.xml.stream.isSupportingExternalEntities`.\n\n\nCreates an `XMLInputFactory` stream parser, but disables accessing external DTD or entities:\n```\n// Create an XMLInputFactory\nXMLInputFactory factory = XMLInputFactory.newFactory();\n// Set the ACCESS_EXTERNAL_DTD property to an empty string so it won't access\n// entities using protocols\n// (ref:\nhttps://docs.oracle.com/javase/8/docs/api/javax/xml/XMLConstants.html#ACCESS_EXTERNAL_DTD)\nfactory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n// Additionally, disable support for resolving external entities\nfactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n// Continue to work with the factory/stream parser\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_XMLSTREAMREADER-1)\n","text":"External XML entities are a feature of XML parsers that allow documents to contain references\nto\nother documents or data. This feature can be abused to read files, communicate with external\nhosts,\nexfiltrate data, or cause a Denial of Service (DoS).\n\nIn most XML parsers, the recommendation to protect against XXE is to disable the doctype\nfeature.\nUnfortunately use of the `XMLInputFactory` requires that the doctypes feature be enabled.\nInstead\nthe application can set the `ACCESS_EXTERNAL_DTD` to an empty string and disable\n`javax.xml.stream.isSupportingExternalEntities`.\n\n\nCreates an `XMLInputFactory` stream parser, but disables accessing external DTD or entities:\n```\n// Create an XMLInputFactory\nXMLInputFactory factory = XMLInputFactory.newFactory();\n// Set the ACCESS_EXTERNAL_DTD property to an empty string so it won't access\n// entities using protocols\n// (ref:\nhttps://docs.oracle.com/javase/8/docs/api/javax/xml/XMLConstants.html#ACCESS_EXTERNAL_DTD)\nfactory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n// Additionally, disable support for resolving external entities\nfactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n// Continue to work with the factory/stream parser\n```\n\nFor more information on XML security see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_XMLSTREAMREADER-1","id":"gitlab.find_sec_bugs.XXE_XMLSTREAMREADER-1","name":"gitlab.find_sec_bugs.XXE_XMLSTREAMREADER-1","properties":{"precision":"very-high","tags":["CWE-611","security"]},"shortDescription":{"text":"Improper restriction of XML external entity reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_XPATH-1.XXE_DOCUMENT-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs.XXE_XPATH-1.XXE_DOCUMENT-1","id":"gitlab.find_sec_bugs.XXE_XPATH-1.XXE_DOCUMENT-1","name":"gitlab.find_sec_bugs.XXE_XPATH-1.XXE_DOCUMENT-1","properties":{"precision":"very-high","tags":["CWE-611","security"]},"shortDescription":{"text":"Improper Restriction of XML External Entity Reference ('XXE')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"When converting a byte array containing a hash signature to a human readable string, a\nconversion mistake can be made if the array is read byte by byte.\n"},"help":{"markdown":"When converting a byte array containing a hash signature to a human readable string, a\nconversion mistake can be made if the array is read byte by byte.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.BAD_HEXA_CONVERSION-1)\n","text":"When converting a byte array containing a hash signature to a human readable string, a\nconversion mistake can be made if the array is read byte by byte.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.BAD_HEXA_CONVERSION-1","id":"gitlab.find_sec_bugs_kotlin.BAD_HEXA_CONVERSION-1","name":"gitlab.find_sec_bugs_kotlin.BAD_HEXA_CONVERSION-1","properties":{"precision":"very-high","tags":["CWE-704","HIGH CONFIDENCE","OWASP-A05:2021-Security Misconfiguration","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Incorrect type conversion or cast"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A small key size makes the ciphertext vulnerable to brute force attacks. At least 128 bits of\nentropy should be used when generating the key if use of Blowfish is required.\n"},"help":{"markdown":"A small key size makes the ciphertext vulnerable to brute force attacks. At least 128 bits of\nentropy should be used when generating the key if use of Blowfish is required.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.BLOWFISH_KEY_SIZE-1)\n","text":"A small key size makes the ciphertext vulnerable to brute force attacks. At least 128 bits of\nentropy should be used when generating the key if use of Blowfish is required.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.BLOWFISH_KEY_SIZE-1","id":"gitlab.find_sec_bugs_kotlin.BLOWFISH_KEY_SIZE-1","name":"gitlab.find_sec_bugs_kotlin.BLOWFISH_KEY_SIZE-1","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The ciphertext produced is susceptible to alteration by an adversary. This mean that the\ncipher provides no way to detect that the data has been tampered with. If the ciphertext can be\ncontrolled by an attacker, it could be altered without detection.\n"},"help":{"markdown":"The ciphertext produced is susceptible to alteration by an adversary. This mean that the\ncipher provides no way to detect that the data has been tampered with. If the ciphertext can be\ncontrolled by an attacker, it could be altered without detection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.CIPHER_INTEGRITY-1)\n","text":"The ciphertext produced is susceptible to alteration by an adversary. This mean that the\ncipher provides no way to detect that the data has been tampered with. If the ciphertext can be\ncontrolled by an attacker, it could be altered without detection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.CIPHER_INTEGRITY-1","id":"gitlab.find_sec_bugs_kotlin.CIPHER_INTEGRITY-1","name":"gitlab.find_sec_bugs_kotlin.CIPHER_INTEGRITY-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The highlighted API is used to execute a system command. If unfiltered input is passed to this\nAPI, it can lead to arbitrary command execution.\n"},"help":{"markdown":"The highlighted API is used to execute a system command. If unfiltered input is passed to this\nAPI, it can lead to arbitrary command execution.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.COMMAND_INJECTION-1)\n","text":"The highlighted API is used to execute a system command. If unfiltered input is passed to this\nAPI, it can lead to arbitrary command execution.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.COMMAND_INJECTION-1","id":"gitlab.find_sec_bugs_kotlin.COMMAND_INJECTION-1","name":"gitlab.find_sec_bugs_kotlin.COMMAND_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-78","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper neutralization of special elements used in an OS command ('OS Command Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Implementing a custom MessageDigest is error-prone. National Institute of Standards and\nTechnology(NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\nSHA-512/256.\n"},"help":{"markdown":"Implementing a custom MessageDigest is error-prone. National Institute of Standards and\nTechnology(NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\nSHA-512/256.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.CUSTOM_MESSAGE_DIGEST-1)\n","text":"Implementing a custom MessageDigest is error-prone. National Institute of Standards and\nTechnology(NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\nSHA-512/256.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.CUSTOM_MESSAGE_DIGEST-1","id":"gitlab.find_sec_bugs_kotlin.CUSTOM_MESSAGE_DIGEST-1","name":"gitlab.find_sec_bugs_kotlin.CUSTOM_MESSAGE_DIGEST-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A04:2021-Insecure Design","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Do not grant dangerous combinations of permissions.\n"},"help":{"markdown":"Do not grant dangerous combinations of permissions.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.DANGEROUS_PERMISSION_COMBINATION-1)\n","text":"Do not grant dangerous combinations of permissions.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.DANGEROUS_PERMISSION_COMBINATION-1","id":"gitlab.find_sec_bugs_kotlin.DANGEROUS_PERMISSION_COMBINATION-1","name":"gitlab.find_sec_bugs_kotlin.DANGEROUS_PERMISSION_COMBINATION-1","properties":{"precision":"very-high","tags":["CWE-269","HIGH CONFIDENCE","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper privilege management"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n"},"help":{"markdown":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.DES_USAGE-1)\n","text":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.DES_USAGE-1","id":"gitlab.find_sec_bugs_kotlin.DES_USAGE-1","name":"gitlab.find_sec_bugs_kotlin.DES_USAGE-1","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"help":{"markdown":"A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3)\n","text":"A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3","id":"gitlab.find_sec_bugs_kotlin.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3","name":"gitlab.find_sec_bugs_kotlin.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3","properties":{"precision":"very-high","tags":["CWE-259","OWASP-A07:2021-Identification and Authentication Failures","OWASP-A2:2017-Broken Authentication","security"],"security-severity":"Critical"},"shortDescription":{"text":"Use of hard-coded password"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"help":{"markdown":"The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2)\n","text":"The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2","id":"gitlab.find_sec_bugs_kotlin.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2","name":"gitlab.find_sec_bugs_kotlin.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2","properties":{"precision":"very-high","tags":["CWE-306","OWASP-A07:2021-Identification and Authentication Failures","OWASP-A2:2017-Broken Authentication","security"],"security-severity":"Critical"},"shortDescription":{"text":"Missing authentication for critical function (database)"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"An authentication cipher mode which provides better confidentiality of the encrypted data\nshould be used instead of Electronic Code Book (ECB) mode, which does not provide good\nconfidentiality. Specifically, ECB mode produces the same output for the same input each time.\nThis allows an attacker to intercept and replay the data.\n"},"help":{"markdown":"An authentication cipher mode which provides better confidentiality of the encrypted data\nshould be used instead of Electronic Code Book (ECB) mode, which does not provide good\nconfidentiality. Specifically, ECB mode produces the same output for the same input each time.\nThis allows an attacker to intercept and replay the data.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.ECB_MODE-1)\n","text":"An authentication cipher mode which provides better confidentiality of the encrypted data\nshould be used instead of Electronic Code Book (ECB) mode, which does not provide good\nconfidentiality. Specifically, ECB mode produces the same output for the same input each time.\nThis allows an attacker to intercept and replay the data.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.ECB_MODE-1","id":"gitlab.find_sec_bugs_kotlin.ECB_MODE-1","name":"gitlab.find_sec_bugs_kotlin.ECB_MODE-1","properties":{"precision":"very-high","tags":["CWE-326","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Inadequate Encryption Strength"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"An expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\n"},"help":{"markdown":"An expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.EL_INJECTION-1)\n","text":"An expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.EL_INJECTION-1","id":"gitlab.find_sec_bugs_kotlin.EL_INJECTION-1","name":"gitlab.find_sec_bugs_kotlin.EL_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-917","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper neutralization of special elements used in an expression language statement ('Expression Language Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Allowing external control of system settings can disrupt service or cause an application to\nbehave in unexpected, and potentially malicious ways. An attacker could cause an error by\nproviding a nonexistent catalog name or connect to an unauthorized portion of the database.\n"},"help":{"markdown":"Allowing external control of system settings can disrupt service or cause an application to\nbehave in unexpected, and potentially malicious ways. An attacker could cause an error by\nproviding a nonexistent catalog name or connect to an unauthorized portion of the database.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.EXTERNAL_CONFIG_CONTROL-1)\n","text":"Allowing external control of system settings can disrupt service or cause an application to\nbehave in unexpected, and potentially malicious ways. An attacker could cause an error by\nproviding a nonexistent catalog name or connect to an unauthorized portion of the database.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.EXTERNAL_CONFIG_CONTROL-1","id":"gitlab.find_sec_bugs_kotlin.EXTERNAL_CONFIG_CONTROL-1","name":"gitlab.find_sec_bugs_kotlin.EXTERNAL_CONFIG_CONTROL-1","properties":{"precision":"very-high","tags":["CWE-15","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"External control of system or configuration setting"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The filename provided by the FileUpload API can be tampered with by the client to reference\nunauthorized files. The provided filename should be properly validated to ensure it's properly\nstructured, contains no unauthorized path characters (e.g., / \\), and refers to an authorized\nfile.\n"},"help":{"markdown":"The filename provided by the FileUpload API can be tampered with by the client to reference\nunauthorized files. The provided filename should be properly validated to ensure it's properly\nstructured, contains no unauthorized path characters (e.g., / \\), and refers to an authorized\nfile.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.FILE_UPLOAD_FILENAME-1)\n","text":"The filename provided by the FileUpload API can be tampered with by the client to reference\nunauthorized files. The provided filename should be properly validated to ensure it's properly\nstructured, contains no unauthorized path characters (e.g., / \\), and refers to an authorized\nfile.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.FILE_UPLOAD_FILENAME-1","id":"gitlab.find_sec_bugs_kotlin.FILE_UPLOAD_FILENAME-1","name":"gitlab.find_sec_bugs_kotlin.FILE_UPLOAD_FILENAME-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Allowing user input to control format parameters could enable an attacker to cause exceptions\nto be thrown or leak information.Attackers may be able  to modify the format string argument,\nsuch that an exception is thrown. If this exception is left uncaught, it may crash the\napplication. Alternatively, if sensitive information is used within the unused arguments,\nattackers may change the format string to reveal this information.\n"},"help":{"markdown":"Allowing user input to control format parameters could enable an attacker to cause exceptions\nto be thrown or leak information.Attackers may be able  to modify the format string argument,\nsuch that an exception is thrown. If this exception is left uncaught, it may crash the\napplication. Alternatively, if sensitive information is used within the unused arguments,\nattackers may change the format string to reveal this information.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.FORMAT_STRING_MANIPULATION-1)\n","text":"Allowing user input to control format parameters could enable an attacker to cause exceptions\nto be thrown or leak information.Attackers may be able  to modify the format string argument,\nsuch that an exception is thrown. If this exception is left uncaught, it may crash the\napplication. Alternatively, if sensitive information is used within the unused arguments,\nattackers may change the format string to reveal this information.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.FORMAT_STRING_MANIPULATION-1","id":"gitlab.find_sec_bugs_kotlin.FORMAT_STRING_MANIPULATION-1","name":"gitlab.find_sec_bugs_kotlin.FORMAT_STRING_MANIPULATION-1","properties":{"precision":"very-high","tags":["CWE-134","HIGH CONFIDENCE","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Use of externally-controlled format string"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A potential hard-coded password was identified in the source code.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"help":{"markdown":"A potential hard-coded password was identified in the source code.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HARD_CODE_PASSWORD-1)\n","text":"A potential hard-coded password was identified in the source code.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HARD_CODE_PASSWORD-1","id":"gitlab.find_sec_bugs_kotlin.HARD_CODE_PASSWORD-1","name":"gitlab.find_sec_bugs_kotlin.HARD_CODE_PASSWORD-1","properties":{"precision":"very-high","tags":["CWE-259","OWASP-A07:2021-Identification and Authentication Failures","OWASP-A2:2017-Broken Authentication","security"],"security-severity":"High"},"shortDescription":{"text":"Use of hard-coded password"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The network communications for Hazelcast is configured to use a symmetric cipher (probably DES\nor Blowfish). Those ciphers alone do not provide integrity or secure authentication. The use of\nasymmetric encryption is preferred.\n"},"help":{"markdown":"The network communications for Hazelcast is configured to use a symmetric cipher (probably DES\nor Blowfish). Those ciphers alone do not provide integrity or secure authentication. The use of\nasymmetric encryption is preferred.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HAZELCAST_SYMMETRIC_ENCRYPTION-1)\n","text":"The network communications for Hazelcast is configured to use a symmetric cipher (probably DES\nor Blowfish). Those ciphers alone do not provide integrity or secure authentication. The use of\nasymmetric encryption is preferred.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HAZELCAST_SYMMETRIC_ENCRYPTION-1","id":"gitlab.find_sec_bugs_kotlin.HAZELCAST_SYMMETRIC_ENCRYPTION-1","name":"gitlab.find_sec_bugs_kotlin.HAZELCAST_SYMMETRIC_ENCRYPTION-1","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"This code directly writes an HTTP parameter to an HTTP header, which allows for a HTTP\nresponse splitting vulnerability. See http://en.wikipedia.org/wiki/HTTP_response_splitting for\nmore information.\n"},"help":{"markdown":"This code directly writes an HTTP parameter to an HTTP header, which allows for a HTTP\nresponse splitting vulnerability. See http://en.wikipedia.org/wiki/HTTP_response_splitting for\nmore information.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1)\n","text":"This code directly writes an HTTP parameter to an HTTP header, which allows for a HTTP\nresponse splitting vulnerability. See http://en.wikipedia.org/wiki/HTTP_response_splitting for\nmore information.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1","id":"gitlab.find_sec_bugs_kotlin.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1","name":"gitlab.find_sec_bugs_kotlin.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1","properties":{"precision":"very-high","tags":["CWE-113","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper neutralization of CRLF sequences in HTTP headers ('HTTP Response Splitting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A new cookie is created without the HttpOnly flag set. The HttpOnly flag is a directive to the\nbrowser to make sure that the cookie can not be red by malicious script. When a user is the\ntarget of a \"Cross-Site Scripting\", the attacker would benefit greatly from getting the session\nid for example.\n"},"help":{"markdown":"A new cookie is created without the HttpOnly flag set. The HttpOnly flag is a directive to the\nbrowser to make sure that the cookie can not be red by malicious script. When a user is the\ntarget of a \"Cross-Site Scripting\", the attacker would benefit greatly from getting the session\nid for example.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HTTPONLY_COOKIE-1)\n","text":"A new cookie is created without the HttpOnly flag set. The HttpOnly flag is a directive to the\nbrowser to make sure that the cookie can not be red by malicious script. When a user is the\ntarget of a \"Cross-Site Scripting\", the attacker would benefit greatly from getting the session\nid for example.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HTTPONLY_COOKIE-1","id":"gitlab.find_sec_bugs_kotlin.HTTPONLY_COOKIE-1","name":"gitlab.find_sec_bugs_kotlin.HTTPONLY_COOKIE-1","properties":{"precision":"very-high","tags":["CWE-1004","OWASP-A05:2021-Security Misconfiguration","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Sensitive cookie without 'HttpOnly' flag"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Concatenating unvalidated user input into a URL can allow an attacker to override the value of\na request parameter. Attacker may be able to override existing parameter values, inject a new\nparameter or exploit variables out of a direct reach. HTTP Parameter Pollution (HPP) attacks\nconsist of injecting encoded query string delimiters into other existing parameters. If a web\napplication does not properly sanitize the user input, a malicious user may compromise the\nlogic of the application to perform either client-side or server-side attacks.\n"},"help":{"markdown":"Concatenating unvalidated user input into a URL can allow an attacker to override the value of\na request parameter. Attacker may be able to override existing parameter values, inject a new\nparameter or exploit variables out of a direct reach. HTTP Parameter Pollution (HPP) attacks\nconsist of injecting encoded query string delimiters into other existing parameters. If a web\napplication does not properly sanitize the user input, a malicious user may compromise the\nlogic of the application to perform either client-side or server-side attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HTTP_PARAMETER_POLLUTION-1)\n","text":"Concatenating unvalidated user input into a URL can allow an attacker to override the value of\na request parameter. Attacker may be able to override existing parameter values, inject a new\nparameter or exploit variables out of a direct reach. HTTP Parameter Pollution (HPP) attacks\nconsist of injecting encoded query string delimiters into other existing parameters. If a web\napplication does not properly sanitize the user input, a malicious user may compromise the\nlogic of the application to perform either client-side or server-side attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HTTP_PARAMETER_POLLUTION-1","id":"gitlab.find_sec_bugs_kotlin.HTTP_PARAMETER_POLLUTION-1","name":"gitlab.find_sec_bugs_kotlin.HTTP_PARAMETER_POLLUTION-1","properties":{"precision":"very-high","tags":["CWE-88","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper neutralization of argument delimiters in a command ('Argument Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"When an HTTP request contains unexpected CR and LF characters, the server may respond with an\noutput stream that is interpreted as two different HTTP responses (instead of one). An attacker\ncan control the second response and mount attacks such as cross-site scripting and cache\npoisoning attacks.\n"},"help":{"markdown":"When an HTTP request contains unexpected CR and LF characters, the server may respond with an\noutput stream that is interpreted as two different HTTP responses (instead of one). An attacker\ncan control the second response and mount attacks such as cross-site scripting and cache\npoisoning attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HTTP_RESPONSE_SPLITTING-1)\n","text":"When an HTTP request contains unexpected CR and LF characters, the server may respond with an\noutput stream that is interpreted as two different HTTP responses (instead of one). An attacker\ncan control the second response and mount attacks such as cross-site scripting and cache\npoisoning attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.HTTP_RESPONSE_SPLITTING-1","id":"gitlab.find_sec_bugs_kotlin.HTTP_RESPONSE_SPLITTING-1","name":"gitlab.find_sec_bugs_kotlin.HTTP_RESPONSE_SPLITTING-1","properties":{"precision":"very-high","tags":["CWE-113","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper neutralization of CRLF sequences in HTTP headers ('HTTP Response Splitting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"\"A new cookie is created without the Secure flag set. The Secure flag is a\n directive to the browser to make sure that the cookie is not sent for insecure communication\n(http://)\"\n"},"help":{"markdown":"\"A new cookie is created without the Secure flag set. The Secure flag is a\n directive to the browser to make sure that the cookie is not sent for insecure communication\n(http://)\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.INSECURE_COOKIE-1)\n","text":"\"A new cookie is created without the Secure flag set. The Secure flag is a\n directive to the browser to make sure that the cookie is not sent for insecure communication\n(http://)\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.INSECURE_COOKIE-1","id":"gitlab.find_sec_bugs_kotlin.INSECURE_COOKIE-1","name":"gitlab.find_sec_bugs_kotlin.INSECURE_COOKIE-1","properties":{"precision":"very-high","tags":["CWE-614","OWASP-A05:2021-Security Misconfiguration","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Sensitive cookie in HTTPS session without 'Secure' attribute"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Server identity verification is disabled when making SSL connections.\n"},"help":{"markdown":"Server identity verification is disabled when making SSL connections.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.INSECURE_SMTP_SSL-1)\n","text":"Server identity verification is disabled when making SSL connections.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.INSECURE_SMTP_SSL-1","id":"gitlab.find_sec_bugs_kotlin.INSECURE_SMTP_SSL-1","name":"gitlab.find_sec_bugs_kotlin.INSECURE_SMTP_SSL-1","properties":{"precision":"very-high","tags":["CWE-297","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper validation of certificate with host mismatch"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n"},"help":{"markdown":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.LDAP_ANONYMOUS-1)\n","text":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.LDAP_ANONYMOUS-1","id":"gitlab.find_sec_bugs_kotlin.LDAP_ANONYMOUS-1","name":"gitlab.find_sec_bugs_kotlin.LDAP_ANONYMOUS-1","properties":{"precision":"very-high","tags":["CWE-306","OWASP-A07:2021-Identification and Authentication Failures","OWASP-A2:2017-Broken Authentication","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Missing authentication for critical function (LDAP)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Just like SQL, all inputs passed to an LDAP query need to be passed in safely. Unfortunately,\nLDAP doesn't have prepared statement interfaces like SQL. Therefore, the primary defense\nagainst LDAP injection is strong input validation of any untrusted data before including it in\nan LDAP query.\n"},"help":{"markdown":"Just like SQL, all inputs passed to an LDAP query need to be passed in safely. Unfortunately,\nLDAP doesn't have prepared statement interfaces like SQL. Therefore, the primary defense\nagainst LDAP injection is strong input validation of any untrusted data before including it in\nan LDAP query.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.LDAP_INJECTION-1)\n","text":"Just like SQL, all inputs passed to an LDAP query need to be passed in safely. Unfortunately,\nLDAP doesn't have prepared statement interfaces like SQL. Therefore, the primary defense\nagainst LDAP injection is strong input validation of any untrusted data before including it in\nan LDAP query.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.LDAP_INJECTION-1","id":"gitlab.find_sec_bugs_kotlin.LDAP_INJECTION-1","name":"gitlab.find_sec_bugs_kotlin.LDAP_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-90","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper neutralization of special elements used in an LDAP query ('LDAP Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"It is possible to attach malicious behavior to those style sheets. Therefore, if an attacker\ncan control the content or the source of the style sheet, he might be able to trigger remote\ncode execution.\n"},"help":{"markdown":"It is possible to attach malicious behavior to those style sheets. Therefore, if an attacker\ncan control the content or the source of the style sheet, he might be able to trigger remote\ncode execution.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.MALICIOUS_XSLT-1)\n","text":"It is possible to attach malicious behavior to those style sheets. Therefore, if an attacker\ncan control the content or the source of the style sheet, he might be able to trigger remote\ncode execution.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.MALICIOUS_XSLT-1","id":"gitlab.find_sec_bugs_kotlin.MALICIOUS_XSLT-1","name":"gitlab.find_sec_bugs_kotlin.MALICIOUS_XSLT-1","properties":{"precision":"very-high","tags":["CWE-74","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper neutralization of special elements in output used by a downstream component ('Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"CERT: IDS11-J. Perform any string modifications before validation\n"},"help":{"markdown":"CERT: IDS11-J. Perform any string modifications before validation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.MODIFICATION_AFTER_VALIDATION-1)\n","text":"CERT: IDS11-J. Perform any string modifications before validation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.MODIFICATION_AFTER_VALIDATION-1","id":"gitlab.find_sec_bugs_kotlin.MODIFICATION_AFTER_VALIDATION-1","name":"gitlab.find_sec_bugs_kotlin.MODIFICATION_AFTER_VALIDATION-1","properties":{"precision":"very-high","tags":["CWE-182","HIGH CONFIDENCE","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Collapse of data into unsafe value"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"IDS01-J. Normalize strings before validating them\n"},"help":{"markdown":"IDS01-J. Normalize strings before validating them\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.NORMALIZATION_AFTER_VALIDATION-1)\n","text":"IDS01-J. Normalize strings before validating them\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.NORMALIZATION_AFTER_VALIDATION-1","id":"gitlab.find_sec_bugs_kotlin.NORMALIZATION_AFTER_VALIDATION-1","name":"gitlab.find_sec_bugs_kotlin.NORMALIZATION_AFTER_VALIDATION-1","properties":{"precision":"very-high","tags":["CWE-180","HIGH CONFIDENCE","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Incorrect behavior order: validate before canonicalize"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The NullCipher implements the Cipher interface by returning ciphertext identical to the\nsupplied plaintext. In a few contexts, such as testing, a NullCipher may be appropriate. Avoid\nusing the NullCipher. Its accidental use can introduce a significant confidentiality risk.\n"},"help":{"markdown":"The NullCipher implements the Cipher interface by returning ciphertext identical to the\nsupplied plaintext. In a few contexts, such as testing, a NullCipher may be appropriate. Avoid\nusing the NullCipher. Its accidental use can introduce a significant confidentiality risk.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.NULL_CIPHER-1)\n","text":"The NullCipher implements the Cipher interface by returning ciphertext identical to the\nsupplied plaintext. In a few contexts, such as testing, a NullCipher may be appropriate. Avoid\nusing the NullCipher. Its accidental use can introduce a significant confidentiality risk.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.NULL_CIPHER-1","id":"gitlab.find_sec_bugs_kotlin.NULL_CIPHER-1","name":"gitlab.find_sec_bugs_kotlin.NULL_CIPHER-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"\"A expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\"\n"},"help":{"markdown":"\"A expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.OGNL_INJECTION-1)\n","text":"\"A expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.OGNL_INJECTION-1","id":"gitlab.find_sec_bugs_kotlin.OGNL_INJECTION-1","name":"gitlab.find_sec_bugs_kotlin.OGNL_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-917","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Expression injection (OGNL)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Overly permissive file permission\n"},"help":{"markdown":"Overly permissive file permission\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.OVERLY_PERMISSIVE_FILE_PERMISSION-1)\n","text":"Overly permissive file permission\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.OVERLY_PERMISSIVE_FILE_PERMISSION-1","id":"gitlab.find_sec_bugs_kotlin.OVERLY_PERMISSIVE_FILE_PERMISSION-1","name":"gitlab.find_sec_bugs_kotlin.OVERLY_PERMISSIVE_FILE_PERMISSION-1","properties":{"precision":"very-high","tags":["CWE-732","HIGH CONFIDENCE","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Incorrect permission assignment for critical resource"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An\nadversary could potentially decrypt the message if the system exposed the difference between\nplaintext with invalid padding or valid padding. The distinction between valid and invalid\npadding is usually revealed through distinct error messages being returned for each condition.\n"},"help":{"markdown":"This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An\nadversary could potentially decrypt the message if the system exposed the difference between\nplaintext with invalid padding or valid padding. The distinction between valid and invalid\npadding is usually revealed through distinct error messages being returned for each condition.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.PADDING_ORACLE-1)\n","text":"This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An\nadversary could potentially decrypt the message if the system exposed the difference between\nplaintext with invalid padding or valid padding. The distinction between valid and invalid\npadding is usually revealed through distinct error messages being returned for each condition.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.PADDING_ORACLE-1","id":"gitlab.find_sec_bugs_kotlin.PADDING_ORACLE-1","name":"gitlab.find_sec_bugs_kotlin.PADDING_ORACLE-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n"},"help":{"markdown":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.PERMISSIVE_CORS-2)\n","text":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.PERMISSIVE_CORS-2","id":"gitlab.find_sec_bugs_kotlin.PERMISSIVE_CORS-2","name":"gitlab.find_sec_bugs_kotlin.PERMISSIVE_CORS-2","properties":{"precision":"very-high","tags":["CWE-942","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Permissive cross-domain policy with untrusted domains"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize absolute path sequences such as\n\"/abs/path\" that can resolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/36.html for more information.\n"},"help":{"markdown":"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize absolute path sequences such as\n\"/abs/path\" that can resolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/36.html for more information.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.PT_ABSOLUTE_PATH_TRAVERSAL-1)\n","text":"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize absolute path sequences such as\n\"/abs/path\" that can resolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/36.html for more information.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.PT_ABSOLUTE_PATH_TRAVERSAL-1","id":"gitlab.find_sec_bugs_kotlin.PT_ABSOLUTE_PATH_TRAVERSAL-1","name":"gitlab.find_sec_bugs_kotlin.PT_ABSOLUTE_PATH_TRAVERSAL-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Constructing a server-side redirect path with user input could allow an\nattacker to download application binaries (including application classes or\njar files) or view arbitrary files within protected directories.\n"},"help":{"markdown":"Constructing a server-side redirect path with user input could allow an\nattacker to download application binaries (including application classes or\njar files) or view arbitrary files within protected directories.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1)\n","text":"Constructing a server-side redirect path with user input could allow an\nattacker to download application binaries (including application classes or\njar files) or view arbitrary files within protected directories.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1","id":"gitlab.find_sec_bugs_kotlin.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1","name":"gitlab.find_sec_bugs_kotlin.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1","properties":{"precision":"very-high","tags":["CWE-552","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Files or directories accessible to external parties"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Detected an insufficient key size for DSA. NIST recommends a key size\nof 2048 or higher.\n"},"help":{"markdown":"Detected an insufficient key size for DSA. NIST recommends a key size\nof 2048 or higher.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.RSA_KEY_SIZE-1)\n","text":"Detected an insufficient key size for DSA. NIST recommends a key size\nof 2048 or higher.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.RSA_KEY_SIZE-1","id":"gitlab.find_sec_bugs_kotlin.RSA_KEY_SIZE-1","name":"gitlab.find_sec_bugs_kotlin.RSA_KEY_SIZE-1","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The software uses the RSA algorithm but does not incorporate Optimal Asymmetric\nEncryption Padding (OAEP), which might weaken the encryption.\n"},"help":{"markdown":"The software uses the RSA algorithm but does not incorporate Optimal Asymmetric\nEncryption Padding (OAEP), which might weaken the encryption.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.RSA_NO_PADDING-1)\n","text":"The software uses the RSA algorithm but does not incorporate Optimal Asymmetric\nEncryption Padding (OAEP), which might weaken the encryption.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.RSA_NO_PADDING-1","id":"gitlab.find_sec_bugs_kotlin.RSA_NO_PADDING-1","name":"gitlab.find_sec_bugs_kotlin.RSA_NO_PADDING-1","properties":{"precision":"very-high","tags":["CWE-780","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Use of RSA algorithm without OAEP"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Ignoring XML comments in SAML may lead to authentication bypass\n"},"help":{"markdown":"Ignoring XML comments in SAML may lead to authentication bypass\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SAML_IGNORE_COMMENTS-1)\n","text":"Ignoring XML comments in SAML may lead to authentication bypass\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SAML_IGNORE_COMMENTS-1","id":"gitlab.find_sec_bugs_kotlin.SAML_IGNORE_COMMENTS-1","name":"gitlab.find_sec_bugs_kotlin.SAML_IGNORE_COMMENTS-1","properties":{"precision":"very-high","tags":["CWE-287","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper authentication"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The software constructs all or part of a code segment using externally-influenced\ninput from an upstream component, but it does not neutralize or incorrectly\nneutralizes special elements that could modify the syntax or behavior of the\nintended code segment.\n"},"help":{"markdown":"The software constructs all or part of a code segment using externally-influenced\ninput from an upstream component, but it does not neutralize or incorrectly\nneutralizes special elements that could modify the syntax or behavior of the\nintended code segment.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1)\n","text":"The software constructs all or part of a code segment using externally-influenced\ninput from an upstream component, but it does not neutralize or incorrectly\nneutralizes special elements that could modify the syntax or behavior of the\nintended code segment.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1","id":"gitlab.find_sec_bugs_kotlin.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1","name":"gitlab.find_sec_bugs_kotlin.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-94","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper control of generation of code ('Code Injection')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Simple Mail Transfer Protocol (SMTP) is a the text based protocol used for\nemail delivery. Like with HTTP, headers are separate by new line separator. If\nkuser input is place in a header line, the application should remove or replace\nnew line characters (CR / LF). You should use a safe wrapper such as Apache\nCommon Email and Simple Java Mail which filter special characters that can lead\nto header injection.\n"},"help":{"markdown":"Simple Mail Transfer Protocol (SMTP) is a the text based protocol used for\nemail delivery. Like with HTTP, headers are separate by new line separator. If\nkuser input is place in a header line, the application should remove or replace\nnew line characters (CR / LF). You should use a safe wrapper such as Apache\nCommon Email and Simple Java Mail which filter special characters that can lead\nto header injection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SMTP_HEADER_INJECTION-1)\n","text":"Simple Mail Transfer Protocol (SMTP) is a the text based protocol used for\nemail delivery. Like with HTTP, headers are separate by new line separator. If\nkuser input is place in a header line, the application should remove or replace\nnew line characters (CR / LF). You should use a safe wrapper such as Apache\nCommon Email and Simple Java Mail which filter special characters that can lead\nto header injection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SMTP_HEADER_INJECTION-1","id":"gitlab.find_sec_bugs_kotlin.SMTP_HEADER_INJECTION-1","name":"gitlab.find_sec_bugs_kotlin.SMTP_HEADER_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-77","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper neutralization of special elements used in a command"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application fails to protect against Cross-Site Request Forgery (CSRF)\ndue to disabling Spring's CSRF protection features.\n"},"help":{"markdown":"The application fails to protect against Cross-Site Request Forgery (CSRF)\ndue to disabling Spring's CSRF protection features.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SPRING_CSRF_PROTECTION_DISABLED-1)\n","text":"The application fails to protect against Cross-Site Request Forgery (CSRF)\ndue to disabling Spring's CSRF protection features.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SPRING_CSRF_PROTECTION_DISABLED-1","id":"gitlab.find_sec_bugs_kotlin.SPRING_CSRF_PROTECTION_DISABLED-1","name":"gitlab.find_sec_bugs_kotlin.SPRING_CSRF_PROTECTION_DISABLED-1","properties":{"precision":"very-high","tags":["CWE-352","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Cross-Site Request Forgery (CSRF)"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"help":{"markdown":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1)\n","text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1","id":"gitlab.find_sec_bugs_kotlin.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1","name":"gitlab.find_sec_bugs_kotlin.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1","properties":{"precision":"very-high","tags":["CWE-89","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middleattacks\nattacks since the client will trust any certificate.\n"},"help":{"markdown":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middleattacks\nattacks since the client will trust any certificate.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SSL_CONTEXT-1)\n","text":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middleattacks\nattacks since the client will trust any certificate.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SSL_CONTEXT-1","id":"gitlab.find_sec_bugs_kotlin.SSL_CONTEXT-1","name":"gitlab.find_sec_bugs_kotlin.SSL_CONTEXT-1","properties":{"precision":"very-high","tags":["CWE-295","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper certificate validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The application was found enabling insecure TLS protocol versions. When enabling protocol\nversions for an `SSLContext`, only the following versions should be allowed:\n- TLSv1.2\n- TLSv1.3\n- DTLSv1.2\n- DTLSv1.3\n\nTo mitigate potential security risks, it is strongly advised to enforce TLS 1.2 as the minimum\nprotocol version and disallow older versions such as TLS 1.0. Do note that newer versions of\nJava do not even support TLS 1.0 and will throw `NoSuchAlgorithmException`. Versions of TLS\nprior to 1.2 could expose the connection to downgrade attacks, where an adversary intercepts\nthe\nconnection and alters the requested protocol version to be a less secure one.\n\nIn many scenarios, relying on the default system configuration does not meet compliance\nstandards. This is due to the application being deployed across diverse systems with varying\nconfigurations and Java versions. While the default value may be secure on modern and\nup-to-date systems, it may not hold true for older systems. Consequently, it is highly\nrecommended to explicitly define a secure configuration in all cases.\n\nExample configuring an SSLContext with TLSv1.2:\n```\n// Create an SSLContext with TLSv1.2 explicitly\nSSLContext tlsContext = SSLContext.getInstance(\"TLSv1.2\"); // or TLSv1.3, DTLSv1.2, DTLSv1.3\n\n// Alternatively, set the enabled protocols\nSSLContext serverSslContext = SSLContext.getInstance(\"TLS\");\nSSLEngine serverEngine = serverSslContext.createSSLEngine();\n// Calling setEnabledProtocols will override the original context's configured protocol version\nserverEngine.setEnabledProtocols(new String[]{ \"TLSv1.2\" });\n```\n\nFor more information on `SSLContext` see:\n- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html\n\nFor more information on MiTM attacks see:\n- https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack\n"},"help":{"markdown":"The application was found enabling insecure TLS protocol versions. When enabling protocol\nversions for an `SSLContext`, only the following versions should be allowed:\n- TLSv1.2\n- TLSv1.3\n- DTLSv1.2\n- DTLSv1.3\n\nTo mitigate potential security risks, it is strongly advised to enforce TLS 1.2 as the minimum\nprotocol version and disallow older versions such as TLS 1.0. Do note that newer versions of\nJava do not even support TLS 1.0 and will throw `NoSuchAlgorithmException`. Versions of TLS\nprior to 1.2 could expose the connection to downgrade attacks, where an adversary intercepts\nthe\nconnection and alters the requested protocol version to be a less secure one.\n\nIn many scenarios, relying on the default system configuration does not meet compliance\nstandards. This is due to the application being deployed across diverse systems with varying\nconfigurations and Java versions. While the default value may be secure on modern and\nup-to-date systems, it may not hold true for older systems. Consequently, it is highly\nrecommended to explicitly define a secure configuration in all cases.\n\nExample configuring an SSLContext with TLSv1.2:\n```\n// Create an SSLContext with TLSv1.2 explicitly\nSSLContext tlsContext = SSLContext.getInstance(\"TLSv1.2\"); // or TLSv1.3, DTLSv1.2, DTLSv1.3\n\n// Alternatively, set the enabled protocols\nSSLContext serverSslContext = SSLContext.getInstance(\"TLS\");\nSSLEngine serverEngine = serverSslContext.createSSLEngine();\n// Calling setEnabledProtocols will override the original context's configured protocol version\nserverEngine.setEnabledProtocols(new String[]{ \"TLSv1.2\" });\n```\n\nFor more information on `SSLContext` see:\n- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html\n\nFor more information on MiTM attacks see:\n- https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SSL_CONTEXT-2)\n","text":"The application was found enabling insecure TLS protocol versions. When enabling protocol\nversions for an `SSLContext`, only the following versions should be allowed:\n- TLSv1.2\n- TLSv1.3\n- DTLSv1.2\n- DTLSv1.3\n\nTo mitigate potential security risks, it is strongly advised to enforce TLS 1.2 as the minimum\nprotocol version and disallow older versions such as TLS 1.0. Do note that newer versions of\nJava do not even support TLS 1.0 and will throw `NoSuchAlgorithmException`. Versions of TLS\nprior to 1.2 could expose the connection to downgrade attacks, where an adversary intercepts\nthe\nconnection and alters the requested protocol version to be a less secure one.\n\nIn many scenarios, relying on the default system configuration does not meet compliance\nstandards. This is due to the application being deployed across diverse systems with varying\nconfigurations and Java versions. While the default value may be secure on modern and\nup-to-date systems, it may not hold true for older systems. Consequently, it is highly\nrecommended to explicitly define a secure configuration in all cases.\n\nExample configuring an SSLContext with TLSv1.2:\n```\n// Create an SSLContext with TLSv1.2 explicitly\nSSLContext tlsContext = SSLContext.getInstance(\"TLSv1.2\"); // or TLSv1.3, DTLSv1.2, DTLSv1.3\n\n// Alternatively, set the enabled protocols\nSSLContext serverSslContext = SSLContext.getInstance(\"TLS\");\nSSLEngine serverEngine = serverSslContext.createSSLEngine();\n// Calling setEnabledProtocols will override the original context's configured protocol version\nserverEngine.setEnabledProtocols(new String[]{ \"TLSv1.2\" });\n```\n\nFor more information on `SSLContext` see:\n- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html\n\nFor more information on MiTM attacks see:\n- https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.SSL_CONTEXT-2","id":"gitlab.find_sec_bugs_kotlin.SSL_CONTEXT-2","name":"gitlab.find_sec_bugs_kotlin.SSL_CONTEXT-2","properties":{"precision":"very-high","tags":["CWE-326","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Triple DES (also known as 3DES or DESede) is considered strong ciphers for modern\napplications. NIST recommends the usage of AES block ciphers instead of 3DES.\n"},"help":{"markdown":"Triple DES (also known as 3DES or DESede) is considered strong ciphers for modern\napplications. NIST recommends the usage of AES block ciphers instead of 3DES.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.TDES_USAGE-1)\n","text":"Triple DES (also known as 3DES or DESede) is considered strong ciphers for modern\napplications. NIST recommends the usage of AES block ciphers instead of 3DES.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.TDES_USAGE-1","id":"gitlab.find_sec_bugs_kotlin.TDES_USAGE-1","name":"gitlab.find_sec_bugs_kotlin.TDES_USAGE-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A malicious user in control of a template can run malicious code on the\nserver-side. Velocity templates should be seen as scripts.\n"},"help":{"markdown":"A malicious user in control of a template can run malicious code on the\nserver-side. Velocity templates should be seen as scripts.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1)\n","text":"A malicious user in control of a template can run malicious code on the\nserver-side. Velocity templates should be seen as scripts.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1","id":"gitlab.find_sec_bugs_kotlin.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1","name":"gitlab.find_sec_bugs_kotlin.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1","properties":{"precision":"very-high","tags":["CWE-94","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper control of generation of code ('Code Injection')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Unvalidated redirects occur when an application redirects a user to a\ndestination URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities can be used to facilitate phishing attacks.\n"},"help":{"markdown":"Unvalidated redirects occur when an application redirects a user to a\ndestination URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities can be used to facilitate phishing attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.UNVALIDATED_REDIRECT-1.URL_REWRITING-1)\n","text":"Unvalidated redirects occur when an application redirects a user to a\ndestination URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities can be used to facilitate phishing attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.UNVALIDATED_REDIRECT-1.URL_REWRITING-1","id":"gitlab.find_sec_bugs_kotlin.UNVALIDATED_REDIRECT-1.URL_REWRITING-1","name":"gitlab.find_sec_bugs_kotlin.UNVALIDATED_REDIRECT-1.URL_REWRITING-1","properties":{"precision":"very-high","tags":["CWE-601","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"URL redirection to untrusted site ('Open Redirect')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Server-Side Request Forgery occur when a web server executes a request to a user supplied\ndestination parameter that is not validated. Such vulnerabilities could allow an attacker to\naccess internal services or to launch attacks from your web server.\n"},"help":{"markdown":"Server-Side Request Forgery occur when a web server executes a request to a user supplied\ndestination parameter that is not validated. Such vulnerabilities could allow an attacker to\naccess internal services or to launch attacks from your web server.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.URLCONNECTION_SSRF_FD-1)\n","text":"Server-Side Request Forgery occur when a web server executes a request to a user supplied\ndestination parameter that is not validated. Such vulnerabilities could allow an attacker to\naccess internal services or to launch attacks from your web server.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.URLCONNECTION_SSRF_FD-1","id":"gitlab.find_sec_bugs_kotlin.URLCONNECTION_SSRF_FD-1","name":"gitlab.find_sec_bugs_kotlin.URLCONNECTION_SSRF_FD-1","properties":{"precision":"very-high","tags":["CWE-918","OWASP-A10:2021-Server-Side Request Forgery","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Server-Side Request Forgery (SSRF)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A file is opened to read its content. The filename comes from an input\nparameter. If an unfiltered parameter is passed to this file API, files from an\narbitrary filesystem location could be read.\n"},"help":{"markdown":"A file is opened to read its content. The filename comes from an input\nparameter. If an unfiltered parameter is passed to this file API, files from an\narbitrary filesystem location could be read.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.WEAK_FILENAMEUTILS-1)\n","text":"A file is opened to read its content. The filename comes from an input\nparameter. If an unfiltered parameter is passed to this file API, files from an\narbitrary filesystem location could be read.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.WEAK_FILENAMEUTILS-1","id":"gitlab.find_sec_bugs_kotlin.WEAK_FILENAMEUTILS-1","name":"gitlab.find_sec_bugs_kotlin.WEAK_FILENAMEUTILS-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middle\nattacks since the client will trust any certificate.\n"},"help":{"markdown":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middle\nattacks since the client will trust any certificate.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1)\n","text":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middle\nattacks since the client will trust any certificate.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1","id":"gitlab.find_sec_bugs_kotlin.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1","name":"gitlab.find_sec_bugs_kotlin.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1","properties":{"precision":"very-high","tags":["CWE-295","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper Certificate Validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n"},"help":{"markdown":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1)\n","text":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","id":"gitlab.find_sec_bugs_kotlin.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","name":"gitlab.find_sec_bugs_kotlin.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","properties":{"precision":"very-high","tags":["CWE-327","OWASP-A04:2021-Insecure Design","OWASP-A6:2017-Security Misconfiguration","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Use of a broken or risky cryptographic algorithm (SHA1/MD5)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).\n"},"help":{"markdown":"Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.WICKET_XSS1-1)\n","text":"Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.WICKET_XSS1-1","id":"gitlab.find_sec_bugs_kotlin.WICKET_XSS1-1","name":"gitlab.find_sec_bugs_kotlin.WICKET_XSS1-1","properties":{"precision":"very-high","tags":["CWE-79","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper neutralization of input during web page generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Avoid using XMLDecoder to parse content from an untrusted source.\n"},"help":{"markdown":"Avoid using XMLDecoder to parse content from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XML_DECODER-1)\n","text":"Avoid using XMLDecoder to parse content from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XML_DECODER-1","id":"gitlab.find_sec_bugs_kotlin.XML_DECODER-1","name":"gitlab.find_sec_bugs_kotlin.XML_DECODER-1","properties":{"precision":"very-high","tags":["CWE-502","OWASP-A08:2021-Software and Data Integrity Failures","OWASP-A8:2017-Insecure Deserialization","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Deserialization of untrusted data"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"help":{"markdown":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XPATH_INJECTION-1)\n","text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XPATH_INJECTION-1","id":"gitlab.find_sec_bugs_kotlin.XPATH_INJECTION-1","name":"gitlab.find_sec_bugs_kotlin.XPATH_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-643","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper neutralization of data within XPath expressions ('XPath Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Servlet reflected cross site scripting vulnerability\n"},"help":{"markdown":"Servlet reflected cross site scripting vulnerability\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1)\n","text":"Servlet reflected cross site scripting vulnerability\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1","id":"gitlab.find_sec_bugs_kotlin.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1","name":"gitlab.find_sec_bugs_kotlin.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1","properties":{"precision":"very-high","tags":["CWE-79","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"MEDIUM"},"shortDescription":{"text":"Improper neutralization of input during web page generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XXE_SAXPARSER-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XXE_SAXPARSER-1","id":"gitlab.find_sec_bugs_kotlin.XXE_SAXPARSER-1","name":"gitlab.find_sec_bugs_kotlin.XXE_SAXPARSER-1","properties":{"precision":"very-high","tags":["CWE-611","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper restriction of XML external entity reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XXE_XMLREADER-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XXE_XMLREADER-1","id":"gitlab.find_sec_bugs_kotlin.XXE_XMLREADER-1","name":"gitlab.find_sec_bugs_kotlin.XXE_XMLREADER-1","properties":{"precision":"very-high","tags":["CWE-611","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper restriction of XML external entity reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XXE_XMLSTREAMREADER-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_kotlin.XXE_XMLSTREAMREADER-1","id":"gitlab.find_sec_bugs_kotlin.XXE_XMLSTREAMREADER-1","name":"gitlab.find_sec_bugs_kotlin.XXE_XMLSTREAMREADER-1","properties":{"precision":"very-high","tags":["CWE-611","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"CRITICAL"},"shortDescription":{"text":"Improper restriction of XML external entity reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Constructing SimpleDB queries containing user input can allow an attacker to view unauthorized\nrecords.\n"},"help":{"markdown":"Constructing SimpleDB queries containing user input can allow an attacker to view unauthorized\nrecords.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.AWS_QUERY_INJECTION-1)\n","text":"Constructing SimpleDB queries containing user input can allow an attacker to view unauthorized\nrecords.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.AWS_QUERY_INJECTION-1","id":"gitlab.find_sec_bugs_scala.AWS_QUERY_INJECTION-1","name":"gitlab.find_sec_bugs_scala.AWS_QUERY_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-943","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Neutralization of Special Elements in Data Query Logic"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"When converting a byte array containing a hash signature to a human readable string, a\nconversion mistake can be made if the array is read byte by byte.\n"},"help":{"markdown":"When converting a byte array containing a hash signature to a human readable string, a\nconversion mistake can be made if the array is read byte by byte.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.BAD_HEXA_CONVERSION-1)\n","text":"When converting a byte array containing a hash signature to a human readable string, a\nconversion mistake can be made if the array is read byte by byte.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.BAD_HEXA_CONVERSION-1","id":"gitlab.find_sec_bugs_scala.BAD_HEXA_CONVERSION-1","name":"gitlab.find_sec_bugs_scala.BAD_HEXA_CONVERSION-1","properties":{"precision":"very-high","tags":["CWE-704","HIGH CONFIDENCE","security"],"security-severity":"Medium"},"shortDescription":{"text":"Incorrect Type Conversion or Cast"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"An attacker can set arbitrary bean properties that can compromise system integrity. An\nattacker can leverage this functionality to access special bean properties like\nclass.classLoader that will allow them to override system properties and potentially execute\narbitrary code.\n"},"help":{"markdown":"An attacker can set arbitrary bean properties that can compromise system integrity. An\nattacker can leverage this functionality to access special bean properties like\nclass.classLoader that will allow them to override system properties and potentially execute\narbitrary code.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.BEAN_PROPERTY_INJECTION-1)\n","text":"An attacker can set arbitrary bean properties that can compromise system integrity. An\nattacker can leverage this functionality to access special bean properties like\nclass.classLoader that will allow them to override system properties and potentially execute\narbitrary code.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.BEAN_PROPERTY_INJECTION-1","id":"gitlab.find_sec_bugs_scala.BEAN_PROPERTY_INJECTION-1","name":"gitlab.find_sec_bugs_scala.BEAN_PROPERTY_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-15","security"],"security-severity":"Info"},"shortDescription":{"text":"External Control of System or Configuration Setting"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A small key size makes the ciphertext vulnerable to brute force attacks. At least 128 bits of\nentropy should be used when generating the key if use of Blowfish is required.\n"},"help":{"markdown":"A small key size makes the ciphertext vulnerable to brute force attacks. At least 128 bits of\nentropy should be used when generating the key if use of Blowfish is required.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.BLOWFISH_KEY_SIZE-1)\n","text":"A small key size makes the ciphertext vulnerable to brute force attacks. At least 128 bits of\nentropy should be used when generating the key if use of Blowfish is required.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.BLOWFISH_KEY_SIZE-1","id":"gitlab.find_sec_bugs_scala.BLOWFISH_KEY_SIZE-1","name":"gitlab.find_sec_bugs_scala.BLOWFISH_KEY_SIZE-1","properties":{"precision":"very-high","tags":["CWE-326","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate Encryption Strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The ciphertext produced is susceptible to alteration by an adversary. This mean that the\ncipher provides no way to detect that the data has been tampered with. If the ciphertext can be\ncontrolled by an attacker, it could be altered without detection.\n"},"help":{"markdown":"The ciphertext produced is susceptible to alteration by an adversary. This mean that the\ncipher provides no way to detect that the data has been tampered with. If the ciphertext can be\ncontrolled by an attacker, it could be altered without detection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CIPHER_INTEGRITY-1)\n","text":"The ciphertext produced is susceptible to alteration by an adversary. This mean that the\ncipher provides no way to detect that the data has been tampered with. If the ciphertext can be\ncontrolled by an attacker, it could be altered without detection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CIPHER_INTEGRITY-1","id":"gitlab.find_sec_bugs_scala.CIPHER_INTEGRITY-1","name":"gitlab.find_sec_bugs_scala.CIPHER_INTEGRITY-1","properties":{"precision":"very-high","tags":["CWE-353","security"],"security-severity":"Medium"},"shortDescription":{"text":"Missing Support for Integrity Check"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The highlighted API is used to execute a system command. If unfiltered input is passed to this\nAPI, it can lead to arbitrary command execution.\n"},"help":{"markdown":"The highlighted API is used to execute a system command. If unfiltered input is passed to this\nAPI, it can lead to arbitrary command execution.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.COMMAND_INJECTION-1.SCALA_COMMAND_INJECTION-1)\n","text":"The highlighted API is used to execute a system command. If unfiltered input is passed to this\nAPI, it can lead to arbitrary command execution.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.COMMAND_INJECTION-1.SCALA_COMMAND_INJECTION-1","id":"gitlab.find_sec_bugs_scala.COMMAND_INJECTION-1.SCALA_COMMAND_INJECTION-1","name":"gitlab.find_sec_bugs_scala.COMMAND_INJECTION-1.SCALA_COMMAND_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-78","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"\"Storing sensitive data in a persistent cookie for an extended period can lead to a breach of\nconfidentiality or account compromise.\"\n"},"help":{"markdown":"\"Storing sensitive data in a persistent cookie for an extended period can lead to a breach of\nconfidentiality or account compromise.\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.COOKIE_PERSISTENT-1)\n","text":"\"Storing sensitive data in a persistent cookie for an extended period can lead to a breach of\nconfidentiality or account compromise.\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.COOKIE_PERSISTENT-1","id":"gitlab.find_sec_bugs_scala.COOKIE_PERSISTENT-1","name":"gitlab.find_sec_bugs_scala.COOKIE_PERSISTENT-1","properties":{"precision":"very-high","tags":["CWE-614","security"],"security-severity":"Info"},"shortDescription":{"text":"Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The information stored in a custom cookie should not be sensitive or related to the session.\nIn most cases, sensitive data should only be stored in session and referenced by the user's\nsession cookie.\n"},"help":{"markdown":"The information stored in a custom cookie should not be sensitive or related to the session.\nIn most cases, sensitive data should only be stored in session and referenced by the user's\nsession cookie.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.COOKIE_USAGE-1)\n","text":"The information stored in a custom cookie should not be sensitive or related to the session.\nIn most cases, sensitive data should only be stored in session and referenced by the user's\nsession cookie.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.COOKIE_USAGE-1","id":"gitlab.find_sec_bugs_scala.COOKIE_USAGE-1","name":"gitlab.find_sec_bugs_scala.COOKIE_USAGE-1","properties":{"precision":"very-high","tags":["CWE-614","security"],"security-severity":"Info"},"shortDescription":{"text":"Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"When data from an untrusted source is put into a logger and not neutralized correctly, an\nattacker could forge log entries or include malicious content. Inserted false entries could be\nused to skew statistics, distract the administrator or even to implicate another party in the\ncommission of a malicious act. If the log file is processed automatically, the attacker can\nrender the file unusable by corrupting the format of the file or injecting unexpected\ncharacters. An attacker may also inject code or other commands into the log file and take\nadvantage of a vulnerability in the log processing utility (e.g. command injection or XSS).\n"},"help":{"markdown":"When data from an untrusted source is put into a logger and not neutralized correctly, an\nattacker could forge log entries or include malicious content. Inserted false entries could be\nused to skew statistics, distract the administrator or even to implicate another party in the\ncommission of a malicious act. If the log file is processed automatically, the attacker can\nrender the file unusable by corrupting the format of the file or injecting unexpected\ncharacters. An attacker may also inject code or other commands into the log file and take\nadvantage of a vulnerability in the log processing utility (e.g. command injection or XSS).\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CRLF_INJECTION_LOGS-1)\n","text":"When data from an untrusted source is put into a logger and not neutralized correctly, an\nattacker could forge log entries or include malicious content. Inserted false entries could be\nused to skew statistics, distract the administrator or even to implicate another party in the\ncommission of a malicious act. If the log file is processed automatically, the attacker can\nrender the file unusable by corrupting the format of the file or injecting unexpected\ncharacters. An attacker may also inject code or other commands into the log file and take\nadvantage of a vulnerability in the log processing utility (e.g. command injection or XSS).\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CRLF_INJECTION_LOGS-1","id":"gitlab.find_sec_bugs_scala.CRLF_INJECTION_LOGS-1","name":"gitlab.find_sec_bugs_scala.CRLF_INJECTION_LOGS-1","properties":{"precision":"very-high","tags":["CWE-93","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Neutralization of CRLF Sequences ('CRLF Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The method identified is susceptible to injection. The input should be validated and properly\nescaped.\n"},"help":{"markdown":"The method identified is susceptible to injection. The input should be validated and properly\nescaped.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CUSTOM_INJECTION-1)\n","text":"The method identified is susceptible to injection. The input should be validated and properly\nescaped.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CUSTOM_INJECTION-1","id":"gitlab.find_sec_bugs_scala.CUSTOM_INJECTION-1","name":"gitlab.find_sec_bugs_scala.CUSTOM_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-89","security"],"security-severity":"Low"},"shortDescription":{"text":"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The method identified is susceptible to injection. The input should be validated and properly\nescaped.\n"},"help":{"markdown":"The method identified is susceptible to injection. The input should be validated and properly\nescaped.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CUSTOM_INJECTION-2)\n","text":"The method identified is susceptible to injection. The input should be validated and properly\nescaped.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CUSTOM_INJECTION-2","id":"gitlab.find_sec_bugs_scala.CUSTOM_INJECTION-2","name":"gitlab.find_sec_bugs_scala.CUSTOM_INJECTION-2","properties":{"precision":"very-high","tags":["CWE-89","security"],"security-severity":"High"},"shortDescription":{"text":"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Implementing a custom MessageDigest is error-prone. National Institute of Standards and\nTechnology(NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\nSHA-512/256.\n"},"help":{"markdown":"Implementing a custom MessageDigest is error-prone. National Institute of Standards and\nTechnology(NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\nSHA-512/256.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CUSTOM_MESSAGE_DIGEST-1)\n","text":"Implementing a custom MessageDigest is error-prone. National Institute of Standards and\nTechnology(NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\nSHA-512/256.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.CUSTOM_MESSAGE_DIGEST-1","id":"gitlab.find_sec_bugs_scala.CUSTOM_MESSAGE_DIGEST-1","name":"gitlab.find_sec_bugs_scala.CUSTOM_MESSAGE_DIGEST-1","properties":{"precision":"very-high","tags":["CWE-327","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of a Broken or Risky Cryptographic Algorithm"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Do not grant dangerous combinations of permissions.\n"},"help":{"markdown":"Do not grant dangerous combinations of permissions.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DANGEROUS_PERMISSION_COMBINATION-1)\n","text":"Do not grant dangerous combinations of permissions.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DANGEROUS_PERMISSION_COMBINATION-1","id":"gitlab.find_sec_bugs_scala.DANGEROUS_PERMISSION_COMBINATION-1","name":"gitlab.find_sec_bugs_scala.DANGEROUS_PERMISSION_COMBINATION-1","properties":{"precision":"very-high","tags":["CWE-269","HIGH CONFIDENCE","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper privilege management"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"DefaultHttpClient with default constructor is not compatible with TLS 1.2\n"},"help":{"markdown":"DefaultHttpClient with default constructor is not compatible with TLS 1.2\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DEFAULT_HTTP_CLIENT-1)\n","text":"DefaultHttpClient with default constructor is not compatible with TLS 1.2\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DEFAULT_HTTP_CLIENT-1","id":"gitlab.find_sec_bugs_scala.DEFAULT_HTTP_CLIENT-1","name":"gitlab.find_sec_bugs_scala.DEFAULT_HTTP_CLIENT-1","properties":{"precision":"very-high","tags":["CWE-326","security"],"security-severity":"Info"},"shortDescription":{"text":"Inadequate encryption strength"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n"},"help":{"markdown":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DES_USAGE-1)\n","text":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DES_USAGE-1","id":"gitlab.find_sec_bugs_scala.DES_USAGE-1","name":"gitlab.find_sec_bugs_scala.DES_USAGE-1","properties":{"precision":"very-high","tags":["CWE-326","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate Encryption Strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"help":{"markdown":"A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3)\n","text":"A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3","id":"gitlab.find_sec_bugs_scala.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3","name":"gitlab.find_sec_bugs_scala.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3","properties":{"precision":"very-high","tags":["CWE-259","security"],"security-severity":"Critical"},"shortDescription":{"text":"Use of Hard-coded Password"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"help":{"markdown":"The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2)\n","text":"The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2","id":"gitlab.find_sec_bugs_scala.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2","name":"gitlab.find_sec_bugs_scala.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2","properties":{"precision":"very-high","tags":["CWE-259","security"],"security-severity":"Critical"},"shortDescription":{"text":"Use of Hard-coded Password"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"An authentication cipher mode which provides better confidentiality of the encrypted data\nshould be used instead of Electronic Code Book (ECB) mode, which does not provide good\nconfidentiality. Specifically, ECB mode produces the same output for the same input each time.\nThis allows an attacker to intercept and replay the data.\n"},"help":{"markdown":"An authentication cipher mode which provides better confidentiality of the encrypted data\nshould be used instead of Electronic Code Book (ECB) mode, which does not provide good\nconfidentiality. Specifically, ECB mode produces the same output for the same input each time.\nThis allows an attacker to intercept and replay the data.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.ECB_MODE-1)\n","text":"An authentication cipher mode which provides better confidentiality of the encrypted data\nshould be used instead of Electronic Code Book (ECB) mode, which does not provide good\nconfidentiality. Specifically, ECB mode produces the same output for the same input each time.\nThis allows an attacker to intercept and replay the data.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.ECB_MODE-1","id":"gitlab.find_sec_bugs_scala.ECB_MODE-1","name":"gitlab.find_sec_bugs_scala.ECB_MODE-1","properties":{"precision":"very-high","tags":["CWE-326","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate Encryption Strength"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"An expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\n"},"help":{"markdown":"An expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.EL_INJECTION-1)\n","text":"An expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.EL_INJECTION-1","id":"gitlab.find_sec_bugs_scala.EL_INJECTION-1","name":"gitlab.find_sec_bugs_scala.EL_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-94","security"],"security-severity":"High"},"shortDescription":{"text":"Improper Control of Generation of Code ('Code Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Allowing external control of system settings can disrupt service or cause an application to\nbehave in unexpected, and potentially malicious ways. An attacker could cause an error by\nproviding a nonexistent catalog name or connect to an unauthorized portion of the database.\n"},"help":{"markdown":"Allowing external control of system settings can disrupt service or cause an application to\nbehave in unexpected, and potentially malicious ways. An attacker could cause an error by\nproviding a nonexistent catalog name or connect to an unauthorized portion of the database.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.EXTERNAL_CONFIG_CONTROL-1)\n","text":"Allowing external control of system settings can disrupt service or cause an application to\nbehave in unexpected, and potentially malicious ways. An attacker could cause an error by\nproviding a nonexistent catalog name or connect to an unauthorized portion of the database.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.EXTERNAL_CONFIG_CONTROL-1","id":"gitlab.find_sec_bugs_scala.EXTERNAL_CONFIG_CONTROL-1","name":"gitlab.find_sec_bugs_scala.EXTERNAL_CONFIG_CONTROL-1","properties":{"precision":"very-high","tags":["CWE-15","security"],"security-severity":"High"},"shortDescription":{"text":"External Control of System or Configuration Setting"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The filename provided by the FileUpload API can be tampered with by the client to reference\nunauthorized files. The provided filename should be properly validated to ensure it's properly\nstructured, contains no unauthorized path characters (e.g., / \\), and refers to an authorized\nfile.\n"},"help":{"markdown":"The filename provided by the FileUpload API can be tampered with by the client to reference\nunauthorized files. The provided filename should be properly validated to ensure it's properly\nstructured, contains no unauthorized path characters (e.g., / \\), and refers to an authorized\nfile.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.FILE_UPLOAD_FILENAME-1)\n","text":"The filename provided by the FileUpload API can be tampered with by the client to reference\nunauthorized files. The provided filename should be properly validated to ensure it's properly\nstructured, contains no unauthorized path characters (e.g., / \\), and refers to an authorized\nfile.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.FILE_UPLOAD_FILENAME-1","id":"gitlab.find_sec_bugs_scala.FILE_UPLOAD_FILENAME-1","name":"gitlab.find_sec_bugs_scala.FILE_UPLOAD_FILENAME-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Allowing user input to control format parameters could enable an attacker to cause exceptions\nto be thrown or leak information.Attackers may be able  to modify the format string argument,\nsuch that an exception is thrown. If this exception is left uncaught, it may crash the\napplication. Alternatively, if sensitive information is used within the unused arguments,\nattackers may change the format string to reveal this information.\n"},"help":{"markdown":"Allowing user input to control format parameters could enable an attacker to cause exceptions\nto be thrown or leak information.Attackers may be able  to modify the format string argument,\nsuch that an exception is thrown. If this exception is left uncaught, it may crash the\napplication. Alternatively, if sensitive information is used within the unused arguments,\nattackers may change the format string to reveal this information.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.FORMAT_STRING_MANIPULATION-1)\n","text":"Allowing user input to control format parameters could enable an attacker to cause exceptions\nto be thrown or leak information.Attackers may be able  to modify the format string argument,\nsuch that an exception is thrown. If this exception is left uncaught, it may crash the\napplication. Alternatively, if sensitive information is used within the unused arguments,\nattackers may change the format string to reveal this information.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.FORMAT_STRING_MANIPULATION-1","id":"gitlab.find_sec_bugs_scala.FORMAT_STRING_MANIPULATION-1","name":"gitlab.find_sec_bugs_scala.FORMAT_STRING_MANIPULATION-1","properties":{"precision":"very-high","tags":["CWE-134","HIGH CONFIDENCE","security"],"security-severity":"Info"},"shortDescription":{"text":"Use of Externally-Controlled Format String"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A potential hard-coded password was identified in the source code.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"help":{"markdown":"A potential hard-coded password was identified in the source code.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HARD_CODE_PASSWORD-1)\n","text":"A potential hard-coded password was identified in the source code.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HARD_CODE_PASSWORD-1","id":"gitlab.find_sec_bugs_scala.HARD_CODE_PASSWORD-1","name":"gitlab.find_sec_bugs_scala.HARD_CODE_PASSWORD-1","properties":{"precision":"very-high","tags":["CWE-259","security"],"security-severity":"High"},"shortDescription":{"text":"Use of Hard-coded Password"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The network communications for Hazelcast is configured to use a symmetric cipher (probably DES\nor Blowfish). Those ciphers alone do not provide integrity or secure authentication. The use of\nasymmetric encryption is preferred.\n"},"help":{"markdown":"The network communications for Hazelcast is configured to use a symmetric cipher (probably DES\nor Blowfish). Those ciphers alone do not provide integrity or secure authentication. The use of\nasymmetric encryption is preferred.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HAZELCAST_SYMMETRIC_ENCRYPTION-1)\n","text":"The network communications for Hazelcast is configured to use a symmetric cipher (probably DES\nor Blowfish). Those ciphers alone do not provide integrity or secure authentication. The use of\nasymmetric encryption is preferred.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HAZELCAST_SYMMETRIC_ENCRYPTION-1","id":"gitlab.find_sec_bugs_scala.HAZELCAST_SYMMETRIC_ENCRYPTION-1","name":"gitlab.find_sec_bugs_scala.HAZELCAST_SYMMETRIC_ENCRYPTION-1","properties":{"precision":"very-high","tags":["CWE-326","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate Encryption Strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added\nto an HTTP response, it will allow a HTTP response splitting vulnerability. See\nhttp://en.wikipedia.org/wiki/HTTP_response_splitting for more information.\n"},"help":{"markdown":"This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added\nto an HTTP response, it will allow a HTTP response splitting vulnerability. See\nhttp://en.wikipedia.org/wiki/HTTP_response_splitting for more information.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_COOKIE-1)\n","text":"This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added\nto an HTTP response, it will allow a HTTP response splitting vulnerability. See\nhttp://en.wikipedia.org/wiki/HTTP_response_splitting for more information.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_COOKIE-1","id":"gitlab.find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_COOKIE-1","name":"gitlab.find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_COOKIE-1","properties":{"precision":"very-high","tags":["CWE-113","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"This code directly writes an HTTP parameter to an HTTP header, which allows for a HTTP\nresponse splitting vulnerability. See http://en.wikipedia.org/wiki/HTTP_response_splitting for\nmore information.\n"},"help":{"markdown":"This code directly writes an HTTP parameter to an HTTP header, which allows for a HTTP\nresponse splitting vulnerability. See http://en.wikipedia.org/wiki/HTTP_response_splitting for\nmore information.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1)\n","text":"This code directly writes an HTTP parameter to an HTTP header, which allows for a HTTP\nresponse splitting vulnerability. See http://en.wikipedia.org/wiki/HTTP_response_splitting for\nmore information.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1","id":"gitlab.find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1","name":"gitlab.find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1","properties":{"precision":"very-high","tags":["CWE-113","security"],"security-severity":"High"},"shortDescription":{"text":"Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A new cookie is created without the HttpOnly flag set. The HttpOnly flag is a directive to the\nbrowser to make sure that the cookie can not be red by malicious script. When a user is the\ntarget of a \"Cross-Site Scripting\", the attacker would benefit greatly from getting the session\nid for example.\n"},"help":{"markdown":"A new cookie is created without the HttpOnly flag set. The HttpOnly flag is a directive to the\nbrowser to make sure that the cookie can not be red by malicious script. When a user is the\ntarget of a \"Cross-Site Scripting\", the attacker would benefit greatly from getting the session\nid for example.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HTTPONLY_COOKIE-1)\n","text":"A new cookie is created without the HttpOnly flag set. The HttpOnly flag is a directive to the\nbrowser to make sure that the cookie can not be red by malicious script. When a user is the\ntarget of a \"Cross-Site Scripting\", the attacker would benefit greatly from getting the session\nid for example.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HTTPONLY_COOKIE-1","id":"gitlab.find_sec_bugs_scala.HTTPONLY_COOKIE-1","name":"gitlab.find_sec_bugs_scala.HTTPONLY_COOKIE-1","properties":{"precision":"very-high","tags":["CWE-1004","security"],"security-severity":"Low"},"shortDescription":{"text":"Sensitive Cookie Without 'HttpOnly' Flag"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Concatenating unvalidated user input into a URL can allow an attacker to override the value of\na request parameter. Attacker may be able to override existing parameter values, inject a new\nparameter or exploit variables out of a direct reach. HTTP Parameter Pollution (HPP) attacks\nconsist of injecting encoded query string delimiters into other existing parameters. If a web\napplication does not properly sanitize the user input, a malicious user may compromise the\nlogic of the application to perform either client-side or server-side attacks.\n"},"help":{"markdown":"Concatenating unvalidated user input into a URL can allow an attacker to override the value of\na request parameter. Attacker may be able to override existing parameter values, inject a new\nparameter or exploit variables out of a direct reach. HTTP Parameter Pollution (HPP) attacks\nconsist of injecting encoded query string delimiters into other existing parameters. If a web\napplication does not properly sanitize the user input, a malicious user may compromise the\nlogic of the application to perform either client-side or server-side attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HTTP_PARAMETER_POLLUTION-1)\n","text":"Concatenating unvalidated user input into a URL can allow an attacker to override the value of\na request parameter. Attacker may be able to override existing parameter values, inject a new\nparameter or exploit variables out of a direct reach. HTTP Parameter Pollution (HPP) attacks\nconsist of injecting encoded query string delimiters into other existing parameters. If a web\napplication does not properly sanitize the user input, a malicious user may compromise the\nlogic of the application to perform either client-side or server-side attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HTTP_PARAMETER_POLLUTION-1","id":"gitlab.find_sec_bugs_scala.HTTP_PARAMETER_POLLUTION-1","name":"gitlab.find_sec_bugs_scala.HTTP_PARAMETER_POLLUTION-1","properties":{"precision":"very-high","tags":["CWE-88","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"When an HTTP request contains unexpected CR and LF characters, the server may respond with an\noutput stream that is interpreted as two different HTTP responses (instead of one). An attacker\ncan control the second response and mount attacks such as cross-site scripting and cache\npoisoning attacks.\n"},"help":{"markdown":"When an HTTP request contains unexpected CR and LF characters, the server may respond with an\noutput stream that is interpreted as two different HTTP responses (instead of one). An attacker\ncan control the second response and mount attacks such as cross-site scripting and cache\npoisoning attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HTTP_RESPONSE_SPLITTING-1)\n","text":"When an HTTP request contains unexpected CR and LF characters, the server may respond with an\noutput stream that is interpreted as two different HTTP responses (instead of one). An attacker\ncan control the second response and mount attacks such as cross-site scripting and cache\npoisoning attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.HTTP_RESPONSE_SPLITTING-1","id":"gitlab.find_sec_bugs_scala.HTTP_RESPONSE_SPLITTING-1","name":"gitlab.find_sec_bugs_scala.HTTP_RESPONSE_SPLITTING-1","properties":{"precision":"very-high","tags":["CWE-113","security"],"security-severity":"High"},"shortDescription":{"text":"Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Improper Handling of Unicode Encoding\n"},"help":{"markdown":"Improper Handling of Unicode Encoding\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.IMPROPER_UNICODE-1)\n","text":"Improper Handling of Unicode Encoding\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.IMPROPER_UNICODE-1","id":"gitlab.find_sec_bugs_scala.IMPROPER_UNICODE-1","name":"gitlab.find_sec_bugs_scala.IMPROPER_UNICODE-1","properties":{"precision":"very-high","tags":["CWE-176","HIGH CONFIDENCE","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Handling of Unicode Encoding"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The sensitive information may be valuable information on its own (such as a password), or it\nmay be useful for launching other, more deadly attacks. If an attack fails, an attacker may use\nerror information provided by the server to launch another more focused attack. For example, an\nattempt to exploit a path traversal weakness (CWE-22) might yield the full pathname of the\ninstalled application.\n"},"help":{"markdown":"The sensitive information may be valuable information on its own (such as a password), or it\nmay be useful for launching other, more deadly attacks. If an attack fails, an attacker may use\nerror information provided by the server to launch another more focused attack. For example, an\nattempt to exploit a path traversal weakness (CWE-22) might yield the full pathname of the\ninstalled application.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1)\n","text":"The sensitive information may be valuable information on its own (such as a password), or it\nmay be useful for launching other, more deadly attacks. If an attack fails, an attacker may use\nerror information provided by the server to launch another more focused attack. For example, an\nattempt to exploit a path traversal weakness (CWE-22) might yield the full pathname of the\ninstalled application.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1","id":"gitlab.find_sec_bugs_scala.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1","name":"gitlab.find_sec_bugs_scala.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1","properties":{"precision":"very-high","tags":["CWE-209","security"],"security-severity":"Low"},"shortDescription":{"text":"Information Exposure Through an Error Message"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"\"A new cookie is created without the Secure flag set. The Secure flag is a\n directive to the browser to make sure that the cookie is not sent for insecure communication\n(http://)\"\n"},"help":{"markdown":"\"A new cookie is created without the Secure flag set. The Secure flag is a\n directive to the browser to make sure that the cookie is not sent for insecure communication\n(http://)\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.INSECURE_COOKIE-1)\n","text":"\"A new cookie is created without the Secure flag set. The Secure flag is a\n directive to the browser to make sure that the cookie is not sent for insecure communication\n(http://)\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.INSECURE_COOKIE-1","id":"gitlab.find_sec_bugs_scala.INSECURE_COOKIE-1","name":"gitlab.find_sec_bugs_scala.INSECURE_COOKIE-1","properties":{"precision":"very-high","tags":["CWE-539","security"],"security-severity":"Low"},"shortDescription":{"text":"Information Exposure Through Persistent Cookies"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Server identity verification is disabled when making SSL connections.\n"},"help":{"markdown":"Server identity verification is disabled when making SSL connections.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.INSECURE_SMTP_SSL-1)\n","text":"Server identity verification is disabled when making SSL connections.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.INSECURE_SMTP_SSL-1","id":"gitlab.find_sec_bugs_scala.INSECURE_SMTP_SSL-1","name":"gitlab.find_sec_bugs_scala.INSECURE_SMTP_SSL-1","properties":{"precision":"very-high","tags":["CWE-297","OWASP-A07:2021-Identification and Authentication Failures","OWASP-A2:2017-Broken Authentication","security"],"security-severity":"High"},"shortDescription":{"text":"Improper Validation of Certificate with Host Mismatch"}},{"defaultConfiguration":{"level":"note"},"fullDescription":{"text":"This method is part of a REST Web Service (JSR311). The security of this web service should be\nanalyzed. For example:\n- Authentication, if enforced, should be tested.\n- Access control, if enforced, should be tested.\n- The inputs should be tracked for potential vulnerabilities.\n- The communication should ideally be over SSL.\n- If the service supports writes (e.g., via POST), its vulnerability to CSRF should be\ninvestigated.\n"},"help":{"markdown":"This method is part of a REST Web Service (JSR311). The security of this web service should be\nanalyzed. For example:\n- Authentication, if enforced, should be tested.\n- Access control, if enforced, should be tested.\n- The inputs should be tracked for potential vulnerabilities.\n- The communication should ideally be over SSL.\n- If the service supports writes (e.g., via POST), its vulnerability to CSRF should be\ninvestigated.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.JAXRS_ENDPOINT-1)\n","text":"This method is part of a REST Web Service (JSR311). The security of this web service should be\nanalyzed. For example:\n- Authentication, if enforced, should be tested.\n- Access control, if enforced, should be tested.\n- The inputs should be tracked for potential vulnerabilities.\n- The communication should ideally be over SSL.\n- If the service supports writes (e.g., via POST), its vulnerability to CSRF should be\ninvestigated.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.JAXRS_ENDPOINT-1","id":"gitlab.find_sec_bugs_scala.JAXRS_ENDPOINT-1","name":"gitlab.find_sec_bugs_scala.JAXRS_ENDPOINT-1","properties":{"precision":"very-high","tags":["CWE-20","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"note"},"fullDescription":{"text":"This method is part of a SOAP Web Service (JSR224). The security of this web service should be\nanalyzed. For example:\n- Authentication, if enforced, should be tested.\n- Access control, if enforced, should be tested.\n- The inputs should be tracked for potential vulnerabilities.\n- The communication should ideally be over SSL.\n"},"help":{"markdown":"This method is part of a SOAP Web Service (JSR224). The security of this web service should be\nanalyzed. For example:\n- Authentication, if enforced, should be tested.\n- Access control, if enforced, should be tested.\n- The inputs should be tracked for potential vulnerabilities.\n- The communication should ideally be over SSL.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.JAXWS_ENDPOINT-1)\n","text":"This method is part of a SOAP Web Service (JSR224). The security of this web service should be\nanalyzed. For example:\n- Authentication, if enforced, should be tested.\n- Access control, if enforced, should be tested.\n- The inputs should be tracked for potential vulnerabilities.\n- The communication should ideally be over SSL.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.JAXWS_ENDPOINT-1","id":"gitlab.find_sec_bugs_scala.JAXWS_ENDPOINT-1","name":"gitlab.find_sec_bugs_scala.JAXWS_ENDPOINT-1","properties":{"precision":"very-high","tags":["CWE-20","OWASP-A03:2021-Injection","OWASP-A7:2017-Cross-Site Scripting (XSS)","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n"},"help":{"markdown":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.LDAP_ANONYMOUS-1)\n","text":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.LDAP_ANONYMOUS-1","id":"gitlab.find_sec_bugs_scala.LDAP_ANONYMOUS-1","name":"gitlab.find_sec_bugs_scala.LDAP_ANONYMOUS-1","properties":{"precision":"very-high","tags":["CWE-20","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n"},"help":{"markdown":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.LDAP_ENTRY_POISONING-1)\n","text":"Without proper access control, executing an LDAP statement that contains a\nuser-controlled value can allow an attacker to abuse poorly configured LDAP\ncontext\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.LDAP_ENTRY_POISONING-1","id":"gitlab.find_sec_bugs_scala.LDAP_ENTRY_POISONING-1","name":"gitlab.find_sec_bugs_scala.LDAP_ENTRY_POISONING-1","properties":{"precision":"very-high","tags":["CWE-20","security"],"security-severity":"High"},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Just like SQL, all inputs passed to an LDAP query need to be passed in safely. Unfortunately,\nLDAP doesn't have prepared statement interfaces like SQL. Therefore, the primary defense\nagainst LDAP injection is strong input validation of any untrusted data before including it in\nan LDAP query.\n"},"help":{"markdown":"Just like SQL, all inputs passed to an LDAP query need to be passed in safely. Unfortunately,\nLDAP doesn't have prepared statement interfaces like SQL. Therefore, the primary defense\nagainst LDAP injection is strong input validation of any untrusted data before including it in\nan LDAP query.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.LDAP_INJECTION-1)\n","text":"Just like SQL, all inputs passed to an LDAP query need to be passed in safely. Unfortunately,\nLDAP doesn't have prepared statement interfaces like SQL. Therefore, the primary defense\nagainst LDAP injection is strong input validation of any untrusted data before including it in\nan LDAP query.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.LDAP_INJECTION-1","id":"gitlab.find_sec_bugs_scala.LDAP_INJECTION-1","name":"gitlab.find_sec_bugs_scala.LDAP_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-90","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"It is possible to attach malicious behavior to those style sheets. Therefore, if an attacker\ncan control the content or the source of the style sheet, he might be able to trigger remote\ncode execution.\n"},"help":{"markdown":"It is possible to attach malicious behavior to those style sheets. Therefore, if an attacker\ncan control the content or the source of the style sheet, he might be able to trigger remote\ncode execution.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.MALICIOUS_XSLT-1)\n","text":"It is possible to attach malicious behavior to those style sheets. Therefore, if an attacker\ncan control the content or the source of the style sheet, he might be able to trigger remote\ncode execution.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.MALICIOUS_XSLT-1","id":"gitlab.find_sec_bugs_scala.MALICIOUS_XSLT-1","name":"gitlab.find_sec_bugs_scala.MALICIOUS_XSLT-1","properties":{"precision":"very-high","tags":["CWE-74","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper neutralization of special elements in output used by a downstream component ('Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"CERT: IDS11-J. Perform any string modifications before validation\n"},"help":{"markdown":"CERT: IDS11-J. Perform any string modifications before validation\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.MODIFICATION_AFTER_VALIDATION-1)\n","text":"CERT: IDS11-J. Perform any string modifications before validation\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.MODIFICATION_AFTER_VALIDATION-1","id":"gitlab.find_sec_bugs_scala.MODIFICATION_AFTER_VALIDATION-1","name":"gitlab.find_sec_bugs_scala.MODIFICATION_AFTER_VALIDATION-1","properties":{"precision":"very-high","tags":["CWE-182","HIGH CONFIDENCE","security"],"security-severity":"Info"},"shortDescription":{"text":"Collapse of data into unsafe value"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"IDS01-J. Normalize strings before validating them\n"},"help":{"markdown":"IDS01-J. Normalize strings before validating them\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.NORMALIZATION_AFTER_VALIDATION-1)\n","text":"IDS01-J. Normalize strings before validating them\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.NORMALIZATION_AFTER_VALIDATION-1","id":"gitlab.find_sec_bugs_scala.NORMALIZATION_AFTER_VALIDATION-1","name":"gitlab.find_sec_bugs_scala.NORMALIZATION_AFTER_VALIDATION-1","properties":{"precision":"very-high","tags":["CWE-182","HIGH CONFIDENCE","security"],"security-severity":"Info"},"shortDescription":{"text":"Collapse of data into unsafe value"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The NullCipher implements the Cipher interface by returning ciphertext identical to the\nsupplied plaintext. In a few contexts, such as testing, a NullCipher may be appropriate. Avoid\nusing the NullCipher. Its accidental use can introduce a significant confidentiality risk.\n"},"help":{"markdown":"The NullCipher implements the Cipher interface by returning ciphertext identical to the\nsupplied plaintext. In a few contexts, such as testing, a NullCipher may be appropriate. Avoid\nusing the NullCipher. Its accidental use can introduce a significant confidentiality risk.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.NULL_CIPHER-1)\n","text":"The NullCipher implements the Cipher interface by returning ciphertext identical to the\nsupplied plaintext. In a few contexts, such as testing, a NullCipher may be appropriate. Avoid\nusing the NullCipher. Its accidental use can introduce a significant confidentiality risk.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.NULL_CIPHER-1","id":"gitlab.find_sec_bugs_scala.NULL_CIPHER-1","name":"gitlab.find_sec_bugs_scala.NULL_CIPHER-1","properties":{"precision":"very-high","tags":["CWE-327","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of a Broken or Risky Cryptographic Algorithm"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"\"A expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\"\n"},"help":{"markdown":"\"A expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.OGNL_INJECTION-1)\n","text":"\"A expression is built with a dynamic value. The source of the value(s) should be verified to\navoid that unfiltered values fall into this risky code evaluation.\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.OGNL_INJECTION-1","id":"gitlab.find_sec_bugs_scala.OGNL_INJECTION-1","name":"gitlab.find_sec_bugs_scala.OGNL_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-917","security"],"security-severity":"Medium"},"shortDescription":{"text":"Expression injection (OGNL)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Overly permissive file permission\n"},"help":{"markdown":"Overly permissive file permission\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-1)\n","text":"Overly permissive file permission\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-1","id":"gitlab.find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-1","name":"gitlab.find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-1","properties":{"precision":"very-high","tags":["CWE-732","HIGH CONFIDENCE","security"],"security-severity":"High"},"shortDescription":{"text":"Incorrect Permission Assignment for Critical Resource"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Overly permissive file permission\n"},"help":{"markdown":"Overly permissive file permission\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-2)\n","text":"Overly permissive file permission\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-2","id":"gitlab.find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-2","name":"gitlab.find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-2","properties":{"precision":"very-high","tags":["CWE-732","HIGH CONFIDENCE","security"],"security-severity":"Medium"},"shortDescription":{"text":"Incorrect Permission Assignment for Critical Resource"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An\nadversary could potentially decrypt the message if the system exposed the difference between\nplaintext with invalid padding or valid padding. The distinction between valid and invalid\npadding is usually revealed through distinct error messages being returned for each condition.\n"},"help":{"markdown":"This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An\nadversary could potentially decrypt the message if the system exposed the difference between\nplaintext with invalid padding or valid padding. The distinction between valid and invalid\npadding is usually revealed through distinct error messages being returned for each condition.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PADDING_ORACLE-1)\n","text":"This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An\nadversary could potentially decrypt the message if the system exposed the difference between\nplaintext with invalid padding or valid padding. The distinction between valid and invalid\npadding is usually revealed through distinct error messages being returned for each condition.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PADDING_ORACLE-1","id":"gitlab.find_sec_bugs_scala.PADDING_ORACLE-1","name":"gitlab.find_sec_bugs_scala.PADDING_ORACLE-1","properties":{"precision":"very-high","tags":["CWE-696","security"],"security-severity":"Medium"},"shortDescription":{"text":"Incorrect Behavior Order"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A file is opened to read its content. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files from an arbitrary filesystem location\ncould be read. This rule identifies potential path traversal vulnerabilities. In many cases,\nthe constructed file path cannot be controlled by the user.\n"},"help":{"markdown":"A file is opened to read its content. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files from an arbitrary filesystem location\ncould be read. This rule identifies potential path traversal vulnerabilities. In many cases,\nthe constructed file path cannot be controlled by the user.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PATH_TRAVERSAL_IN-1.SCALA_PATH_TRAVERSAL_IN-1)\n","text":"A file is opened to read its content. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files from an arbitrary filesystem location\ncould be read. This rule identifies potential path traversal vulnerabilities. In many cases,\nthe constructed file path cannot be controlled by the user.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PATH_TRAVERSAL_IN-1.SCALA_PATH_TRAVERSAL_IN-1","id":"gitlab.find_sec_bugs_scala.PATH_TRAVERSAL_IN-1.SCALA_PATH_TRAVERSAL_IN-1","name":"gitlab.find_sec_bugs_scala.PATH_TRAVERSAL_IN-1.SCALA_PATH_TRAVERSAL_IN-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A file is opened to write to its contents. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files at an arbitrary filesystem location\ncould be modified. This rule identifies potential path traversal vulnerabilities. In many\ncases, the constructed file path cannot be controlled by the user.\n"},"help":{"markdown":"A file is opened to write to its contents. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files at an arbitrary filesystem location\ncould be modified. This rule identifies potential path traversal vulnerabilities. In many\ncases, the constructed file path cannot be controlled by the user.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PATH_TRAVERSAL_OUT-1)\n","text":"A file is opened to write to its contents. The filename comes from an input parameter. If an\nunfiltered parameter is passed to this file API, files at an arbitrary filesystem location\ncould be modified. This rule identifies potential path traversal vulnerabilities. In many\ncases, the constructed file path cannot be controlled by the user.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PATH_TRAVERSAL_OUT-1","id":"gitlab.find_sec_bugs_scala.PATH_TRAVERSAL_OUT-1","name":"gitlab.find_sec_bugs_scala.PATH_TRAVERSAL_OUT-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"High"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n"},"help":{"markdown":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PERMISSIVE_CORS-1)\n","text":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PERMISSIVE_CORS-1","id":"gitlab.find_sec_bugs_scala.PERMISSIVE_CORS-1","name":"gitlab.find_sec_bugs_scala.PERMISSIVE_CORS-1","properties":{"precision":"very-high","tags":["CWE-942","security"],"security-severity":"Info"},"shortDescription":{"text":"Permissive Cross-domain Policy with Untrusted Domains"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n"},"help":{"markdown":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PERMISSIVE_CORS-2)\n","text":"Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for\nJavaScript to access the contents of a Web page, both the JavaScript and the Web page must\noriginate from the same domain. Without the Same Origin Policy, a malicious website could serve\nup JavaScript that loads sensitive information from other websites using a client's\ncredentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible\nfor JavaScript to access data across domains if a new HTTP header called\nAccess-Control-Allow-Origin is defined. With this header, a Web server defines which other\ndomains are allowed to access its domain using cross-origin requests. However, caution should\nbe taken when defining the header because an overly permissive CORS policy will allow a\nmalicious application to communicate with the victim application in an inappropriate way,\nleading to spoofing, data theft, relay and other attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PERMISSIVE_CORS-2","id":"gitlab.find_sec_bugs_scala.PERMISSIVE_CORS-2","name":"gitlab.find_sec_bugs_scala.PERMISSIVE_CORS-2","properties":{"precision":"very-high","tags":["CWE-942","security"],"security-severity":"Low"},"shortDescription":{"text":"Permissive Cross-domain Policy with Untrusted Domains"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The use of a predictable random value can lead to vulnerabilities when used in certain security\ncritical contexts. A quick fix could be to replace the use of scala.util.Random with something\nstronger, such as java.security.SecureRandom\n"},"help":{"markdown":"The use of a predictable random value can lead to vulnerabilities when used in certain security\ncritical contexts. A quick fix could be to replace the use of scala.util.Random with something\nstronger, such as java.security.SecureRandom\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PREDICTABLE_RANDOM-1.PREDICTABLE_RANDOM_SCALA-1)\n","text":"The use of a predictable random value can lead to vulnerabilities when used in certain security\ncritical contexts. A quick fix could be to replace the use of scala.util.Random with something\nstronger, such as java.security.SecureRandom\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PREDICTABLE_RANDOM-1.PREDICTABLE_RANDOM_SCALA-1","id":"gitlab.find_sec_bugs_scala.PREDICTABLE_RANDOM-1.PREDICTABLE_RANDOM_SCALA-1","name":"gitlab.find_sec_bugs_scala.PREDICTABLE_RANDOM-1.PREDICTABLE_RANDOM_SCALA-1","properties":{"precision":"very-high","tags":["CWE-330","security"]},"shortDescription":{"text":"Use of Insufficiently Random Values"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"\"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize absolute path sequences such as\n\"/abs/path\" that can resolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/36.html for more information.\"\n"},"help":{"markdown":"\"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize absolute path sequences such as\n\"/abs/path\" that can resolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/36.html for more information.\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PT_ABSOLUTE_PATH_TRAVERSAL-1)\n","text":"\"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize absolute path sequences such as\n\"/abs/path\" that can resolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/36.html for more information.\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PT_ABSOLUTE_PATH_TRAVERSAL-1","id":"gitlab.find_sec_bugs_scala.PT_ABSOLUTE_PATH_TRAVERSAL-1","name":"gitlab.find_sec_bugs_scala.PT_ABSOLUTE_PATH_TRAVERSAL-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"\"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize sequences such as \"..\" that can\nresolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/23.html for more information.\"\n"},"help":{"markdown":"\"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize sequences such as \"..\" that can\nresolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/23.html for more information.\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PT_RELATIVE_PATH_TRAVERSAL-1)\n","text":"\"The software uses an HTTP request parameter to construct a pathname that should be within a\nrestricted directory, but it does not properly neutralize sequences such as \"..\" that can\nresolve to a location that is outside of that directory. See\nhttp://cwe.mitre.org/data/definitions/23.html for more information.\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.PT_RELATIVE_PATH_TRAVERSAL-1","id":"gitlab.find_sec_bugs_scala.PT_RELATIVE_PATH_TRAVERSAL-1","name":"gitlab.find_sec_bugs_scala.PT_RELATIVE_PATH_TRAVERSAL-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Constructing a server-side redirect path with user input could allow an\nattacker to download application binaries (including application classes or\njar files) or view arbitrary files within protected directories.\n"},"help":{"markdown":"Constructing a server-side redirect path with user input could allow an\nattacker to download application binaries (including application classes or\njar files) or view arbitrary files within protected directories.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1)\n","text":"Constructing a server-side redirect path with user input could allow an\nattacker to download application binaries (including application classes or\njar files) or view arbitrary files within protected directories.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1","id":"gitlab.find_sec_bugs_scala.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1","name":"gitlab.find_sec_bugs_scala.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1","properties":{"precision":"very-high","tags":["CWE-552","security"],"security-severity":"Info"},"shortDescription":{"text":"Files or Directories Accessible to External Parties"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Enabling extensions in Apache XML RPC server or client can lead to deserialization\nvulnerability which would allow an attacker to execute arbitrary code.\n"},"help":{"markdown":"Enabling extensions in Apache XML RPC server or client can lead to deserialization\nvulnerability which would allow an attacker to execute arbitrary code.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.RPC_ENABLED_EXTENSIONS-1)\n","text":"Enabling extensions in Apache XML RPC server or client can lead to deserialization\nvulnerability which would allow an attacker to execute arbitrary code.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.RPC_ENABLED_EXTENSIONS-1","id":"gitlab.find_sec_bugs_scala.RPC_ENABLED_EXTENSIONS-1","name":"gitlab.find_sec_bugs_scala.RPC_ENABLED_EXTENSIONS-1","properties":{"precision":"very-high","tags":["CWE-502","security"],"security-severity":"Info"},"shortDescription":{"text":"Deserialization of Untrusted Data"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Detected an insufficient key size for DSA. NIST recommends a key size\nof 2048 or higher.\n"},"help":{"markdown":"Detected an insufficient key size for DSA. NIST recommends a key size\nof 2048 or higher.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.RSA_KEY_SIZE-1)\n","text":"Detected an insufficient key size for DSA. NIST recommends a key size\nof 2048 or higher.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.RSA_KEY_SIZE-1","id":"gitlab.find_sec_bugs_scala.RSA_KEY_SIZE-1","name":"gitlab.find_sec_bugs_scala.RSA_KEY_SIZE-1","properties":{"precision":"very-high","tags":["CWE-326","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate Encryption Strength"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The software uses the RSA algorithm but does not incorporate Optimal Asymmetric\nEncryption Padding (OAEP), which might weaken the encryption.\n"},"help":{"markdown":"The software uses the RSA algorithm but does not incorporate Optimal Asymmetric\nEncryption Padding (OAEP), which might weaken the encryption.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.RSA_NO_PADDING-1)\n","text":"The software uses the RSA algorithm but does not incorporate Optimal Asymmetric\nEncryption Padding (OAEP), which might weaken the encryption.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.RSA_NO_PADDING-1","id":"gitlab.find_sec_bugs_scala.RSA_NO_PADDING-1","name":"gitlab.find_sec_bugs_scala.RSA_NO_PADDING-1","properties":{"precision":"very-high","tags":["CWE-780","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Medium"},"shortDescription":{"text":"Use of RSA Algorithm without OAEP"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Ignoring XML comments in SAML may lead to authentication bypass\n"},"help":{"markdown":"Ignoring XML comments in SAML may lead to authentication bypass\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SAML_IGNORE_COMMENTS-1)\n","text":"Ignoring XML comments in SAML may lead to authentication bypass\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SAML_IGNORE_COMMENTS-1","id":"gitlab.find_sec_bugs_scala.SAML_IGNORE_COMMENTS-1","name":"gitlab.find_sec_bugs_scala.SAML_IGNORE_COMMENTS-1","properties":{"precision":"very-high","tags":["CWE-287","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Authentication"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Server-Side Request Forgery occur when a web server executes a request to a user supplied\ndestination parameter that is not validated. Such vulnerabilities could allow an attacker to\naccess internal services or to launch attacks from your web server.\n"},"help":{"markdown":"Server-Side Request Forgery occur when a web server executes a request to a user supplied\ndestination parameter that is not validated. Such vulnerabilities could allow an attacker to\naccess internal services or to launch attacks from your web server.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCALA_PLAY_SSRF-1)\n","text":"Server-Side Request Forgery occur when a web server executes a request to a user supplied\ndestination parameter that is not validated. Such vulnerabilities could allow an attacker to\naccess internal services or to launch attacks from your web server.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCALA_PLAY_SSRF-1","id":"gitlab.find_sec_bugs_scala.SCALA_PLAY_SSRF-1","name":"gitlab.find_sec_bugs_scala.SCALA_PLAY_SSRF-1","properties":{"precision":"very-high","tags":["CWE-918","security"],"security-severity":"Medium"},"shortDescription":{"text":"Server-Side Request Forgery (SSRF)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Applications can unintentionally leak information about their configuration, internal\nworkings, or violate privacy through a variety of application problems. Pages that provide\ndifferent responses based on the validity of the data can lead to Information Leakage;\nspecifically when data deemed confidential is being revealed as a result of the web\napplication's design.\n"},"help":{"markdown":"Applications can unintentionally leak information about their configuration, internal\nworkings, or violate privacy through a variety of application problems. Pages that provide\ndifferent responses based on the validity of the data can lead to Information Leakage;\nspecifically when data deemed confidential is being revealed as a result of the web\napplication's design.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCALA_SENSITIVE_DATA_EXPOSURE-1)\n","text":"Applications can unintentionally leak information about their configuration, internal\nworkings, or violate privacy through a variety of application problems. Pages that provide\ndifferent responses based on the validity of the data can lead to Information Leakage;\nspecifically when data deemed confidential is being revealed as a result of the web\napplication's design.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCALA_SENSITIVE_DATA_EXPOSURE-1","id":"gitlab.find_sec_bugs_scala.SCALA_SENSITIVE_DATA_EXPOSURE-1","name":"gitlab.find_sec_bugs_scala.SCALA_SENSITIVE_DATA_EXPOSURE-1","properties":{"precision":"very-high","tags":["CWE-200","security"],"security-severity":"Info"},"shortDescription":{"text":"Information Exposure"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).\n"},"help":{"markdown":"Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCALA_XSS_MVC_API-1)\n","text":"Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCALA_XSS_MVC_API-1","id":"gitlab.find_sec_bugs_scala.SCALA_XSS_MVC_API-1","name":"gitlab.find_sec_bugs_scala.SCALA_XSS_MVC_API-1","properties":{"precision":"very-high","tags":["CWE-79","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The software constructs all or part of a code segment using externally-influenced\ninput from an upstream component, but it does not neutralize or incorrectly\nneutralizes special elements that could modify the syntax or behavior of the\nintended code segment.\n"},"help":{"markdown":"The software constructs all or part of a code segment using externally-influenced\ninput from an upstream component, but it does not neutralize or incorrectly\nneutralizes special elements that could modify the syntax or behavior of the\nintended code segment.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1)\n","text":"The software constructs all or part of a code segment using externally-influenced\ninput from an upstream component, but it does not neutralize or incorrectly\nneutralizes special elements that could modify the syntax or behavior of the\nintended code segment.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1","id":"gitlab.find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1","name":"gitlab.find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-94","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Control of Generation of Code ('Code Injection')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The software constructs all or part of a code segment using externally-influenced\ninput from an upstream component, but it does not neutralize or incorrectly\nneutralizes special elements that could modify the syntax or behavior of the\nintended code segment.\n"},"help":{"markdown":"The software constructs all or part of a code segment using externally-influenced\ninput from an upstream component, but it does not neutralize or incorrectly\nneutralizes special elements that could modify the syntax or behavior of the\nintended code segment.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-2)\n","text":"The software constructs all or part of a code segment using externally-influenced\ninput from an upstream component, but it does not neutralize or incorrectly\nneutralizes special elements that could modify the syntax or behavior of the\nintended code segment.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-2","id":"gitlab.find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-2","name":"gitlab.find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-2","properties":{"precision":"very-high","tags":["CWE-94","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Control of Generation of Code ('Code Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"The Servlet can read GET and POST parameters from various methods. The\nvalue obtained should be considered unsafe.\"\n"},"help":{"markdown":"The Servlet can read GET and POST parameters from various methods. The\nvalue obtained should be considered unsafe.\"\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1)\n","text":"The Servlet can read GET and POST parameters from various methods. The\nvalue obtained should be considered unsafe.\"\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1","id":"gitlab.find_sec_bugs_scala.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1","name":"gitlab.find_sec_bugs_scala.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1","properties":{"precision":"very-high","tags":["CWE-20","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Simple Mail Transfer Protocol (SMTP) is a the text based protocol used for\nemail delivery. Like with HTTP, headers are separate by new line separator. If\nkuser input is place in a header line, the application should remove or replace\nnew line characters (CR / LF). You should use a safe wrapper such as Apache\nCommon Email and Simple Java Mail which filter special characters that can lead\nto header injection.\n"},"help":{"markdown":"Simple Mail Transfer Protocol (SMTP) is a the text based protocol used for\nemail delivery. Like with HTTP, headers are separate by new line separator. If\nkuser input is place in a header line, the application should remove or replace\nnew line characters (CR / LF). You should use a safe wrapper such as Apache\nCommon Email and Simple Java Mail which filter special characters that can lead\nto header injection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SMTP_HEADER_INJECTION-1)\n","text":"Simple Mail Transfer Protocol (SMTP) is a the text based protocol used for\nemail delivery. Like with HTTP, headers are separate by new line separator. If\nkuser input is place in a header line, the application should remove or replace\nnew line characters (CR / LF). You should use a safe wrapper such as Apache\nCommon Email and Simple Java Mail which filter special characters that can lead\nto header injection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SMTP_HEADER_INJECTION-1","id":"gitlab.find_sec_bugs_scala.SMTP_HEADER_INJECTION-1","name":"gitlab.find_sec_bugs_scala.SMTP_HEADER_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-77","security"],"security-severity":"High"},"shortDescription":{"text":"Improper Neutralization of Special Elements used in a Command"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"help":{"markdown":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SCALA_SQL_INJECTION_SLICK-1)\n","text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SCALA_SQL_INJECTION_SLICK-1","id":"gitlab.find_sec_bugs_scala.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SCALA_SQL_INJECTION_SLICK-1","name":"gitlab.find_sec_bugs_scala.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SCALA_SQL_INJECTION_SLICK-1","properties":{"precision":"very-high","tags":["CWE-89","OWASP-A03:2021-Injection","OWASP-A1:2017-Injection","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middleattacks\nattacks since the client will trust any certificate.\n"},"help":{"markdown":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middleattacks\nattacks since the client will trust any certificate.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SSL_CONTEXT-1)\n","text":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middleattacks\nattacks since the client will trust any certificate.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.SSL_CONTEXT-1","id":"gitlab.find_sec_bugs_scala.SSL_CONTEXT-1","name":"gitlab.find_sec_bugs_scala.SSL_CONTEXT-1","properties":{"precision":"very-high","tags":["CWE-295","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Certificate Validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Form inputs should have minimal input validation. Preventive validation helps provide defense\nin depth against a variety of risks.\n"},"help":{"markdown":"Form inputs should have minimal input validation. Preventive validation helps provide defense\nin depth against a variety of risks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.STRUTS_FORM_VALIDATION-1)\n","text":"Form inputs should have minimal input validation. Preventive validation helps provide defense\nin depth against a variety of risks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.STRUTS_FORM_VALIDATION-1","id":"gitlab.find_sec_bugs_scala.STRUTS_FORM_VALIDATION-1","name":"gitlab.find_sec_bugs_scala.STRUTS_FORM_VALIDATION-1","properties":{"precision":"very-high","tags":["CWE-20","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Input Validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Triple DES (also known as 3DES or DESede) is considered strong ciphers for modern\napplications. NIST recommends the usage of AES block ciphers instead of 3DES.\n"},"help":{"markdown":"Triple DES (also known as 3DES or DESede) is considered strong ciphers for modern\napplications. NIST recommends the usage of AES block ciphers instead of 3DES.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.TDES_USAGE-1)\n","text":"Triple DES (also known as 3DES or DESede) is considered strong ciphers for modern\napplications. NIST recommends the usage of AES block ciphers instead of 3DES.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.TDES_USAGE-1","id":"gitlab.find_sec_bugs_scala.TDES_USAGE-1","name":"gitlab.find_sec_bugs_scala.TDES_USAGE-1","properties":{"precision":"very-high","tags":["CWE-326","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate Encryption Strength"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A malicious user in control of a template can run malicious code on the\nserver-side. Velocity templates should be seen as scripts.\n"},"help":{"markdown":"A malicious user in control of a template can run malicious code on the\nserver-side. Velocity templates should be seen as scripts.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1)\n","text":"A malicious user in control of a template can run malicious code on the\nserver-side. Velocity templates should be seen as scripts.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1","id":"gitlab.find_sec_bugs_scala.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1","name":"gitlab.find_sec_bugs_scala.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1","properties":{"precision":"very-high","tags":["CWE-94","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Control of Generation of Code ('Code Injection')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A trust boundary can be thought of as line drawn through a program. On one side\nof the line, data is untrusted. On the other side of the line, data is assumed\nto be trustworthy. The purpose of validation logic is to allow data to safely\ncross the trust boundary - to move from untrusted to trusted. A trust boundary\nviolation occurs when a program blurs the line between what is trusted and what\nis untrusted. By combining trusted and untrusted data in the same data\nstructure, it becomes easier for programmers to mistakenly trust unvalidated\ndata.\n"},"help":{"markdown":"A trust boundary can be thought of as line drawn through a program. On one side\nof the line, data is untrusted. On the other side of the line, data is assumed\nto be trustworthy. The purpose of validation logic is to allow data to safely\ncross the trust boundary - to move from untrusted to trusted. A trust boundary\nviolation occurs when a program blurs the line between what is trusted and what\nis untrusted. By combining trusted and untrusted data in the same data\nstructure, it becomes easier for programmers to mistakenly trust unvalidated\ndata.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.TRUST_BOUNDARY_VIOLATION-1)\n","text":"A trust boundary can be thought of as line drawn through a program. On one side\nof the line, data is untrusted. On the other side of the line, data is assumed\nto be trustworthy. The purpose of validation logic is to allow data to safely\ncross the trust boundary - to move from untrusted to trusted. A trust boundary\nviolation occurs when a program blurs the line between what is trusted and what\nis untrusted. By combining trusted and untrusted data in the same data\nstructure, it becomes easier for programmers to mistakenly trust unvalidated\ndata.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.TRUST_BOUNDARY_VIOLATION-1","id":"gitlab.find_sec_bugs_scala.TRUST_BOUNDARY_VIOLATION-1","name":"gitlab.find_sec_bugs_scala.TRUST_BOUNDARY_VIOLATION-1","properties":{"precision":"very-high","tags":["CWE-501","security"],"security-severity":"Info"},"shortDescription":{"text":"Trust Boundary Violation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Beyond using an SSL socket, you need to make sure your use of SSLSocketFactory\ndoes all the appropriate certificate validation checks to make sure you are not\nsubject to man-in-the-middle attacks. Please read the OWASP Transport Layer\nProtection Cheat Sheet for details on how to do this correctly.\n"},"help":{"markdown":"Beyond using an SSL socket, you need to make sure your use of SSLSocketFactory\ndoes all the appropriate certificate validation checks to make sure you are not\nsubject to man-in-the-middle attacks. Please read the OWASP Transport Layer\nProtection Cheat Sheet for details on how to do this correctly.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1)\n","text":"Beyond using an SSL socket, you need to make sure your use of SSLSocketFactory\ndoes all the appropriate certificate validation checks to make sure you are not\nsubject to man-in-the-middle attacks. Please read the OWASP Transport Layer\nProtection Cheat Sheet for details on how to do this correctly.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1","id":"gitlab.find_sec_bugs_scala.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1","name":"gitlab.find_sec_bugs_scala.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1","properties":{"precision":"very-high","tags":["CWE-319","OWASP-A02:2021-Cryptographic Failures","OWASP-A3:2017-Sensitive Data Exposure","security"],"security-severity":"Info"},"shortDescription":{"text":"Cleartext transmission of sensitive information"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Unvalidated redirects occur when an application redirects a user to a\ndestination URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities can be used to facilitate phishing attacks.\n"},"help":{"markdown":"Unvalidated redirects occur when an application redirects a user to a\ndestination URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities can be used to facilitate phishing attacks.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.UNVALIDATED_REDIRECT-1.URL_REWRITING-1)\n","text":"Unvalidated redirects occur when an application redirects a user to a\ndestination URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities can be used to facilitate phishing attacks.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.UNVALIDATED_REDIRECT-1.URL_REWRITING-1","id":"gitlab.find_sec_bugs_scala.UNVALIDATED_REDIRECT-1.URL_REWRITING-1","name":"gitlab.find_sec_bugs_scala.UNVALIDATED_REDIRECT-1.URL_REWRITING-1","properties":{"precision":"very-high","tags":["CWE-601","security"],"security-severity":"Info"},"shortDescription":{"text":"URL Redirection to Untrusted Site ('Open Redirect')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Server-Side Request Forgery occur when a web server executes a request to a user supplied\ndestination parameter that is not validated. Such vulnerabilities could allow an attacker to\naccess internal services or to launch attacks from your web server.\n"},"help":{"markdown":"Server-Side Request Forgery occur when a web server executes a request to a user supplied\ndestination parameter that is not validated. Such vulnerabilities could allow an attacker to\naccess internal services or to launch attacks from your web server.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.URLCONNECTION_SSRF_FD-1)\n","text":"Server-Side Request Forgery occur when a web server executes a request to a user supplied\ndestination parameter that is not validated. Such vulnerabilities could allow an attacker to\naccess internal services or to launch attacks from your web server.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.URLCONNECTION_SSRF_FD-1","id":"gitlab.find_sec_bugs_scala.URLCONNECTION_SSRF_FD-1","name":"gitlab.find_sec_bugs_scala.URLCONNECTION_SSRF_FD-1","properties":{"precision":"very-high","tags":["CWE-918","security"],"security-severity":"Low"},"shortDescription":{"text":"Server-Side Request Forgery (SSRF)"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A file is opened to read its content. The filename comes from an input\nparameter. If an unfiltered parameter is passed to this file API, files from an\narbitrary filesystem location could be read.\n"},"help":{"markdown":"A file is opened to read its content. The filename comes from an input\nparameter. If an unfiltered parameter is passed to this file API, files from an\narbitrary filesystem location could be read.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.WEAK_FILENAMEUTILS-1)\n","text":"A file is opened to read its content. The filename comes from an input\nparameter. If an unfiltered parameter is passed to this file API, files from an\narbitrary filesystem location could be read.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.WEAK_FILENAMEUTILS-1","id":"gitlab.find_sec_bugs_scala.WEAK_FILENAMEUTILS-1","name":"gitlab.find_sec_bugs_scala.WEAK_FILENAMEUTILS-1","properties":{"precision":"very-high","tags":["CWE-22","OWASP-A01:2021-Broken Access Control","OWASP-A5:2017-Broken Access Control","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper limitation of a pathname to a restricted directory ('Path Traversal')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middle\nattacks since the client will trust any certificate.\n"},"help":{"markdown":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middle\nattacks since the client will trust any certificate.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1)\n","text":"A HostnameVerifier that accept any host are often use because of certificate\nreuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middle\nattacks since the client will trust any certificate.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1","id":"gitlab.find_sec_bugs_scala.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1","name":"gitlab.find_sec_bugs_scala.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1","properties":{"precision":"very-high","tags":["CWE-295","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Certificate Validation"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n"},"help":{"markdown":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1)\n","text":"DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage\nof AES block ciphers instead of DES.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","id":"gitlab.find_sec_bugs_scala.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","name":"gitlab.find_sec_bugs_scala.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","properties":{"precision":"very-high","tags":["CWE-326","security"],"security-severity":"Medium"},"shortDescription":{"text":"Inadequate Encryption Strength"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).\n"},"help":{"markdown":"Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.WICKET_XSS1-1)\n","text":"Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.WICKET_XSS1-1","id":"gitlab.find_sec_bugs_scala.WICKET_XSS1-1","name":"gitlab.find_sec_bugs_scala.WICKET_XSS1-1","properties":{"precision":"very-high","tags":["CWE-79","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Avoid using XMLDecoder to parse content from an untrusted source.\n"},"help":{"markdown":"Avoid using XMLDecoder to parse content from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XML_DECODER-1)\n","text":"Avoid using XMLDecoder to parse content from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XML_DECODER-1","id":"gitlab.find_sec_bugs_scala.XML_DECODER-1","name":"gitlab.find_sec_bugs_scala.XML_DECODER-1","properties":{"precision":"very-high","tags":["CWE-502","security"],"security-severity":"High"},"shortDescription":{"text":"Deserialization of Untrusted Data"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"help":{"markdown":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XPATH_INJECTION-1)\n","text":"The input values included in SQL queries need to be passed in safely. Bind\nvariables in prepared statements can be used to easily mitigate the risk of\nSQL injection.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XPATH_INJECTION-1","id":"gitlab.find_sec_bugs_scala.XPATH_INJECTION-1","name":"gitlab.find_sec_bugs_scala.XPATH_INJECTION-1","properties":{"precision":"very-high","tags":["CWE-611","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Restriction of XML External Entity Reference ('XXE')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Servlet reflected cross site scripting vulnerability\n"},"help":{"markdown":"Servlet reflected cross site scripting vulnerability\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1)\n","text":"Servlet reflected cross site scripting vulnerability\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1","id":"gitlab.find_sec_bugs_scala.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1","name":"gitlab.find_sec_bugs_scala.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1","properties":{"precision":"very-high","tags":["CWE-79","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Neutralization of Input During Web Page Generation"}},{"defaultConfiguration":{"level":"note"},"fullDescription":{"text":"Avoid using custom XSS filtering. Please use standard sanitization functions.\n"},"help":{"markdown":"Avoid using custom XSS filtering. Please use standard sanitization functions.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XSS_REQUEST_WRAPPER-1)\n","text":"Avoid using custom XSS filtering. Please use standard sanitization functions.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XSS_REQUEST_WRAPPER-1","id":"gitlab.find_sec_bugs_scala.XSS_REQUEST_WRAPPER-1","name":"gitlab.find_sec_bugs_scala.XSS_REQUEST_WRAPPER-1","properties":{"precision":"very-high","tags":["CWE-79","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A potential XSS was found. It could be used to execute unwanted JavaScript in a\nclient's browser.\n"},"help":{"markdown":"A potential XSS was found. It could be used to execute unwanted JavaScript in a\nclient's browser.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XSS_SERVLET-1)\n","text":"A potential XSS was found. It could be used to execute unwanted JavaScript in a\nclient's browser.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XSS_SERVLET-1","id":"gitlab.find_sec_bugs_scala.XSS_SERVLET-1","name":"gitlab.find_sec_bugs_scala.XSS_SERVLET-1","properties":{"precision":"very-high","tags":["CWE-79","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_DOCUMENT-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_DOCUMENT-1","id":"gitlab.find_sec_bugs_scala.XXE_DOCUMENT-1","name":"gitlab.find_sec_bugs_scala.XXE_DOCUMENT-1","properties":{"precision":"very-high","tags":["CWE-611","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Restriction of XML External Entity Reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1","id":"gitlab.find_sec_bugs_scala.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1","name":"gitlab.find_sec_bugs_scala.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1","properties":{"precision":"very-high","tags":["CWE-611","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Restriction of XML External Entity Reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_SAXPARSER-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_SAXPARSER-1","id":"gitlab.find_sec_bugs_scala.XXE_SAXPARSER-1","name":"gitlab.find_sec_bugs_scala.XXE_SAXPARSER-1","properties":{"precision":"very-high","tags":["CWE-611","security"],"security-severity":"Info"},"shortDescription":{"text":"Improper Restriction of XML External Entity Reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_XMLREADER-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_XMLREADER-1","id":"gitlab.find_sec_bugs_scala.XXE_XMLREADER-1","name":"gitlab.find_sec_bugs_scala.XXE_XMLREADER-1","properties":{"precision":"very-high","tags":["CWE-611","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Restriction of XML External Entity Reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_XMLSTREAMREADER-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_XMLSTREAMREADER-1","id":"gitlab.find_sec_bugs_scala.XXE_XMLSTREAMREADER-1","name":"gitlab.find_sec_bugs_scala.XXE_XMLSTREAMREADER-1","properties":{"precision":"very-high","tags":["CWE-611","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Restriction of XML External Entity Reference ('XXE')"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"help":{"markdown":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_XPATH-1)\n","text":"XML External Entity (XXE) attacks can occur when an XML parser supports XML\nentities while processing XML received from an untrusted source.\n"},"helpUri":"https://semgrep.dev/r/gitlab.find_sec_bugs_scala.XXE_XPATH-1","id":"gitlab.find_sec_bugs_scala.XXE_XPATH-1","name":"gitlab.find_sec_bugs_scala.XXE_XPATH-1","properties":{"precision":"very-high","tags":["CWE-611","security"],"security-severity":"Medium"},"shortDescription":{"text":"Improper Restriction of XML External Entity Reference ('XXE')"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Detected a potential path traversal. A malicious actor could control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are sanitized. You may also consider using a utility method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file name from the path."},"help":{"markdown":"Detected a potential path traversal. A malicious actor could control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are sanitized. You may also consider using a utility method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file name from the path.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal)\n - [https://www.owasp.org/index.php/Path_Traversal](https://www.owasp.org/index.php/Path_Traversal)\n","text":"Detected a potential path traversal. A malicious actor could control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are sanitized. You may also consider using a utility method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file name from the path."},"helpUri":"https://semgrep.dev/r/java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal","id":"java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal","name":"java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal","properties":{"precision":"very-high","tags":["CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')","MEDIUM CONFIDENCE","OWASP-A01:2021 - Broken Access Control","OWASP-A05:2017 - Broken Access Control","security"]},"shortDescription":{"text":"Semgrep Finding: java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Detected anonymous LDAP bind. This permits anonymous users to execute LDAP statements. Consider enforcing authentication for LDAP. See https://docs.oracle.com/javase/tutorial/jndi/ldap/auth_mechs.html for more information."},"help":{"markdown":"Detected anonymous LDAP bind. This permits anonymous users to execute LDAP statements. Consider enforcing authentication for LDAP. See https://docs.oracle.com/javase/tutorial/jndi/ldap/auth_mechs.html for more information.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind)\n - [https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures](https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures)\n","text":"Detected anonymous LDAP bind. This permits anonymous users to execute LDAP statements. Consider enforcing authentication for LDAP. See https://docs.oracle.com/javase/tutorial/jndi/ldap/auth_mechs.html for more information."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind","id":"java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind","name":"java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind","properties":{"precision":"very-high","tags":["CWE-287: Improper Authentication","LOW CONFIDENCE","OWASP-A02:2017 - Broken Authentication","OWASP-A07:2021 - Identification and Authentication Failures","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format(\"%02X\", ...)' instead."},"help":{"markdown":"'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format(\"%02X\", ...)' instead.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion)\n - [https://cwe.mitre.org/data/definitions/704.html](https://cwe.mitre.org/data/definitions/704.html)\n","text":"'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format(\"%02X\", ...)' instead."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion","id":"java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion","name":"java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion","properties":{"precision":"very-high","tags":["CWE-704: Incorrect Type Conversion or Cast","LOW CONFIDENCE","OWASP-A03:2017 - Sensitive Data Exposure","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"A formatted or concatenated string was detected as input to a java.lang.Runtime call. This is dangerous if a variable is controlled by user input and could result in a command injection. Ensure your variables are not controlled by users or sufficiently sanitized."},"help":{"markdown":"A formatted or concatenated string was detected as input to a java.lang.Runtime call. This is dangerous if a variable is controlled by user input and could result in a command injection. Ensure your variables are not controlled by users or sufficiently sanitized.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"A formatted or concatenated string was detected as input to a java.lang.Runtime call. This is dangerous if a variable is controlled by user input and could result in a command injection. Ensure your variables are not controlled by users or sufficiently sanitized."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call","id":"java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call","name":"java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call","properties":{"precision":"very-high","tags":["CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')","LOW CONFIDENCE","OWASP-A01:2017 - Injection","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A cookie was detected without setting the 'HttpOnly' flag. The 'HttpOnly' flag for cookies instructs the browser to forbid client-side scripts from reading the cookie. Set the 'HttpOnly' flag by calling 'cookie.setHttpOnly(true);'"},"help":{"markdown":"A cookie was detected without setting the 'HttpOnly' flag. The 'HttpOnly' flag for cookies instructs the browser to forbid client-side scripts from reading the cookie. Set the 'HttpOnly' flag by calling 'cookie.setHttpOnly(true);'\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly)\n - [https://owasp.org/Top10/A05_2021-Security_Misconfiguration](https://owasp.org/Top10/A05_2021-Security_Misconfiguration)\n","text":"A cookie was detected without setting the 'HttpOnly' flag. The 'HttpOnly' flag for cookies instructs the browser to forbid client-side scripts from reading the cookie. Set the 'HttpOnly' flag by calling 'cookie.setHttpOnly(true);'"},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly","id":"java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly","name":"java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly","properties":{"precision":"very-high","tags":["CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag","LOW CONFIDENCE","OWASP-A05:2021 - Security Misconfiguration","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A cookie was detected without setting the 'secure' flag. The 'secure' flag for cookies prevents the client from transmitting the cookie over insecure channels such as HTTP. Set the 'secure' flag by calling '$COOKIE.setSecure(true);'"},"help":{"markdown":"A cookie was detected without setting the 'secure' flag. The 'secure' flag for cookies prevents the client from transmitting the cookie over insecure channels such as HTTP. Set the 'secure' flag by calling '$COOKIE.setSecure(true);'\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag)\n - [https://owasp.org/Top10/A05_2021-Security_Misconfiguration](https://owasp.org/Top10/A05_2021-Security_Misconfiguration)\n","text":"A cookie was detected without setting the 'secure' flag. The 'secure' flag for cookies prevents the client from transmitting the cookie over insecure channels such as HTTP. Set the 'secure' flag by calling '$COOKIE.setSecure(true);'"},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag","id":"java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag","name":"java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag","properties":{"precision":"very-high","tags":["CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute","LOW CONFIDENCE","OWASP-A05:2021 - Security Misconfiguration","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"When data from an untrusted source is put into a logger and not neutralized correctly, an attacker could forge log entries or include malicious content."},"help":{"markdown":"When data from an untrusted source is put into a logger and not neutralized correctly, an attacker could forge log entries or include malicious content.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crlf-injection-logs.crlf-injection-logs)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"When data from an untrusted source is put into a logger and not neutralized correctly, an attacker could forge log entries or include malicious content."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crlf-injection-logs.crlf-injection-logs","id":"java.lang.security.audit.crlf-injection-logs.crlf-injection-logs","name":"java.lang.security.audit.crlf-injection-logs.crlf-injection-logs","properties":{"precision":"very-high","tags":["CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')","MEDIUM CONFIDENCE","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crlf-injection-logs.crlf-injection-logs"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"DES is considered deprecated. AES is the recommended cipher. Upgrade to use AES. See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information."},"help":{"markdown":"DES is considered deprecated. AES is the recommended cipher. Upgrade to use AES. See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated)\n - [https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard](https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard)\n - [https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms)\n","text":"DES is considered deprecated. AES is the recommended cipher. Upgrade to use AES. See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated","id":"java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated","name":"java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated","properties":{"precision":"very-high","tags":["CWE-326: Inadequate Encryption Strength","HIGH CONFIDENCE","OWASP-A02:2021 - Cryptographic Failures","OWASP-A03:2017 - Sensitive Data Exposure","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher. Upgrade to use AES."},"help":{"markdown":"Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher. Upgrade to use AES.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated)\n - [https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA](https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA)\n","text":"Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher. Upgrade to use AES."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated","id":"java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated","name":"java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated","properties":{"precision":"very-high","tags":["CWE-326: Inadequate Encryption Strength","HIGH CONFIDENCE","OWASP-A02:2021 - Cryptographic Failures","OWASP-A03:2017 - Sensitive Data Exposure","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"NullCipher was detected. This will not encrypt anything; the cipher text will be the same as the plain text. Use a valid, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\"). See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions for more information."},"help":{"markdown":"NullCipher was detected. This will not encrypt anything; the cipher text will be the same as the plain text. Use a valid, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\"). See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions for more information.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.no-null-cipher.no-null-cipher)\n - [https://owasp.org/Top10/A02_2021-Cryptographic_Failures](https://owasp.org/Top10/A02_2021-Cryptographic_Failures)\n","text":"NullCipher was detected. This will not encrypt anything; the cipher text will be the same as the plain text. Use a valid, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\"). See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions for more information."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.no-null-cipher.no-null-cipher","id":"java.lang.security.audit.crypto.no-null-cipher.no-null-cipher","name":"java.lang.security.audit.crypto.no-null-cipher.no-null-cipher","properties":{"precision":"very-high","tags":["CWE-327: Use of a Broken or Risky Cryptographic Algorithm","HIGH CONFIDENCE","OWASP-A02:2021 - Cryptographic Failures","OWASP-A03:2017 - Sensitive Data Exposure","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.no-null-cipher.no-null-cipher"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Initialization Vectors (IVs) for block ciphers should be randomly generated each time they are used. Using a static IV means the same plaintext encrypts to the same ciphertext every time, weakening the strength of the encryption."},"help":{"markdown":"Initialization Vectors (IVs) for block ciphers should be randomly generated each time they are used. Using a static IV means the same plaintext encrypts to the same ciphertext every time, weakening the strength of the encryption.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector)\n - [https://cwe.mitre.org/data/definitions/329.html](https://cwe.mitre.org/data/definitions/329.html)\n","text":"Initialization Vectors (IVs) for block ciphers should be randomly generated each time they are used. Using a static IV means the same plaintext encrypts to the same ciphertext every time, weakening the strength of the encryption."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector","id":"java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector","name":"java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector","properties":{"precision":"very-high","tags":["CWE-329: Generation of Predictable IV with CBC Mode","HIGH CONFIDENCE","OWASP-A02:2021 - Cryptographic Failures","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Using RSA without OAEP mode weakens the encryption."},"help":{"markdown":"Using RSA without OAEP mode weakens the encryption.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding)\n - [https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/](https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/)\n","text":"Using RSA without OAEP mode weakens the encryption."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding","id":"java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding","name":"java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding","properties":{"precision":"very-high","tags":["CWE-326: Inadequate Encryption Strength","HIGH CONFIDENCE","OWASP-A02:2021 - Cryptographic Failures","OWASP-A03:2017 - Sensitive Data Exposure","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Cryptographic algorithms are notoriously difficult to get right. By implementing a custom message digest, you risk introducing security issues into your program. Use one of the many sound message digests already available to you: MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA256\");"},"help":{"markdown":"Cryptographic algorithms are notoriously difficult to get right. By implementing a custom message digest, you risk introducing security issues into your program. Use one of the many sound message digests already available to you: MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA256\");\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests)\n - [https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#custom-algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#custom-algorithms)\n","text":"Cryptographic algorithms are notoriously difficult to get right. By implementing a custom message digest, you risk introducing security issues into your program. Use one of the many sound message digests already available to you: MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA256\");"},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests","id":"java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests","name":"java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests","properties":{"precision":"very-high","tags":["CWE-327: Use of a Broken or Risky Cryptographic Algorithm","LOW CONFIDENCE","OWASP-A02:2021 - Cryptographic Failures","OWASP-A03:2017 - Sensitive Data Exposure","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"DefaultHttpClient is deprecated. Further, it does not support connections using TLS1.2, which makes using DefaultHttpClient a security hazard. Use HttpClientBuilder instead."},"help":{"markdown":"DefaultHttpClient is deprecated. Further, it does not support connections using TLS1.2, which makes using DefaultHttpClient a security hazard. Use HttpClientBuilder instead.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated)\n - [https://owasp.org/Top10/A02_2021-Cryptographic_Failures](https://owasp.org/Top10/A02_2021-Cryptographic_Failures)\n","text":"DefaultHttpClient is deprecated. Further, it does not support connections using TLS1.2, which makes using DefaultHttpClient a security hazard. Use HttpClientBuilder instead."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated","id":"java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated","name":"java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated","properties":{"precision":"very-high","tags":["CWE-326: Inadequate Encryption Strength","LOW CONFIDENCE","OWASP-A02:2021 - Cryptographic Failures","OWASP-A03:2017 - Sensitive Data Exposure","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Insecure HostnameVerifier implementation detected. This will accept any SSL certificate with any hostname, which creates the possibility for man-in-the-middle attacks."},"help":{"markdown":"Insecure HostnameVerifier implementation detected. This will accept any SSL certificate with any hostname, which creates the possibility for man-in-the-middle attacks.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier)\n - [https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures](https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures)\n","text":"Insecure HostnameVerifier implementation detected. This will accept any SSL certificate with any hostname, which creates the possibility for man-in-the-middle attacks."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier","id":"java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier","name":"java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier","properties":{"precision":"very-high","tags":["CWE-295: Improper Certificate Validation","LOW CONFIDENCE","OWASP-A03:2017 - Sensitive Data Exposure","OWASP-A07:2021 - Identification and Authentication Failures","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Detected empty trust manager implementations. This is dangerous because it accepts any certificate, enabling man-in-the-middle attacks. Consider using a KeyStore and TrustManagerFactory instead. See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https for more information."},"help":{"markdown":"Detected empty trust manager implementations. This is dangerous because it accepts any certificate, enabling man-in-the-middle attacks. Consider using a KeyStore and TrustManagerFactory instead. See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https for more information.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager)\n - [https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https](https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https)\n","text":"Detected empty trust manager implementations. This is dangerous because it accepts any certificate, enabling man-in-the-middle attacks. Consider using a KeyStore and TrustManagerFactory instead. See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https for more information."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager","id":"java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager","name":"java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager","properties":{"precision":"very-high","tags":["CWE-295: Improper Certificate Validation","LOW CONFIDENCE","OWASP-A03:2017 - Sensitive Data Exposure","OWASP-A07:2021 - Identification and Authentication Failures","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Detected use of a Java socket that is not encrypted. As a result, the traffic could be read by an attacker intercepting the network traffic. Use an SSLSocket created by 'SSLSocketFactory' or 'SSLServerSocketFactory' instead."},"help":{"markdown":"Detected use of a Java socket that is not encrypted. As a result, the traffic could be read by an attacker intercepting the network traffic. Use an SSLSocket created by 'SSLSocketFactory' or 'SSLServerSocketFactory' instead.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket)\n - [https://owasp.org/Top10/A02_2021-Cryptographic_Failures](https://owasp.org/Top10/A02_2021-Cryptographic_Failures)\n","text":"Detected use of a Java socket that is not encrypted. As a result, the traffic could be read by an attacker intercepting the network traffic. Use an SSLSocket created by 'SSLSocketFactory' or 'SSLServerSocketFactory' instead."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket","id":"java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket","name":"java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket","properties":{"precision":"very-high","tags":["CWE-319: Cleartext Transmission of Sensitive Information","HIGH CONFIDENCE","OWASP-A02:2021 - Cryptographic Failures","OWASP-A03:2017 - Sensitive Data Exposure","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation."},"help":{"markdown":"An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.el-injection.el-injection)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.el-injection.el-injection","id":"java.lang.security.audit.el-injection.el-injection","name":"java.lang.security.audit.el-injection.el-injection","properties":{"precision":"very-high","tags":["CWE-94: Improper Control of Generation of Code ('Code Injection')","LOW CONFIDENCE","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.el-injection.el-injection"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. To build SQL queries safely in Java, it is possible to adopt prepared statements by using the `java.sql.PreparedStatement` class with bind variables."},"help":{"markdown":"Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. To build SQL queries safely in Java, it is possible to adopt prepared statements by using the `java.sql.PreparedStatement` class with bind variables.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.formatted-sql-string-deepsemgrep.formatted-sql-string-deepsemgrep)\n - [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n - [https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps)\n - [https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement](https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement)\n","text":"Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. To build SQL queries safely in Java, it is possible to adopt prepared statements by using the `java.sql.PreparedStatement` class with bind variables."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.formatted-sql-string-deepsemgrep.formatted-sql-string-deepsemgrep","id":"java.lang.security.audit.formatted-sql-string-deepsemgrep.formatted-sql-string-deepsemgrep","name":"java.lang.security.audit.formatted-sql-string-deepsemgrep.formatted-sql-string-deepsemgrep","properties":{"precision":"very-high","tags":["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')","MEDIUM CONFIDENCE","OWASP-A01:2017 - Injection","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.formatted-sql-string-deepsemgrep.formatted-sql-string-deepsemgrep"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'."},"help":{"markdown":"Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.formatted-sql-string.formatted-sql-string)\n - [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n - [https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps)\n - [https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement](https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement)\n","text":"Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.formatted-sql-string.formatted-sql-string","id":"java.lang.security.audit.formatted-sql-string.formatted-sql-string","name":"java.lang.security.audit.formatted-sql-string.formatted-sql-string","properties":{"precision":"very-high","tags":["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')","MEDIUM CONFIDENCE","OWASP-A01:2017 - Injection","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.formatted-sql-string.formatted-sql-string"}},{"defaultConfiguration":{"level":"note"},"fullDescription":{"text":"Older Java application servers are vulnerable to HTTP response splitting, which may occur if an HTTP request can be injected with CRLF characters. This finding is reported for completeness; it is recommended to ensure your environment is not affected by testing this yourself."},"help":{"markdown":"Older Java application servers are vulnerable to HTTP response splitting, which may occur if an HTTP request can be injected with CRLF characters. This finding is reported for completeness; it is recommended to ensure your environment is not affected by testing this yourself.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.http-response-splitting.http-response-splitting)\n - [https://www.owasp.org/index.php/HTTP_Response_Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting)\n","text":"Older Java application servers are vulnerable to HTTP response splitting, which may occur if an HTTP request can be injected with CRLF characters. This finding is reported for completeness; it is recommended to ensure your environment is not affected by testing this yourself."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.http-response-splitting.http-response-splitting","id":"java.lang.security.audit.http-response-splitting.http-response-splitting","name":"java.lang.security.audit.http-response-splitting.http-response-splitting","properties":{"precision":"very-high","tags":["CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')","MEDIUM CONFIDENCE","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.http-response-splitting.http-response-splitting"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Insecure SMTP connection detected. This connection will trust any SSL certificate. Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'."},"help":{"markdown":"Insecure SMTP connection detected. This connection will trust any SSL certificate. Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection)\n - [https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures](https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures)\n","text":"Insecure SMTP connection detected. This connection will trust any SSL certificate. Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection","id":"java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection","name":"java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection","properties":{"precision":"very-high","tags":["CWE-297: Improper Validation of Certificate with Host Mismatch","MEDIUM CONFIDENCE","OWASP-A07:2021 - Identification and Authentication Failures","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Possible JDBC injection detected. Use the parameterized query feature available in queryForObject instead of concatenating or formatting strings: 'jdbc.queryForObject(\"select * from table where name = ?\", Integer.class, parameterName);'"},"help":{"markdown":"Possible JDBC injection detected. Use the parameterized query feature available in queryForObject instead of concatenating or formatting strings: 'jdbc.queryForObject(\"select * from table where name = ?\", Integer.class, parameterName);'\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"Possible JDBC injection detected. Use the parameterized query feature available in queryForObject instead of concatenating or formatting strings: 'jdbc.queryForObject(\"select * from table where name = ?\", Integer.class, parameterName);'"},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string","id":"java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string","name":"java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string","properties":{"precision":"very-high","tags":["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')","LOW CONFIDENCE","OWASP-A01:2017 - Injection","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"An object-returning LDAP search will allow attackers to control the LDAP response. This could lead to Remote Code Execution."},"help":{"markdown":"An object-returning LDAP search will allow attackers to control the LDAP response. This could lead to Remote Code Execution.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning)\n - [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf)\n - [https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n","text":"An object-returning LDAP search will allow attackers to control the LDAP response. This could lead to Remote Code Execution."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning","id":"java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning","name":"java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning","properties":{"precision":"very-high","tags":["CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')","LOW CONFIDENCE","OWASP-A01:2017 - Injection","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Detected non-constant data passed into an LDAP query. If this data can be controlled by an external user, this is an LDAP injection. Ensure data passed to an LDAP query is not controllable; or properly sanitize the data."},"help":{"markdown":"Detected non-constant data passed into an LDAP query. If this data can be controlled by an external user, this is an LDAP injection. Ensure data passed to an LDAP query is not controllable; or properly sanitize the data.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.ldap-injection.ldap-injection)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"Detected non-constant data passed into an LDAP query. If this data can be controlled by an external user, this is an LDAP injection. Ensure data passed to an LDAP query is not controllable; or properly sanitize the data."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.ldap-injection.ldap-injection","id":"java.lang.security.audit.ldap-injection.ldap-injection","name":"java.lang.security.audit.ldap-injection.ldap-injection","properties":{"precision":"very-high","tags":["CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')","LOW CONFIDENCE","OWASP-A01:2017 - Injection","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.ldap-injection.ldap-injection"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object."},"help":{"markdown":"Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.object-deserialization.object-deserialization)\n - [https://www.owasp.org/index.php/Deserialization_of_untrusted_data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data)\n - [https://www.oracle.com/java/technologies/javase/seccodeguide.html#8](https://www.oracle.com/java/technologies/javase/seccodeguide.html#8)\n","text":"Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.object-deserialization.object-deserialization","id":"java.lang.security.audit.object-deserialization.object-deserialization","name":"java.lang.security.audit.object-deserialization.object-deserialization","properties":{"precision":"very-high","tags":["CWE-502: Deserialization of Untrusted Data","LOW CONFIDENCE","OWASP-A08:2017 - Insecure Deserialization","OWASP-A08:2021 - Software and Data Integrity Failures","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.object-deserialization.object-deserialization"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation."},"help":{"markdown":"A expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.ognl-injection.ognl-injection)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"A expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.ognl-injection.ognl-injection","id":"java.lang.security.audit.ognl-injection.ognl-injection","name":"java.lang.security.audit.ognl-injection.ognl-injection","properties":{"precision":"very-high","tags":["CWE-94: Improper Control of Generation of Code ('Code Injection')","LOW CONFIDENCE","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.ognl-injection.ognl-injection"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Detected file permissions that are overly permissive (read, write, and execute). It is generally a bad practices to set overly permissive file permission such as read+write+exec for all users. If the file affected is a configuration, a binary, a script or sensitive data, it can lead to privilege escalation or information leakage. Instead, follow the principle of least privilege and give users only the  permissions they need."},"help":{"markdown":"Detected file permissions that are overly permissive (read, write, and execute). It is generally a bad practices to set overly permissive file permission such as read+write+exec for all users. If the file affected is a configuration, a binary, a script or sensitive data, it can lead to privilege escalation or information leakage. Instead, follow the principle of least privilege and give users only the  permissions they need.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission)\n - [https://owasp.org/Top10/A01_2021-Broken_Access_Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control)\n","text":"Detected file permissions that are overly permissive (read, write, and execute). It is generally a bad practices to set overly permissive file permission such as read+write+exec for all users. If the file affected is a configuration, a binary, a script or sensitive data, it can lead to privilege escalation or information leakage. Instead, follow the principle of least privilege and give users only the  permissions they need."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission","id":"java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission","name":"java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission","properties":{"precision":"very-high","tags":["CWE-276: Incorrect Default Permissions","LOW CONFIDENCE","OWASP-A01:2021 - Broken Access Control","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"https://find-sec-bugs.github.io/bugs.htm#PERMISSIVE_CORS Permissive CORS policy will allow a malicious application to communicate with the victim application in an inappropriate way, leading to spoofing, data theft, relay and other attacks."},"help":{"markdown":"https://find-sec-bugs.github.io/bugs.htm#PERMISSIVE_CORS Permissive CORS policy will allow a malicious application to communicate with the victim application in an inappropriate way, leading to spoofing, data theft, relay and other attacks.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.permissive-cors.permissive-cors)\n - [https://owasp.org/Top10/A04_2021-Insecure_Design](https://owasp.org/Top10/A04_2021-Insecure_Design)\n","text":"https://find-sec-bugs.github.io/bugs.htm#PERMISSIVE_CORS Permissive CORS policy will allow a malicious application to communicate with the victim application in an inappropriate way, leading to spoofing, data theft, relay and other attacks."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.permissive-cors.permissive-cors","id":"java.lang.security.audit.permissive-cors.permissive-cors","name":"java.lang.security.audit.permissive-cors.permissive-cors","properties":{"precision":"very-high","tags":["CWE-183: Permissive List of Allowed Inputs","LOW CONFIDENCE","OWASP-A04:2021 - Insecure Design","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.permissive-cors.permissive-cors"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Detected potential code injection using ScriptEngine. Ensure user-controlled data cannot enter '.eval()', otherwise, this is a code injection vulnerability."},"help":{"markdown":"Detected potential code injection using ScriptEngine. Ensure user-controlled data cannot enter '.eval()', otherwise, this is a code injection vulnerability.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.script-engine-injection.script-engine-injection)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"Detected potential code injection using ScriptEngine. Ensure user-controlled data cannot enter '.eval()', otherwise, this is a code injection vulnerability."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.script-engine-injection.script-engine-injection","id":"java.lang.security.audit.script-engine-injection.script-engine-injection","name":"java.lang.security.audit.script-engine-injection.script-engine-injection","properties":{"precision":"very-high","tags":["CWE-94: Improper Control of Generation of Code ('Code Injection')","LOW CONFIDENCE","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.script-engine-injection.script-engine-injection"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Application redirects to a destination URL specified by a user-supplied parameter that is not validated. This could direct users to malicious locations. Consider using an allowlist to validate URLs."},"help":{"markdown":"Application redirects to a destination URL specified by a user-supplied parameter that is not validated. This could direct users to malicious locations. Consider using an allowlist to validate URLs.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.unvalidated-redirect.unvalidated-redirect)\n - [https://owasp.org/Top10/A01_2021-Broken_Access_Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control)\n","text":"Application redirects to a destination URL specified by a user-supplied parameter that is not validated. This could direct users to malicious locations. Consider using an allowlist to validate URLs."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.unvalidated-redirect.unvalidated-redirect","id":"java.lang.security.audit.unvalidated-redirect.unvalidated-redirect","name":"java.lang.security.audit.unvalidated-redirect.unvalidated-redirect","properties":{"precision":"very-high","tags":["CWE-601: URL Redirection to Untrusted Site ('Open Redirect')","MEDIUM CONFIDENCE","OWASP-A01:2021 - Broken Access Control","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.unvalidated-redirect.unvalidated-redirect"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"URL rewriting has significant security risks. Since session ID appears in the URL, it may be easily seen by third parties."},"help":{"markdown":"URL rewriting has significant security risks. Since session ID appears in the URL, it may be easily seen by third parties.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.url-rewriting.url-rewriting)\n - [https://owasp.org/Top10/A01_2021-Broken_Access_Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control)\n","text":"URL rewriting has significant security risks. Since session ID appears in the URL, it may be easily seen by third parties."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.url-rewriting.url-rewriting","id":"java.lang.security.audit.url-rewriting.url-rewriting","name":"java.lang.security.audit.url-rewriting.url-rewriting","properties":{"precision":"very-high","tags":["CWE-200: Exposure of Sensitive Information to an Unauthorized Actor","LOW CONFIDENCE","OWASP-A01:2021 - Broken Access Control","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.url-rewriting.url-rewriting"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance(\"TLSv1.2\") for the best security."},"help":{"markdown":"An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance(\"TLSv1.2\") for the best security.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.weak-ssl-context.weak-ssl-context)\n - [https://tools.ietf.org/html/rfc7568](https://tools.ietf.org/html/rfc7568)\n - [https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html](https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html)\n","text":"An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance(\"TLSv1.2\") for the best security."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.weak-ssl-context.weak-ssl-context","id":"java.lang.security.audit.weak-ssl-context.weak-ssl-context","name":"java.lang.security.audit.weak-ssl-context.weak-ssl-context","properties":{"precision":"very-high","tags":["CWE-326: Inadequate Encryption Strength","HIGH CONFIDENCE","OWASP-A02:2021 - Cryptographic Failures","OWASP-A03:2017 - Sensitive Data Exposure","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.weak-ssl-context.weak-ssl-context"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"XMLDecoder should not be used to parse untrusted data. Deserializing user input can lead to arbitrary code execution. Use an alternative and explicitly disable external entities. See https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html for alternatives and vulnerability prevention."},"help":{"markdown":"XMLDecoder should not be used to parse untrusted data. Deserializing user input can lead to arbitrary code execution. Use an alternative and explicitly disable external entities. See https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html for alternatives and vulnerability prevention.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.xml-decoder.xml-decoder)\n - [https://semgrep.dev/blog/2022/xml-security-in-java](https://semgrep.dev/blog/2022/xml-security-in-java)\n - [https://semgrep.dev/docs/cheat-sheets/java-xxe/](https://semgrep.dev/docs/cheat-sheets/java-xxe/)\n - [https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n","text":"XMLDecoder should not be used to parse untrusted data. Deserializing user input can lead to arbitrary code execution. Use an alternative and explicitly disable external entities. See https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html for alternatives and vulnerability prevention."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.xml-decoder.xml-decoder","id":"java.lang.security.audit.xml-decoder.xml-decoder","name":"java.lang.security.audit.xml-decoder.xml-decoder","properties":{"precision":"very-high","tags":["CWE-611: Improper Restriction of XML External Entity Reference","LOW CONFIDENCE","OWASP-A04:2017 - XML External Entities (XXE)","OWASP-A05:2021 - Security Misconfiguration","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.xml-decoder.xml-decoder"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"It looks like you're using an implementation of XSSRequestWrapper from dzone. (https://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html) The XSS filtering in this code is not secure and can be bypassed by malicious actors. It is recommended to use a stack that automatically escapes in your view or templates instead of filtering yourself."},"help":{"markdown":"It looks like you're using an implementation of XSSRequestWrapper from dzone. (https://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html) The XSS filtering in this code is not secure and can be bypassed by malicious actors. It is recommended to use a stack that automatically escapes in your view or templates instead of filtering yourself.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"It looks like you're using an implementation of XSSRequestWrapper from dzone. (https://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html) The XSS filtering in this code is not secure and can be bypassed by malicious actors. It is recommended to use a stack that automatically escapes in your view or templates instead of filtering yourself."},"helpUri":"https://semgrep.dev/r/java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure","id":"java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure","name":"java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure","properties":{"precision":"very-high","tags":["CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')","LOW CONFIDENCE","OWASP-A03:2021 - Injection","OWASP-A07:2017 - Cross-Site Scripting (XSS)","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Detected a potential path traversal. A malicious actor could control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are sanitized. You may also consider using a utility method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file name from the path."},"help":{"markdown":"Detected a potential path traversal. A malicious actor could control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are sanitized. You may also consider using a utility method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file name from the path.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal)\n - [https://www.owasp.org/index.php/Path_Traversal](https://www.owasp.org/index.php/Path_Traversal)\n","text":"Detected a potential path traversal. A malicious actor could control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are sanitized. You may also consider using a utility method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file name from the path."},"helpUri":"https://semgrep.dev/r/java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal","id":"java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal","name":"java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal","properties":{"precision":"very-high","tags":["CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')","MEDIUM CONFIDENCE","OWASP-A01:2021 - Broken Access Control","OWASP-A05:2017 - Broken Access Control","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User input was detected going directly from the HttpServletRequest into output. Ensure your data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'."},"help":{"markdown":"Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User input was detected going directly from the HttpServletRequest into output. Ensure your data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User input was detected going directly from the HttpServletRequest into output. Ensure your data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'."},"helpUri":"https://semgrep.dev/r/java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss","id":"java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss","name":"java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss","properties":{"precision":"very-high","tags":["CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')","MEDIUM CONFIDENCE","OWASP-A03:2021 - Injection","OWASP-A07:2017 - Cross-Site Scripting (XSS)","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss"}},{"defaultConfiguration":{"level":"error"},"fullDescription":{"text":"XML external entities are enabled for this XMLInputFactory. This is vulnerable to XML external entity attacks. Disable external entities by setting \"javax.xml.stream.isSupportingExternalEntities\" to false."},"help":{"markdown":"XML external entities are enabled for this XMLInputFactory. This is vulnerable to XML external entity attacks. Disable external entities by setting \"javax.xml.stream.isSupportingExternalEntities\" to false.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled)\n - [https://semgrep.dev/blog/2022/xml-security-in-java](https://semgrep.dev/blog/2022/xml-security-in-java)\n - [https://semgrep.dev/docs/cheat-sheets/java-xxe/](https://semgrep.dev/docs/cheat-sheets/java-xxe/)\n - [https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf](https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf)\n","text":"XML external entities are enabled for this XMLInputFactory. This is vulnerable to XML external entity attacks. Disable external entities by setting \"javax.xml.stream.isSupportingExternalEntities\" to false."},"helpUri":"https://semgrep.dev/r/java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled","id":"java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled","name":"java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled","properties":{"precision":"very-high","tags":["CWE-611: Improper Restriction of XML External Entity Reference","LOW CONFIDENCE","OWASP-A04:2017 - XML External Entities (XXE)","OWASP-A05:2021 - Security Misconfiguration","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"XML external entities are not explicitly disabled for this XMLInputFactory. This could be vulnerable to XML external entity vulnerabilities. Explicitly disable external entities by setting \"javax.xml.stream.isSupportingExternalEntities\" to false."},"help":{"markdown":"XML external entities are not explicitly disabled for this XMLInputFactory. This could be vulnerable to XML external entity vulnerabilities. Explicitly disable external entities by setting \"javax.xml.stream.isSupportingExternalEntities\" to false.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe)\n - [https://semgrep.dev/blog/2022/xml-security-in-java](https://semgrep.dev/blog/2022/xml-security-in-java)\n - [https://semgrep.dev/docs/cheat-sheets/java-xxe/](https://semgrep.dev/docs/cheat-sheets/java-xxe/)\n - [https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf](https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf)\n - [https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#xmlinputfactory-a-stax-parser](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#xmlinputfactory-a-stax-parser)\n","text":"XML external entities are not explicitly disabled for this XMLInputFactory. This could be vulnerable to XML external entity vulnerabilities. Explicitly disable external entities by setting \"javax.xml.stream.isSupportingExternalEntities\" to false."},"helpUri":"https://semgrep.dev/r/java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe","id":"java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe","name":"java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe","properties":{"precision":"very-high","tags":["CWE-611: Improper Restriction of XML External Entity Reference","MEDIUM CONFIDENCE","OWASP-A04:2017 - XML External Entities (XXE)","OWASP-A05:2021 - Security Misconfiguration","security"]},"shortDescription":{"text":"Semgrep Finding: java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"A Spring expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation."},"help":{"markdown":"A Spring expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.spring.security.audit.spel-injection.spel-injection)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n","text":"A Spring expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation."},"helpUri":"https://semgrep.dev/r/java.spring.security.audit.spel-injection.spel-injection","id":"java.spring.security.audit.spel-injection.spel-injection","name":"java.spring.security.audit.spel-injection.spel-injection","properties":{"precision":"very-high","tags":["CWE-94: Improper Control of Generation of Code ('Code Injection')","LOW CONFIDENCE","OWASP-A03:2021 - Injection","security"]},"shortDescription":{"text":"Semgrep Finding: java.spring.security.audit.spel-injection.spel-injection"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"CSRF protection is disabled for this configuration. This is a security risk."},"help":{"markdown":"CSRF protection is disabled for this configuration. This is a security risk.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled)\n - [https://owasp.org/Top10/A01_2021-Broken_Access_Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control)\n","text":"CSRF protection is disabled for this configuration. This is a security risk."},"helpUri":"https://semgrep.dev/r/java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled","id":"java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled","name":"java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled","properties":{"precision":"very-high","tags":["CWE-352: Cross-Site Request Forgery (CSRF)","LOW CONFIDENCE","OWASP-A01:2021 - Broken Access Control","security"]},"shortDescription":{"text":"Semgrep Finding: java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled"}},{"defaultConfiguration":{"level":"warning"},"fullDescription":{"text":"Application redirects a user to a destination URL specified by a user supplied parameter that is not validated."},"help":{"markdown":"Application redirects a user to a destination URL specified by a user supplied parameter that is not validated.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect)\n - [https://owasp.org/Top10/A01_2021-Broken_Access_Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control)\n","text":"Application redirects a user to a destination URL specified by a user supplied parameter that is not validated."},"helpUri":"https://semgrep.dev/r/java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect","id":"java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect","name":"java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect","properties":{"precision":"very-high","tags":["CWE-601: URL Redirection to Untrusted Site ('Open Redirect')","MEDIUM CONFIDENCE","OWASP-A01:2021 - Broken Access Control","security"]},"shortDescription":{"text":"Semgrep Finding: java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect"}}],"semanticVersion":"1.141.0"}}}],"$schema":"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/schemas/sarif-schema-2.1.0.json"}